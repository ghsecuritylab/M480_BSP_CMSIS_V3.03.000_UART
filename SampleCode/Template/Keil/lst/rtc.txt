; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\rtc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\rtc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\rtc.crf ..\..\..\Library\StdDriver\src\rtc.c]
                          THUMB

                          AREA ||i.RTC_32KCalibration||, CODE, READONLY, ALIGN=2

                  RTC_32KCalibration PROC
;;;108      */
;;;109    void RTC_32KCalibration(int32_t i32FrequencyX10000)
000000  b510              PUSH     {r4,lr}
;;;110    {
000002  4602              MOV      r2,r0
;;;111        uint64_t u64Compensate;
;;;112    
;;;113        u64Compensate = (uint64_t)(0x2710000000000);
;;;114        u64Compensate = (uint64_t)(u64Compensate / (uint64_t)i32FrequencyX10000);
000004  17c3              ASRS     r3,r0,#31
000006  2000              MOVS     r0,#0
000008  4907              LDR      r1,|L1.40|
00000a  f7fffffe          BL       __aeabi_uldivmod
00000e  4604              MOV      r4,r0
;;;115    
;;;116        if(u64Compensate >= (uint64_t)0x400000)
000010  f44f0080          MOV      r0,#0x400000
000014  1a20              SUBS     r0,r4,r0
000016  f1710000          SBCS     r0,r1,#0
00001a  d300              BCC      |L1.30|
00001c  4c03              LDR      r4,|L1.44|
                  |L1.30|
;;;117        {
;;;118            u64Compensate = (uint64_t)0x3FFFFF;
;;;119        }
;;;120    
;;;121        RTC_WaitAccessEnable();
00001e  f7fffffe          BL       RTC_WaitAccessEnable
;;;122        RTC->FREQADJ = (uint32_t)u64Compensate;
000022  4803              LDR      r0,|L1.48|
000024  6084              STR      r4,[r0,#8]
;;;123    }
000026  bd10              POP      {r4,pc}
;;;124    
                          ENDP

                  |L1.40|
                          DCD      0x00027100
                  |L1.44|
                          DCD      0x003fffff
                  |L1.48|
                          DCD      0x40041000

                          AREA ||i.RTC_Close||, CODE, READONLY, ALIGN=1

                  RTC_Close PROC
;;;95       */
;;;96     void RTC_Close(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;97     {
;;;98         CLK->APBCLK0 &= ~CLK_APBCLK0_RTCCKEN_Msk;
000004  f8d01208          LDR      r1,[r0,#0x208]
000008  f0210102          BIC      r1,r1,#2
00000c  f8c01208          STR      r1,[r0,#0x208]
;;;99     }
000010  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.RTC_DisableInt||, CODE, READONLY, ALIGN=2

                  RTC_DisableInt PROC
;;;764      */
;;;765    void RTC_DisableInt(uint32_t u32IntFlagMask)
000000  b570              PUSH     {r4-r6,lr}
;;;766    {
000002  4605              MOV      r5,r0
;;;767        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;768        RTC->INTEN  &= ~u32IntFlagMask;
000008  4c03              LDR      r4,|L3.24|
00000a  6aa0              LDR      r0,[r4,#0x28]
00000c  43a8              BICS     r0,r0,r5
00000e  62a0              STR      r0,[r4,#0x28]
;;;769        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;770        RTC->INTSTS = u32IntFlagMask;
000014  62e5              STR      r5,[r4,#0x2c]
;;;771    }
000016  bd70              POP      {r4-r6,pc}
;;;772    
                          ENDP

                  |L3.24|
                          DCD      0x40041000

                          AREA ||i.RTC_DisableSpareRegister||, CODE, READONLY, ALIGN=2

                  RTC_DisableSpareRegister PROC
;;;797      */
;;;798    void RTC_DisableSpareRegister(void)
000000  b510              PUSH     {r4,lr}
;;;799    {
;;;800        RTC_WaitAccessEnable();
000002  f7fffffe          BL       RTC_WaitAccessEnable
;;;801    
;;;802        RTC->SPRCTL &= ~RTC_SPRCTL_SPRRWEN_Msk;
000006  4803              LDR      r0,|L4.20|
000008  6bc1              LDR      r1,[r0,#0x3c]
00000a  f0210104          BIC      r1,r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;803    }
000010  bd10              POP      {r4,pc}
;;;804    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperConfig||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperConfig PROC
;;;1044     */
;;;1045   void RTC_DynamicTamperConfig(uint32_t u32ChangeRate, uint32_t u32SeedReload, uint32_t u32RefPattern, uint32_t u32Seed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1046   {
000004  4698              MOV      r8,r3
000006  4615              MOV      r5,r2
000008  460e              MOV      r6,r1
00000a  4607              MOV      r7,r0
;;;1047       uint32_t u32Reg;
;;;1048       RTC_WaitAccessEnable();
00000c  f7fffffe          BL       RTC_WaitAccessEnable
;;;1049       u32Reg = RTC->TAMPCTL;
000010  4c0b              LDR      r4,|L5.64|
000012  f8d40120          LDR      r0,[r4,#0x120]
;;;1050   
;;;1051       u32Reg &= ~(RTC_TAMPCTL_DYNSRC_Msk | RTC_TAMPCTL_SEEDRLD_Msk | RTC_TAMPCTL_DYNRATE_Msk);
;;;1052   
;;;1053       u32Reg |= (u32ChangeRate) | ((u32SeedReload & 0x1ul) << RTC_TAMPCTL_SEEDRLD_Pos) |
000016  f0060101          AND      r1,r6,#1
00001a  ea471101          ORR      r1,r7,r1,LSL #4
00001e  f0050203          AND      r2,r5,#3
000022  f02000fc          BIC      r0,r0,#0xfc           ;1051
000026  ea410582          ORR      r5,r1,r2,LSL #2
00002a  4305              ORRS     r5,r5,r0
00002c  f5047490          ADD      r4,r4,#0x120
;;;1054                 ((u32RefPattern & 0x3ul) << RTC_TAMPCTL_DYNSRC_Pos);
;;;1055   
;;;1056       RTC_WaitAccessEnable();
000030  f7fffffe          BL       RTC_WaitAccessEnable
;;;1057       RTC->TAMPSEED = u32Seed; /* need set seed value before re-load seed */
000034  f8c48008          STR      r8,[r4,#8]
;;;1058       RTC->TAMPCTL = u32Reg;
000038  6025              STR      r5,[r4,#0]
;;;1059   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1060   
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperDisable||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperDisable PROC
;;;980      */
;;;981    void RTC_DynamicTamperDisable(uint32_t u32PairSel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;982    {
;;;983        uint32_t i;
;;;984        uint32_t u32Reg;
;;;985        uint32_t u32TmpReg;
;;;986        uint32_t u32Tamper2En = 0ul, u32Tamper4En = 0ul;
000004  2500              MOVS     r5,#0
000006  4604              MOV      r4,r0                 ;982
000008  462e              MOV      r6,r5
;;;987    
;;;988        RTC_WaitAccessEnable();
00000a  f7fffffe          BL       RTC_WaitAccessEnable
;;;989        u32Reg = RTC->TAMPCTL;
00000e  4f13              LDR      r7,|L6.92|
000010  f8d71120          LDR      r1,[r7,#0x120]
;;;990    
;;;991        if((u32Reg & RTC_TAMPCTL_DYN1ISS_Msk) && (u32PairSel & RTC_PAIR1_SELECT))
000014  07c8              LSLS     r0,r1,#31
000016  d003              BEQ      |L6.32|
000018  07a0              LSLS     r0,r4,#30
00001a  d501              BPL      |L6.32|
;;;992        {
;;;993            u32Tamper2En = u32Reg & RTC_TAMPCTL_TAMP2EN_Msk;
00001c  f4013580          AND      r5,r1,#0x10000
                  |L6.32|
;;;994        }
;;;995    
;;;996        if((u32Reg & RTC_TAMPCTL_DYN2ISS_Msk) && (u32PairSel & RTC_PAIR2_SELECT))
000020  0788              LSLS     r0,r1,#30
000022  d503              BPL      |L6.44|
000024  0760              LSLS     r0,r4,#29
000026  d501              BPL      |L6.44|
;;;997        {
;;;998            u32Tamper4En = u32Reg & RTC_TAMPCTL_TAMP4EN_Msk;
000028  f0017680          AND      r6,r1,#0x1000000
                  |L6.44|
;;;999        }
;;;1000   
;;;1001       u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
00002c  f44f4311          MOV      r3,#0x9100
;;;1002   
;;;1003       for(i = 0ul; i < MAX_PAIR_NUM; i++)
000030  2000              MOVS     r0,#0
;;;1004       {
;;;1005           if(u32PairSel & (0x1ul << i))
000032  f04f0c01          MOV      r12,#1
                  |L6.54|
000036  fa0cf200          LSL      r2,r12,r0
00003a  4222              TST      r2,r4
00003c  d003              BEQ      |L6.70|
;;;1006           {
;;;1007               u32Reg &= ~(u32TmpReg << ((i*8ul)));
00003e  00c2              LSLS     r2,r0,#3
000040  fa03f202          LSL      r2,r3,r2
000044  4391              BICS     r1,r1,r2
                  |L6.70|
000046  1c40              ADDS     r0,r0,#1
000048  2803              CMP      r0,#3                 ;1003
00004a  d3f4              BCC      |L6.54|
;;;1008           }
;;;1009       }
;;;1010   
;;;1011       u32Reg |= (u32Tamper2En | u32Tamper4En);
00004c  4335              ORRS     r5,r5,r6
00004e  430d              ORRS     r5,r5,r1
;;;1012   
;;;1013       RTC_WaitAccessEnable();
000050  f7fffffe          BL       RTC_WaitAccessEnable
;;;1014       RTC->TAMPCTL = u32Reg;
000054  f8c75120          STR      r5,[r7,#0x120]
;;;1015   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1016   
                          ENDP

                  |L6.92|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperEnable||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperEnable PROC
;;;915      */
;;;916    void RTC_DynamicTamperEnable(uint32_t u32PairSel, uint32_t u32DebounceEn, uint32_t u32Pair1Source, uint32_t u32Pair2Source)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;917    {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  468a              MOV      r10,r1
00000a  4605              MOV      r5,r0
;;;918        uint32_t i;
;;;919        uint32_t u32Reg;
;;;920        uint32_t u32TmpReg;
;;;921        uint32_t u32Tamper2Debounce, u32Tamper4Debounce;
;;;922    
;;;923        RTC_WaitAccessEnable();
00000c  f7fffffe          BL       RTC_WaitAccessEnable
;;;924        u32Reg = RTC->TAMPCTL;
000010  f8df9080          LDR      r9,|L7.148|
000014  f8d90120          LDR      r0,[r9,#0x120]
;;;925    
;;;926        u32Tamper2Debounce = u32Reg & RTC_TAMPCTL_TAMP2DBEN_Msk;
;;;927        u32Tamper4Debounce = u32Reg & RTC_TAMPCTL_TAMP4DBEN_Msk;
;;;928    
;;;929        u32Reg &= ~(RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_TAMP2EN_Msk |
000018  491f              LDR      r1,|L7.152|
00001a  f4002880          AND      r8,r0,#0x40000        ;926
00001e  f0006c80          AND      r12,r0,#0x4000000     ;927
000022  4008              ANDS     r0,r0,r1
;;;930                    RTC_TAMPCTL_TAMP3EN_Msk | RTC_TAMPCTL_TAMP4EN_Msk | RTC_TAMPCTL_TAMP5EN_Msk);
;;;931        u32Reg &= ~(RTC_TAMPCTL_DYN1ISS_Msk | RTC_TAMPCTL_DYN2ISS_Msk);
;;;932        u32Reg |= ((u32Pair1Source & 0x1ul) << RTC_TAMPCTL_DYN1ISS_Pos) | ((u32Pair2Source & 0x1ul) << RTC_TAMPCTL_DYN2ISS_Pos);
000024  f0070101          AND      r1,r7,#1
000028  4634              MOV      r4,r6
00002a  f0200003          BIC      r0,r0,#3              ;931
00002e  f361045f          BFI      r4,r1,#1,#31
000032  4304              ORRS     r4,r4,r0
;;;933    
;;;934        if(u32DebounceEn)
000034  f1ba0f00          CMP      r10,#0
000038  d002              BEQ      |L7.64|
;;;935        {
;;;936            u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk |
00003a  f44f4255          MOV      r2,#0xd500
00003e  e001              B        |L7.68|
                  |L7.64|
;;;937                         RTC_TAMPCTL_TAMP0DBEN_Msk | RTC_TAMPCTL_TAMP1DBEN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
;;;938        }
;;;939        else
;;;940        {
;;;941            u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
000040  f44f4211          MOV      r2,#0x9100
                  |L7.68|
;;;942        }
;;;943    
;;;944        for(i = 0ul; i < MAX_PAIR_NUM; i++)
000044  2000              MOVS     r0,#0
;;;945        {
;;;946            if(u32PairSel & (0x1ul << i))
000046  f04f0a01          MOV      r10,#1
;;;947            {
;;;948                u32Reg &= ~((RTC_TAMPCTL_TAMP0DBEN_Msk | RTC_TAMPCTL_TAMP1DBEN_Msk) << (i*8ul));
00004a  f44f4b88          MOV      r11,#0x4400
                  |L7.78|
00004e  fa0af100          LSL      r1,r10,r0             ;946
000052  4229              TST      r1,r5                 ;946
000054  d006              BEQ      |L7.100|
000056  00c1              LSLS     r1,r0,#3
000058  fa0bf301          LSL      r3,r11,r1
00005c  439c              BICS     r4,r4,r3
;;;949                u32Reg |= (u32TmpReg << (i*8ul));
00005e  fa02f301          LSL      r3,r2,r1
000062  431c              ORRS     r4,r4,r3
                  |L7.100|
000064  1c40              ADDS     r0,r0,#1
000066  2803              CMP      r0,#3                 ;944
000068  d3f1              BCC      |L7.78|
;;;950            }
;;;951        }
;;;952    
;;;953        if((u32Pair1Source) && (u32PairSel & RTC_PAIR1_SELECT))
00006a  b12e              CBZ      r6,|L7.120|
00006c  07a8              LSLS     r0,r5,#30
00006e  d503              BPL      |L7.120|
;;;954        {
;;;955            u32Reg &= ~RTC_TAMPCTL_TAMP2EN_Msk;
000070  f4243480          BIC      r4,r4,#0x10000
;;;956            u32Reg |= u32Tamper2Debounce;
000074  ea440408          ORR      r4,r4,r8
                  |L7.120|
;;;957        }
;;;958    
;;;959        if((u32Pair2Source) && (u32PairSel & RTC_PAIR2_SELECT))
000078  b12f              CBZ      r7,|L7.134|
00007a  0768              LSLS     r0,r5,#29
00007c  d503              BPL      |L7.134|
;;;960        {
;;;961            u32Reg &= ~RTC_TAMPCTL_TAMP4EN_Msk;
00007e  f0247480          BIC      r4,r4,#0x1000000
;;;962            u32Reg |= u32Tamper4Debounce;
000082  ea44040c          ORR      r4,r4,r12
                  |L7.134|
;;;963        }
;;;964    
;;;965        RTC_WaitAccessEnable();
000086  f7fffffe          BL       RTC_WaitAccessEnable
;;;966        RTC->TAMPCTL = u32Reg;
00008a  f8c94120          STR      r4,[r9,#0x120]
;;;967    }
00008e  e8bd9ff0          POP      {r4-r12,pc}
;;;968    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      0x40041000
                  |L7.152|
                          DCD      0xeeeeeeff

                          AREA ||i.RTC_EnableInt||, CODE, READONLY, ALIGN=2

                  RTC_EnableInt PROC
;;;741      */
;;;742    void RTC_EnableInt(uint32_t u32IntFlagMask)
000000  b510              PUSH     {r4,lr}
;;;743    {
000002  4604              MOV      r4,r0
;;;744        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;745        RTC->INTEN |= u32IntFlagMask;
000008  4902              LDR      r1,|L8.20|
00000a  6a8a              LDR      r2,[r1,#0x28]
00000c  4322              ORRS     r2,r2,r4
00000e  628a              STR      r2,[r1,#0x28]
;;;746    }
000010  bd10              POP      {r4,pc}
;;;747    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40041000

                          AREA ||i.RTC_EnableSpareAccess||, CODE, READONLY, ALIGN=2

                  RTC_EnableSpareAccess PROC
;;;781      */
;;;782    void RTC_EnableSpareAccess(void)
000000  b510              PUSH     {r4,lr}
;;;783    {
;;;784        RTC_WaitAccessEnable();
000002  f7fffffe          BL       RTC_WaitAccessEnable
;;;785    
;;;786        RTC->SPRCTL |= RTC_SPRCTL_SPRRWEN_Msk;
000006  4803              LDR      r0,|L9.20|
000008  6bc1              LDR      r1,[r0,#0x3c]
00000a  f0410104          ORR      r1,r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;787    }
000010  bd10              POP      {r4,pc}
;;;788    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40041000

                          AREA ||i.RTC_GetAlarmDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmDateAndTime PROC
;;;237      */
;;;238    void RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {
;;;240        uint32_t u32Tmp;
;;;241    
;;;242        sPt->u32TimeScale = RTC->CLKFMT & RTC_CLKFMT_24HEN_Msk;     /* 12/24-hour */
000002  4e3c              LDR      r6,|L10.244|
000004  4604              MOV      r4,r0                 ;239
000006  6970              LDR      r0,[r6,#0x14]
000008  f0000001          AND      r0,r0,#1
;;;243        sPt->u32DayOfWeek = RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk; /* Day of the week */
00000c  61e0              STR      r0,[r4,#0x1c]
00000e  69b0              LDR      r0,[r6,#0x18]
000010  f0000007          AND      r0,r0,#7
;;;244    
;;;245        /* Get alarm [Date digit] data */
;;;246        RTC_WaitAccessEnable();
000014  60e0              STR      r0,[r4,#0xc]
000016  f7fffffe          BL       RTC_WaitAccessEnable
;;;247        g_u32hiYear  = (RTC->CALM & RTC_CALM_TENYEAR_Msk) >> RTC_CALM_TENYEAR_Pos;
00001a  6a30              LDR      r0,[r6,#0x20]
00001c  4d36              LDR      r5,|L10.248|
00001e  f3c05003          UBFX     r0,r0,#20,#4
000022  6028              STR      r0,[r5,#0]  ; g_u32hiYear
;;;248        g_u32loYear  = (RTC->CALM & RTC_CALM_YEAR_Msk) >> RTC_CALM_YEAR_Pos;
000024  6a30              LDR      r0,[r6,#0x20]
000026  f3c04003          UBFX     r0,r0,#16,#4
00002a  6068              STR      r0,[r5,#4]  ; g_u32loYear
;;;249        g_u32hiMonth = (RTC->CALM & RTC_CALM_TENMON_Msk) >> RTC_CALM_TENMON_Pos;
00002c  6a30              LDR      r0,[r6,#0x20]
00002e  f3c03000          UBFX     r0,r0,#12,#1
000032  60a8              STR      r0,[r5,#8]  ; g_u32hiMonth
;;;250        g_u32loMonth = (RTC->CALM & RTC_CALM_MON_Msk) >> RTC_CALM_MON_Pos;
000034  6a30              LDR      r0,[r6,#0x20]
000036  f3c02003          UBFX     r0,r0,#8,#4
00003a  60e8              STR      r0,[r5,#0xc]  ; g_u32loMonth
;;;251        g_u32hiDay   = (RTC->CALM & RTC_CALM_TENDAY_Msk) >> RTC_CALM_TENDAY_Pos;
00003c  6a30              LDR      r0,[r6,#0x20]
00003e  f3c01001          UBFX     r0,r0,#4,#2
000042  6128              STR      r0,[r5,#0x10]  ; g_u32hiDay
;;;252        g_u32loDay   = (RTC->CALM & RTC_CALM_DAY_Msk) >> RTC_CALM_DAY_Pos;
000044  6a30              LDR      r0,[r6,#0x20]
000046  f000000f          AND      r0,r0,#0xf
00004a  6168              STR      r0,[r5,#0x14]  ; g_u32loDay
;;;253    
;;;254        /* Get alarm [Time digit] data */
;;;255        RTC_WaitAccessEnable();
00004c  f7fffffe          BL       RTC_WaitAccessEnable
;;;256        g_u32hiHour = (RTC->TALM & RTC_TALM_TENHR_Msk) >> RTC_TALM_TENHR_Pos;
000050  69f0              LDR      r0,[r6,#0x1c]
000052  f3c05001          UBFX     r0,r0,#20,#2
000056  61a8              STR      r0,[r5,#0x18]  ; g_u32hiHour
;;;257        g_u32loHour = (RTC->TALM & RTC_TALM_HR_Msk) >> RTC_TALM_HR_Pos;
000058  69f0              LDR      r0,[r6,#0x1c]
00005a  f3c04003          UBFX     r0,r0,#16,#4
00005e  61e8              STR      r0,[r5,#0x1c]  ; g_u32loHour
;;;258        g_u32hiMin  = (RTC->TALM & RTC_TALM_TENMIN_Msk) >> RTC_TALM_TENMIN_Pos;
000060  69f0              LDR      r0,[r6,#0x1c]
000062  f3c03002          UBFX     r0,r0,#12,#3
000066  6228              STR      r0,[r5,#0x20]  ; g_u32hiMin
;;;259        g_u32loMin  = (RTC->TALM & RTC_TALM_MIN_Msk) >> RTC_TALM_MIN_Pos;
000068  69f0              LDR      r0,[r6,#0x1c]
00006a  f3c02003          UBFX     r0,r0,#8,#4
00006e  6268              STR      r0,[r5,#0x24]  ; g_u32loMin
;;;260        g_u32hiSec  = (RTC->TALM & RTC_TALM_TENSEC_Msk) >> RTC_TALM_TENSEC_Pos;
000070  69f0              LDR      r0,[r6,#0x1c]
000072  f3c01002          UBFX     r0,r0,#4,#3
000076  62a8              STR      r0,[r5,#0x28]  ; g_u32hiSec
;;;261        g_u32loSec  = (RTC->TALM & RTC_TALM_SEC_Msk) >> RTC_TALM_SEC_Pos;
000078  69f0              LDR      r0,[r6,#0x1c]
00007a  f000000f          AND      r0,r0,#0xf
00007e  62e8              STR      r0,[r5,#0x2c]  ; g_u32loSec
;;;262    
;;;263        /* Compute to 20XX year */
;;;264        u32Tmp  = (g_u32hiYear * 10ul);
000080  6828              LDR      r0,[r5,#0]  ; g_u32hiYear
;;;265        u32Tmp += g_u32loYear;
000082  6869              LDR      r1,[r5,#4]  ; g_u32loYear
000084  eb000080          ADD      r0,r0,r0,LSL #2       ;264
000088  eb010040          ADD      r0,r1,r0,LSL #1
00008c  f50060fa          ADD      r0,r0,#0x7d0
;;;266        sPt->u32Year = u32Tmp + RTC_YEAR2000;
;;;267    
;;;268        /* Compute 0~12 month */
;;;269        u32Tmp = (g_u32hiMonth * 10ul);
000090  6020              STR      r0,[r4,#0]
000092  68a8              LDR      r0,[r5,#8]  ; g_u32hiMonth
;;;270        sPt->u32Month = u32Tmp + g_u32loMonth;
000094  68e9              LDR      r1,[r5,#0xc]  ; g_u32loMonth
000096  eb000080          ADD      r0,r0,r0,LSL #2       ;269
00009a  eb010040          ADD      r0,r1,r0,LSL #1
;;;271    
;;;272        /* Compute 0~31 day */
;;;273        u32Tmp = (g_u32hiDay * 10ul);
00009e  6060              STR      r0,[r4,#4]
0000a0  6928              LDR      r0,[r5,#0x10]  ; g_u32hiDay
;;;274        sPt->u32Day = u32Tmp + g_u32loDay;
0000a2  6969              LDR      r1,[r5,#0x14]  ; g_u32loDay
0000a4  eb000080          ADD      r0,r0,r0,LSL #2       ;273
0000a8  eb010040          ADD      r0,r1,r0,LSL #1
;;;275    
;;;276        /* Compute 12/24 hour */
;;;277        if(sPt->u32TimeScale == RTC_CLOCK_12)
0000ac  60a0              STR      r0,[r4,#8]
0000ae  69e0              LDR      r0,[r4,#0x1c]
0000b0  2800              CMP      r0,#0
;;;278        {
;;;279            u32Tmp  = (g_u32hiHour * 10ul);
;;;280            u32Tmp += g_u32loHour;
;;;281            sPt->u32Hour = u32Tmp;          /* AM: 1~12. PM: 21~32. */
;;;282    
;;;283            if(sPt->u32Hour >= 21ul)
;;;284            {
;;;285                sPt->u32AmPm  = RTC_PM;
;;;286                sPt->u32Hour -= 20ul;
;;;287            }
;;;288            else
;;;289            {
;;;290                sPt->u32AmPm = RTC_AM;
;;;291            }
;;;292    
;;;293            u32Tmp  = (g_u32hiMin * 10ul);
;;;294            u32Tmp += g_u32loMin;
;;;295            sPt->u32Minute = u32Tmp;
;;;296    
;;;297            u32Tmp  = (g_u32hiSec * 10ul);
;;;298            u32Tmp += g_u32loSec;
;;;299            sPt->u32Second = u32Tmp;
;;;300    
;;;301        }
;;;302        else
;;;303        {
;;;304            u32Tmp  = (g_u32hiHour * 10ul);
0000b2  69a8              LDR      r0,[r5,#0x18]  ; g_u32hiHour
;;;305            u32Tmp +=  g_u32loHour;
0000b4  69e9              LDR      r1,[r5,#0x1c]  ; g_u32loHour
0000b6  eb000080          ADD      r0,r0,r0,LSL #2       ;304
0000ba  ea4f0040          LSL      r0,r0,#1              ;304
0000be  4408              ADD      r0,r0,r1
0000c0  d105              BNE      |L10.206|
0000c2  6120              STR      r0,[r4,#0x10]         ;283
0000c4  2815              CMP      r0,#0x15              ;283
0000c6  d304              BCC      |L10.210|
0000c8  2102              MOVS     r1,#2                 ;285
0000ca  3814              SUBS     r0,r0,#0x14           ;285
0000cc  6221              STR      r1,[r4,#0x20]         ;285
                  |L10.206|
;;;306            sPt->u32Hour = u32Tmp;
0000ce  6120              STR      r0,[r4,#0x10]
0000d0  e001              B        |L10.214|
                  |L10.210|
0000d2  2001              MOVS     r0,#1                 ;290
0000d4  6220              STR      r0,[r4,#0x20]         ;290
                  |L10.214|
0000d6  6a28              LDR      r0,[r5,#0x20]         ;293  ; g_u32hiMin
0000d8  6a69              LDR      r1,[r5,#0x24]         ;294  ; g_u32loMin
0000da  eb000080          ADD      r0,r0,r0,LSL #2       ;293
0000de  eb010040          ADD      r0,r1,r0,LSL #1       ;294
0000e2  6160              STR      r0,[r4,#0x14]         ;297
0000e4  6aa8              LDR      r0,[r5,#0x28]         ;297  ; g_u32hiSec
0000e6  6ae9              LDR      r1,[r5,#0x2c]         ;298  ; g_u32loSec
0000e8  eb000080          ADD      r0,r0,r0,LSL #2       ;297
0000ec  eb010040          ADD      r0,r1,r0,LSL #1       ;298
0000f0  61a0              STR      r0,[r4,#0x18]         ;299
;;;307    
;;;308            u32Tmp  = (g_u32hiMin * 10ul);
;;;309            u32Tmp += g_u32loMin;
;;;310            sPt->u32Minute = u32Tmp;
;;;311    
;;;312            u32Tmp  = (g_u32hiSec * 10ul);
;;;313            u32Tmp += g_u32loSec;
;;;314            sPt->u32Second = u32Tmp;
;;;315        }
;;;316    }
0000f2  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

                  |L10.244|
                          DCD      0x40041000
                  |L10.248|
                          DCD      ||.data||

                          AREA ||i.RTC_GetDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_GetDateAndTime PROC
;;;142      */
;;;143    void RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  4a38              LDR      r2,|L11.228|
;;;144    {
000002  b510              PUSH     {r4,lr}
;;;145        uint32_t u32Tmp;
;;;146    
;;;147        sPt->u32TimeScale = RTC->CLKFMT & RTC_CLKFMT_24HEN_Msk;     /* 12/24-hour */
000004  6951              LDR      r1,[r2,#0x14]
000006  f0110301          ANDS     r3,r1,#1
;;;148        sPt->u32DayOfWeek = RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk; /* Day of the week */
00000a  61c3              STR      r3,[r0,#0x1c]
00000c  6991              LDR      r1,[r2,#0x18]
00000e  f0010107          AND      r1,r1,#7
;;;149    
;;;150        /* Get [Date digit] data */
;;;151        g_u32hiYear  = (RTC->CAL & RTC_CAL_TENYEAR_Msk) >> RTC_CAL_TENYEAR_Pos;
000012  60c1              STR      r1,[r0,#0xc]
000014  6911              LDR      r1,[r2,#0x10]
000016  f3c15403          UBFX     r4,r1,#20,#4
00001a  4933              LDR      r1,|L11.232|
00001c  600c              STR      r4,[r1,#0]  ; g_u32hiYear
;;;152        g_u32loYear  = (RTC->CAL & RTC_CAL_YEAR_Msk) >> RTC_CAL_YEAR_Pos;
00001e  6914              LDR      r4,[r2,#0x10]
000020  f3c44403          UBFX     r4,r4,#16,#4
000024  604c              STR      r4,[r1,#4]  ; g_u32loYear
;;;153        g_u32hiMonth = (RTC->CAL & RTC_CAL_TENMON_Msk) >> RTC_CAL_TENMON_Pos;
000026  6914              LDR      r4,[r2,#0x10]
000028  f3c43400          UBFX     r4,r4,#12,#1
00002c  608c              STR      r4,[r1,#8]  ; g_u32hiMonth
;;;154        g_u32loMonth = (RTC->CAL & RTC_CAL_MON_Msk) >> RTC_CAL_MON_Pos;
00002e  6914              LDR      r4,[r2,#0x10]
000030  f3c42403          UBFX     r4,r4,#8,#4
000034  60cc              STR      r4,[r1,#0xc]  ; g_u32loMonth
;;;155        g_u32hiDay   = (RTC->CAL & RTC_CAL_TENDAY_Msk) >> RTC_CAL_TENDAY_Pos;
000036  6914              LDR      r4,[r2,#0x10]
000038  f3c41401          UBFX     r4,r4,#4,#2
00003c  610c              STR      r4,[r1,#0x10]  ; g_u32hiDay
;;;156        g_u32loDay   = (RTC->CAL & RTC_CAL_DAY_Msk) >> RTC_CAL_DAY_Pos;
00003e  6914              LDR      r4,[r2,#0x10]
000040  f004040f          AND      r4,r4,#0xf
000044  614c              STR      r4,[r1,#0x14]  ; g_u32loDay
;;;157    
;;;158        /* Get [Time digit] data */
;;;159        g_u32hiHour = (RTC->TIME & RTC_TIME_TENHR_Msk) >> RTC_TIME_TENHR_Pos;
000046  68d4              LDR      r4,[r2,#0xc]
000048  f3c45401          UBFX     r4,r4,#20,#2
00004c  618c              STR      r4,[r1,#0x18]  ; g_u32hiHour
;;;160        g_u32loHour = (RTC->TIME & RTC_TIME_HR_Msk) >> RTC_TIME_HR_Pos;
00004e  68d4              LDR      r4,[r2,#0xc]
000050  f3c44403          UBFX     r4,r4,#16,#4
000054  61cc              STR      r4,[r1,#0x1c]  ; g_u32loHour
;;;161        g_u32hiMin  = (RTC->TIME & RTC_TIME_TENMIN_Msk) >> RTC_TIME_TENMIN_Pos;
000056  68d4              LDR      r4,[r2,#0xc]
000058  f3c43402          UBFX     r4,r4,#12,#3
00005c  620c              STR      r4,[r1,#0x20]  ; g_u32hiMin
;;;162        g_u32loMin  = (RTC->TIME & RTC_TIME_MIN_Msk) >> RTC_TIME_MIN_Pos;
00005e  68d4              LDR      r4,[r2,#0xc]
000060  f3c42403          UBFX     r4,r4,#8,#4
000064  624c              STR      r4,[r1,#0x24]  ; g_u32loMin
;;;163        g_u32hiSec  = (RTC->TIME & RTC_TIME_TENSEC_Msk) >> RTC_TIME_TENSEC_Pos;
000066  68d4              LDR      r4,[r2,#0xc]
000068  f3c41402          UBFX     r4,r4,#4,#3
00006c  628c              STR      r4,[r1,#0x28]  ; g_u32hiSec
;;;164        g_u32loSec  = (RTC->TIME & RTC_TIME_SEC_Msk) >> RTC_TIME_SEC_Pos;
00006e  68d2              LDR      r2,[r2,#0xc]
000070  f002020f          AND      r2,r2,#0xf
000074  62ca              STR      r2,[r1,#0x2c]  ; g_u32loSec
;;;165    
;;;166        /* Compute to 20XX year */
;;;167        u32Tmp  = (g_u32hiYear * 10ul);
000076  680a              LDR      r2,[r1,#0]  ; g_u32hiYear
;;;168        u32Tmp += g_u32loYear;
000078  684c              LDR      r4,[r1,#4]  ; g_u32loYear
00007a  eb020282          ADD      r2,r2,r2,LSL #2       ;167
00007e  eb040242          ADD      r2,r4,r2,LSL #1
000082  f50262fa          ADD      r2,r2,#0x7d0
;;;169        sPt->u32Year = u32Tmp + RTC_YEAR2000;
;;;170    
;;;171        /* Compute 0~12 month */
;;;172        u32Tmp = (g_u32hiMonth * 10ul);
000086  6002              STR      r2,[r0,#0]
000088  688a              LDR      r2,[r1,#8]  ; g_u32hiMonth
;;;173        sPt->u32Month = u32Tmp + g_u32loMonth;
00008a  68cc              LDR      r4,[r1,#0xc]  ; g_u32loMonth
00008c  eb020282          ADD      r2,r2,r2,LSL #2       ;172
000090  eb040242          ADD      r2,r4,r2,LSL #1
;;;174    
;;;175        /* Compute 0~31 day */
;;;176        u32Tmp = (g_u32hiDay * 10ul);
000094  6042              STR      r2,[r0,#4]
000096  690a              LDR      r2,[r1,#0x10]  ; g_u32hiDay
;;;177        sPt->u32Day =  u32Tmp  + g_u32loDay;
000098  694c              LDR      r4,[r1,#0x14]  ; g_u32loDay
00009a  eb020282          ADD      r2,r2,r2,LSL #2       ;176
00009e  eb040242          ADD      r2,r4,r2,LSL #1
;;;178    
;;;179        /* Compute 12/24 hour */
;;;180        if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;181        {
;;;182            u32Tmp = (g_u32hiHour * 10ul);
;;;183            u32Tmp += g_u32loHour;
;;;184            sPt->u32Hour = u32Tmp;          /* AM: 1~12. PM: 21~32. */
;;;185    
;;;186            if(sPt->u32Hour >= 21ul)
;;;187            {
;;;188                sPt->u32AmPm  = RTC_PM;
;;;189                sPt->u32Hour -= 20ul;
;;;190            }
;;;191            else
;;;192            {
;;;193                sPt->u32AmPm = RTC_AM;
;;;194            }
;;;195    
;;;196            u32Tmp  = (g_u32hiMin  * 10ul);
;;;197            u32Tmp += g_u32loMin;
;;;198            sPt->u32Minute = u32Tmp;
;;;199    
;;;200            u32Tmp  = (g_u32hiSec  * 10ul);
;;;201            u32Tmp += g_u32loSec;
;;;202            sPt->u32Second = u32Tmp;
;;;203        }
;;;204        else
;;;205        {
;;;206            u32Tmp  = (g_u32hiHour * 10ul);
0000a2  6082              STR      r2,[r0,#8]
0000a4  698a              LDR      r2,[r1,#0x18]  ; g_u32hiHour
;;;207            u32Tmp += g_u32loHour;
0000a6  69cb              LDR      r3,[r1,#0x1c]  ; g_u32loHour
0000a8  eb020282          ADD      r2,r2,r2,LSL #2       ;206
0000ac  eb030242          ADD      r2,r3,r2,LSL #1
0000b0  d105              BNE      |L11.190|
0000b2  6102              STR      r2,[r0,#0x10]         ;186
0000b4  2a15              CMP      r2,#0x15              ;186
0000b6  d304              BCC      |L11.194|
0000b8  2302              MOVS     r3,#2                 ;188
0000ba  3a14              SUBS     r2,r2,#0x14           ;188
0000bc  6203              STR      r3,[r0,#0x20]         ;188
                  |L11.190|
;;;208            sPt->u32Hour = u32Tmp;
0000be  6102              STR      r2,[r0,#0x10]
0000c0  e001              B        |L11.198|
                  |L11.194|
0000c2  2201              MOVS     r2,#1                 ;193
0000c4  6202              STR      r2,[r0,#0x20]         ;193
                  |L11.198|
0000c6  6a0a              LDR      r2,[r1,#0x20]         ;196  ; g_u32hiMin
0000c8  6a4b              LDR      r3,[r1,#0x24]         ;197  ; g_u32loMin
0000ca  eb020282          ADD      r2,r2,r2,LSL #2       ;196
0000ce  eb030242          ADD      r2,r3,r2,LSL #1       ;197
0000d2  6142              STR      r2,[r0,#0x14]         ;200
0000d4  6a8a              LDR      r2,[r1,#0x28]         ;200  ; g_u32hiSec
0000d6  6ac9              LDR      r1,[r1,#0x2c]         ;201  ; g_u32loSec
0000d8  eb020282          ADD      r2,r2,r2,LSL #2       ;200
0000dc  eb010142          ADD      r1,r1,r2,LSL #1       ;201
0000e0  6181              STR      r1,[r0,#0x18]         ;202
;;;209    
;;;210            u32Tmp  = (g_u32hiMin * 10ul);
;;;211            u32Tmp +=  g_u32loMin;
;;;212            sPt->u32Minute = u32Tmp;
;;;213    
;;;214            u32Tmp  = (g_u32hiSec * 10ul);
;;;215            u32Tmp += g_u32loSec;
;;;216            sPt->u32Second = u32Tmp;
;;;217        }
;;;218    }
0000e2  bd10              POP      {r4,pc}
;;;219    
                          ENDP

                  |L11.228|
                          DCD      0x40041000
                  |L11.232|
                          DCD      ||.data||

                          AREA ||i.RTC_GetDayOfWeek||, CODE, READONLY, ALIGN=2

                  RTC_GetDayOfWeek PROC
;;;694      */
;;;695    uint32_t RTC_GetDayOfWeek(void)
000000  4802              LDR      r0,|L12.12|
;;;696    {
;;;697        return (RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk);
000002  6980              LDR      r0,[r0,#0x18]
000004  f0000007          AND      r0,r0,#7
;;;698    }
000008  4770              BX       lr
;;;699    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40041000

                          AREA ||i.RTC_Open||, CODE, READONLY, ALIGN=2

                  RTC_Open PROC
;;;64       */
;;;65     void RTC_Open(S_RTC_TIME_DATA_T *sPt)
000000  4908              LDR      r1,|L13.36|
;;;66     {
;;;67         RTC->INIT = RTC_INIT_KEY;
000002  4a07              LDR      r2,|L13.32|
000004  600a              STR      r2,[r1,#0]
;;;68     
;;;69         if(RTC->INIT != RTC_INIT_ACTIVE_Msk)
000006  680b              LDR      r3,[r1,#0]
000008  2b01              CMP      r3,#1
00000a  d003              BEQ      |L13.20|
;;;70         {
;;;71             RTC->INIT = RTC_INIT_KEY;
00000c  600a              STR      r2,[r1,#0]
                  |L13.14|
;;;72             while(RTC->INIT != RTC_INIT_ACTIVE_Msk)
00000e  680a              LDR      r2,[r1,#0]
000010  2a01              CMP      r2,#1
000012  d1fc              BNE      |L13.14|
                  |L13.20|
;;;73             {
;;;74             }
;;;75         }
;;;76     
;;;77         if(sPt == 0)
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L13.28|
;;;78         {
;;;79         }
;;;80         else
;;;81         {
;;;82             /* Set RTC date and time */
;;;83             RTC_SetDateAndTime(sPt);
000018  f7ffbffe          B.W      RTC_SetDateAndTime
                  |L13.28|
;;;84         }
;;;85     }
00001c  4770              BX       lr
;;;86     
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      0xa5eb1357
                  |L13.36|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDate||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDate PROC
;;;564      */
;;;565    void RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day)
000000  b570              PUSH     {r4-r6,lr}
;;;566    {
;;;567        uint32_t u32RegCALM;
;;;568    
;;;569        u32RegCALM  = ((u32Year - RTC_YEAR2000) / 10ul) << 20;
000002  230a              MOVS     r3,#0xa
000004  f5a060fa          SUB      r0,r0,#0x7d0
000008  fbb0f4f3          UDIV     r4,r0,r3
;;;570        u32RegCALM |= (((u32Year - RTC_YEAR2000) % 10ul) << 16);
00000c  fbb0f5f3          UDIV     r5,r0,r3
000010  fb030015          MLS      r0,r3,r5,r0
000014  0524              LSLS     r4,r4,#20             ;569
000016  ea444000          ORR      r0,r4,r0,LSL #16
;;;571        u32RegCALM |= ((u32Month / 10ul) << 12);
00001a  fbb1f4f3          UDIV     r4,r1,r3
00001e  ea403004          ORR      r0,r0,r4,LSL #12
;;;572        u32RegCALM |= ((u32Month % 10ul) << 8);
000022  fbb1f4f3          UDIV     r4,r1,r3
000026  fb031114          MLS      r1,r3,r4,r1
00002a  ea402001          ORR      r0,r0,r1,LSL #8
;;;573        u32RegCALM |= ((u32Day   / 10ul) << 4);
00002e  fbb2f1f3          UDIV     r1,r2,r3
000032  ea401001          ORR      r0,r0,r1,LSL #4
;;;574        u32RegCALM |= (u32Day   % 10ul);
000036  fbb2f1f3          UDIV     r1,r2,r3
00003a  fb032411          MLS      r4,r3,r1,r2
00003e  4304              ORRS     r4,r4,r0
;;;575    
;;;576        RTC_WaitAccessEnable();
000040  f7fffffe          BL       RTC_WaitAccessEnable
;;;577    
;;;578        /* Set RTC Alarm Date */
;;;579        RTC->CALM = (uint32_t)u32RegCALM;
000044  4801              LDR      r0,|L14.76|
000046  6204              STR      r4,[r0,#0x20]
;;;580    }
000048  bd70              POP      {r4-r6,pc}
;;;581    
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDateAndTime PROC
;;;418      */
;;;419    void RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  0004              MOVS     r4,r0
000004  d050              BEQ      |L15.168|
;;;421        uint32_t u32RegCALM, u32RegTALM;
;;;422    
;;;423        if(sPt == 0)
;;;424        {
;;;425        }
;;;426        else
;;;427        {
;;;428            /*-----------------------------------------------------------------------------------------------------*/
;;;429            /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;430            /*-----------------------------------------------------------------------------------------------------*/
;;;431            RTC_WaitAccessEnable();
000006  f7fffffe          BL       RTC_WaitAccessEnable
;;;432            if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;433            {
;;;434                RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00000a  4d2d              LDR      r5,|L15.192|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;432
00000e  2800              CMP      r0,#0                 ;432
;;;435    
;;;436                /*-------------------------------------------------------------------------------------------------*/
;;;437                /* Important, range of 12-hour PM mode is 21 up to 32                                               */
;;;438                /*-------------------------------------------------------------------------------------------------*/
;;;439                if(sPt->u32AmPm == RTC_PM)
;;;440                {
;;;441                    sPt->u32Hour += 20ul;
;;;442                }
;;;443            }
;;;444            else
;;;445            {
;;;446                RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
000010  6968              LDR      r0,[r5,#0x14]
000012  d04a              BEQ      |L15.170|
000014  f0400001          ORR      r0,r0,#1
000018  6168              STR      r0,[r5,#0x14]
                  |L15.26|
;;;447            }
;;;448    
;;;449            /*-----------------------------------------------------------------------------------------------------*/
;;;450            /* Set RTC Alarm Date and Time                                                                         */
;;;451            /*-----------------------------------------------------------------------------------------------------*/
;;;452            u32RegCALM  = ((sPt->u32Year - RTC_YEAR2000) / 10ul) << 20;
00001a  6821              LDR      r1,[r4,#0]
00001c  200a              MOVS     r0,#0xa
00001e  f5a161fa          SUB      r1,r1,#0x7d0
000022  fbb1f2f0          UDIV     r2,r1,r0
;;;453            u32RegCALM |= (((sPt->u32Year - RTC_YEAR2000) % 10ul) << 16);
000026  fbb1f3f0          UDIV     r3,r1,r0
00002a  fb001113          MLS      r1,r0,r3,r1
00002e  0512              LSLS     r2,r2,#20             ;452
000030  ea424201          ORR      r2,r2,r1,LSL #16
;;;454            u32RegCALM |= ((sPt->u32Month  / 10ul) << 12);
000034  6861              LDR      r1,[r4,#4]
000036  fbb1f3f0          UDIV     r3,r1,r0
00003a  ea423203          ORR      r2,r2,r3,LSL #12
;;;455            u32RegCALM |= ((sPt->u32Month  % 10ul) << 8);
00003e  fbb1f3f0          UDIV     r3,r1,r0
000042  fb001113          MLS      r1,r0,r3,r1
000046  ea422201          ORR      r2,r2,r1,LSL #8
;;;456            u32RegCALM |= ((sPt->u32Day    / 10ul) << 4);
00004a  68a1              LDR      r1,[r4,#8]
00004c  fbb1f3f0          UDIV     r3,r1,r0
000050  ea421203          ORR      r2,r2,r3,LSL #4
;;;457            u32RegCALM |= (sPt->u32Day    % 10ul);
000054  fbb1f3f0          UDIV     r3,r1,r0
000058  fb001613          MLS      r6,r0,r3,r1
;;;458    
;;;459            u32RegTALM  = ((sPt->u32Hour   / 10ul) << 20);
00005c  6921              LDR      r1,[r4,#0x10]
00005e  4316              ORRS     r6,r6,r2              ;457
000060  fbb1f2f0          UDIV     r2,r1,r0
;;;460            u32RegTALM |= ((sPt->u32Hour   % 10ul) << 16);
000064  fbb1f3f0          UDIV     r3,r1,r0
000068  fb001113          MLS      r1,r0,r3,r1
00006c  0512              LSLS     r2,r2,#20             ;459
00006e  ea424201          ORR      r2,r2,r1,LSL #16
;;;461            u32RegTALM |= ((sPt->u32Minute / 10ul) << 12);
000072  6961              LDR      r1,[r4,#0x14]
000074  fbb1f3f0          UDIV     r3,r1,r0
000078  ea423203          ORR      r2,r2,r3,LSL #12
;;;462            u32RegTALM |= ((sPt->u32Minute % 10ul) << 8);
00007c  fbb1f3f0          UDIV     r3,r1,r0
000080  fb001113          MLS      r1,r0,r3,r1
000084  ea422201          ORR      r2,r2,r1,LSL #8
;;;463            u32RegTALM |= ((sPt->u32Second / 10ul) << 4);
000088  69a1              LDR      r1,[r4,#0x18]
00008a  fbb1f3f0          UDIV     r3,r1,r0
00008e  ea421203          ORR      r2,r2,r3,LSL #4
;;;464            u32RegTALM |= (sPt->u32Second % 10ul);
000092  fbb1f3f0          UDIV     r3,r1,r0
000096  fb001413          MLS      r4,r0,r3,r1
00009a  4314              ORRS     r4,r4,r2
;;;465    
;;;466            RTC_WaitAccessEnable();
00009c  f7fffffe          BL       RTC_WaitAccessEnable
;;;467            RTC->CALM = (uint32_t)u32RegCALM;
0000a0  622e              STR      r6,[r5,#0x20]
;;;468            RTC_WaitAccessEnable();
0000a2  f7fffffe          BL       RTC_WaitAccessEnable
;;;469            RTC->TALM = (uint32_t)u32RegTALM;
0000a6  61ec              STR      r4,[r5,#0x1c]
                  |L15.168|
;;;470        }
;;;471    }
0000a8  bd70              POP      {r4-r6,pc}
                  |L15.170|
0000aa  f0200001          BIC      r0,r0,#1              ;434
0000ae  6168              STR      r0,[r5,#0x14]         ;434
0000b0  6a20              LDR      r0,[r4,#0x20]         ;439
0000b2  2802              CMP      r0,#2                 ;439
0000b4  d1b1              BNE      |L15.26|
0000b6  6920              LDR      r0,[r4,#0x10]         ;441
0000b8  3014              ADDS     r0,r0,#0x14           ;441
0000ba  6120              STR      r0,[r4,#0x10]         ;441
0000bc  e7ad              B        |L15.26|
;;;472    
                          ENDP

0000be  0000              DCW      0x0000
                  |L15.192|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDateMask||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDateMask PROC
;;;643      */
;;;644    void RTC_SetAlarmDateMask(uint8_t u8IsTenYMsk, uint8_t u8IsYMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenDMsk, uint8_t u8IsDMsk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;645    {
000004  461f              MOV      r7,r3
000006  e9dd8908          LDRD     r8,r9,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  460d              MOV      r5,r1
00000e  4604              MOV      r4,r0
;;;646        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;647        RTC->CAMSK = ((uint32_t)u8IsTenYMsk << RTC_CAMSK_MTENYEAR_Pos) |
000014  0160              LSLS     r0,r4,#5
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  ea4000c6          ORR      r0,r0,r6,LSL #3
00001e  ea400187          ORR      r1,r0,r7,LSL #2
000022  ea410048          ORR      r0,r1,r8,LSL #1
000026  4903              LDR      r1,|L16.52|
000028  ea400009          ORR      r0,r0,r9
00002c  6388              STR      r0,[r1,#0x38]
;;;648                     ((uint32_t)u8IsYMsk    << RTC_CAMSK_MYEAR_Pos) |
;;;649                     ((uint32_t)u8IsTenMMsk << RTC_CAMSK_MTENMON_Pos) |
;;;650                     ((uint32_t)u8IsMMsk    << RTC_CAMSK_MMON_Pos) |
;;;651                     ((uint32_t)u8IsTenDMsk << RTC_CAMSK_MTENDAY_Pos) |
;;;652                     ((uint32_t)u8IsDMsk    << RTC_CAMSK_MDAY_Pos);
;;;653    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;654    
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmTime||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmTime PROC
;;;594      */
;;;595    void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm)
000000  b570              PUSH     {r4-r6,lr}
;;;596    {
000002  001d              MOVS     r5,r3
000004  9b04              LDR      r3,[sp,#0x10]
000006  d102              BNE      |L17.14|
;;;597        uint32_t u32RegTALM;
;;;598    
;;;599        /* Important, range of 12-hour PM mode is 21 up to 32 */
;;;600        if((u32TimeMode == RTC_CLOCK_12) && (u32AmPm == RTC_PM))
000008  2b02              CMP      r3,#2
00000a  d100              BNE      |L17.14|
00000c  3014              ADDS     r0,r0,#0x14
                  |L17.14|
;;;601        {
;;;602            u32Hour += 20ul;
;;;603        }
;;;604    
;;;605        u32RegTALM  = ((u32Hour   / 10ul) << 20);
00000e  240a              MOVS     r4,#0xa
000010  fbb0f3f4          UDIV     r3,r0,r4
;;;606        u32RegTALM |= ((u32Hour   % 10ul) << 16);
000014  fbb0f6f4          UDIV     r6,r0,r4
000018  fb040016          MLS      r0,r4,r6,r0
00001c  051b              LSLS     r3,r3,#20             ;605
00001e  ea434000          ORR      r0,r3,r0,LSL #16
;;;607        u32RegTALM |= ((u32Minute / 10ul) << 12);
000022  fbb1f3f4          UDIV     r3,r1,r4
000026  ea403003          ORR      r0,r0,r3,LSL #12
;;;608        u32RegTALM |= ((u32Minute % 10ul) << 8);
00002a  fbb1f3f4          UDIV     r3,r1,r4
00002e  fb041113          MLS      r1,r4,r3,r1
000032  ea402001          ORR      r0,r0,r1,LSL #8
;;;609        u32RegTALM |= ((u32Second / 10ul) << 4);
000036  fbb2f1f4          UDIV     r1,r2,r4
00003a  ea401001          ORR      r0,r0,r1,LSL #4
;;;610        u32RegTALM |= (u32Second % 10ul);
00003e  fbb2f1f4          UDIV     r1,r2,r4
000042  fb042611          MLS      r6,r4,r1,r2
000046  4306              ORRS     r6,r6,r0
;;;611    
;;;612        /*-----------------------------------------------------------------------------------------------------*/
;;;613        /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;614        /*-----------------------------------------------------------------------------------------------------*/
;;;615        RTC_WaitAccessEnable();
000048  f7fffffe          BL       RTC_WaitAccessEnable
;;;616        if(u32TimeMode == RTC_CLOCK_12)
;;;617        {
;;;618            RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00004c  4c06              LDR      r4,|L17.104|
;;;619        }
;;;620        else
;;;621        {
;;;622            RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
00004e  6960              LDR      r0,[r4,#0x14]
000050  b135              CBZ      r5,|L17.96|
000052  f0400001          ORR      r0,r0,#1
                  |L17.86|
000056  6160              STR      r0,[r4,#0x14]
;;;623        }
;;;624    
;;;625        /* Set RTC Alarm Time */
;;;626        RTC_WaitAccessEnable();
000058  f7fffffe          BL       RTC_WaitAccessEnable
;;;627        RTC->TALM = (uint32_t)u32RegTALM;
00005c  61e6              STR      r6,[r4,#0x1c]
;;;628    }
00005e  bd70              POP      {r4-r6,pc}
                  |L17.96|
000060  f0200001          BIC      r0,r0,#1              ;618
000064  e7f7              B        |L17.86|
;;;629    
                          ENDP

000066  0000              DCW      0x0000
                  |L17.104|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmTimeMask||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmTimeMask PROC
;;;668      */
;;;669    void RTC_SetAlarmTimeMask(uint8_t u8IsTenHMsk, uint8_t u8IsHMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenSMsk, uint8_t u8IsSMsk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;670    {
000004  461f              MOV      r7,r3
000006  e9dd8908          LDRD     r8,r9,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  460d              MOV      r5,r1
00000e  4604              MOV      r4,r0
;;;671        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;672        RTC->TAMSK = ((uint32_t)u8IsTenHMsk << RTC_TAMSK_MTENHR_Pos) |
000014  0160              LSLS     r0,r4,#5
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  ea4000c6          ORR      r0,r0,r6,LSL #3
00001e  ea400187          ORR      r1,r0,r7,LSL #2
000022  ea410048          ORR      r0,r1,r8,LSL #1
000026  4903              LDR      r1,|L18.52|
000028  ea400009          ORR      r0,r0,r9
00002c  6348              STR      r0,[r1,#0x34]
;;;673                     ((uint32_t)u8IsHMsk    << RTC_TAMSK_MHR_Pos) |
;;;674                     ((uint32_t)u8IsTenMMsk << RTC_TAMSK_MTENMIN_Pos) |
;;;675                     ((uint32_t)u8IsMMsk    << RTC_TAMSK_MMIN_Pos) |
;;;676                     ((uint32_t)u8IsTenSMsk << RTC_TAMSK_MTENSEC_Pos) |
;;;677                     ((uint32_t)u8IsSMsk    << RTC_TAMSK_MSEC_Pos);
;;;678    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;679    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      0x40041000

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;486      */
;;;487    void RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek)
000000  b570              PUSH     {r4-r6,lr}
;;;488    {
;;;489        uint32_t u32RegCAL;
;;;490    
;;;491        u32RegCAL  = ((u32Year - RTC_YEAR2000) / 10ul) << 20;
000002  240a              MOVS     r4,#0xa
000004  f5a060fa          SUB      r0,r0,#0x7d0
000008  461d              MOV      r5,r3                 ;488
00000a  fbb0f3f4          UDIV     r3,r0,r4
;;;492        u32RegCAL |= (((u32Year - RTC_YEAR2000) % 10ul) << 16);
00000e  fbb0f6f4          UDIV     r6,r0,r4
000012  fb040016          MLS      r0,r4,r6,r0
000016  051b              LSLS     r3,r3,#20             ;491
000018  ea434000          ORR      r0,r3,r0,LSL #16
;;;493        u32RegCAL |= ((u32Month / 10ul) << 12);
00001c  fbb1f3f4          UDIV     r3,r1,r4
000020  ea403003          ORR      r0,r0,r3,LSL #12
;;;494        u32RegCAL |= ((u32Month % 10ul) << 8);
000024  fbb1f3f4          UDIV     r3,r1,r4
000028  fb041113          MLS      r1,r4,r3,r1
00002c  ea402001          ORR      r0,r0,r1,LSL #8
;;;495        u32RegCAL |= ((u32Day   / 10ul) << 4);
000030  fbb2f1f4          UDIV     r1,r2,r4
000034  ea401001          ORR      r0,r0,r1,LSL #4
;;;496        u32RegCAL |= (u32Day   % 10ul);
000038  fbb2f1f4          UDIV     r1,r2,r4
00003c  fb042411          MLS      r4,r4,r1,r2
000040  4304              ORRS     r4,r4,r0
;;;497    
;;;498        /* Set Day of the Week */
;;;499        RTC_WaitAccessEnable();
000042  f7fffffe          BL       RTC_WaitAccessEnable
;;;500        RTC->WEEKDAY = u32DayOfWeek & RTC_WEEKDAY_WEEKDAY_Msk;
000046  f0050007          AND      r0,r5,#7
00004a  4d03              LDR      r5,|L19.88|
00004c  61a8              STR      r0,[r5,#0x18]
;;;501    
;;;502        /* Set RTC Calender Loading */
;;;503        RTC_WaitAccessEnable();
00004e  f7fffffe          BL       RTC_WaitAccessEnable
;;;504        RTC->CAL = (uint32_t)u32RegCAL;
000052  612c              STR      r4,[r5,#0x10]
;;;505    }
000054  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP

000056  0000              DCW      0x0000
                  |L19.88|
                          DCD      0x40041000

                          AREA ||i.RTC_SetDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_SetDateAndTime PROC
;;;337      */
;;;338    void RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;339    {
000002  0004              MOVS     r4,r0
000004  d054              BEQ      |L20.176|
;;;340        uint32_t u32RegCAL, u32RegTIME;
;;;341    
;;;342        if(sPt == 0ul)
;;;343        {
;;;344        }
;;;345        else
;;;346        {
;;;347            /*-----------------------------------------------------------------------------------------------------*/
;;;348            /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;349            /*-----------------------------------------------------------------------------------------------------*/
;;;350            RTC_WaitAccessEnable();
000006  f7fffffe          BL       RTC_WaitAccessEnable
;;;351            if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;352            {
;;;353                RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00000a  4d2f              LDR      r5,|L20.200|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;351
00000e  2800              CMP      r0,#0                 ;351
;;;354    
;;;355                /*-------------------------------------------------------------------------------------------------*/
;;;356                /* Important, range of 12-hour PM mode is 21 up to 32                                               */
;;;357                /*-------------------------------------------------------------------------------------------------*/
;;;358                if(sPt->u32AmPm == RTC_PM)
;;;359                {
;;;360                    sPt->u32Hour += 20ul;
;;;361                }
;;;362            }
;;;363            else
;;;364            {
;;;365                RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
000010  6968              LDR      r0,[r5,#0x14]
000012  d04e              BEQ      |L20.178|
000014  f0400001          ORR      r0,r0,#1
000018  6168              STR      r0,[r5,#0x14]
                  |L20.26|
;;;366            }
;;;367    
;;;368            /* Set Day of the Week */
;;;369            RTC_WaitAccessEnable();
00001a  f7fffffe          BL       RTC_WaitAccessEnable
;;;370            RTC->WEEKDAY = sPt->u32DayOfWeek;
00001e  68e0              LDR      r0,[r4,#0xc]
000020  61a8              STR      r0,[r5,#0x18]
;;;371    
;;;372            /*-----------------------------------------------------------------------------------------------------*/
;;;373            /* Set RTC Current Date and Time                                                                       */
;;;374            /*-----------------------------------------------------------------------------------------------------*/
;;;375            u32RegCAL  = ((sPt->u32Year - RTC_YEAR2000) / 10ul) << 20;
000022  6821              LDR      r1,[r4,#0]
000024  200a              MOVS     r0,#0xa
000026  f5a161fa          SUB      r1,r1,#0x7d0
00002a  fbb1f2f0          UDIV     r2,r1,r0
;;;376            u32RegCAL |= (((sPt->u32Year - RTC_YEAR2000) % 10ul) << 16);
00002e  fbb1f3f0          UDIV     r3,r1,r0
000032  fb001113          MLS      r1,r0,r3,r1
000036  0512              LSLS     r2,r2,#20             ;375
000038  ea424201          ORR      r2,r2,r1,LSL #16
;;;377            u32RegCAL |= ((sPt->u32Month  / 10ul) << 12);
00003c  6861              LDR      r1,[r4,#4]
00003e  fbb1f3f0          UDIV     r3,r1,r0
000042  ea423203          ORR      r2,r2,r3,LSL #12
;;;378            u32RegCAL |= ((sPt->u32Month  % 10ul) << 8);
000046  fbb1f3f0          UDIV     r3,r1,r0
00004a  fb001113          MLS      r1,r0,r3,r1
00004e  ea422201          ORR      r2,r2,r1,LSL #8
;;;379            u32RegCAL |= ((sPt->u32Day    / 10ul) << 4);
000052  68a1              LDR      r1,[r4,#8]
000054  fbb1f3f0          UDIV     r3,r1,r0
000058  ea421203          ORR      r2,r2,r3,LSL #4
;;;380            u32RegCAL |= (sPt->u32Day     % 10ul);
00005c  fbb1f3f0          UDIV     r3,r1,r0
000060  fb001613          MLS      r6,r0,r3,r1
;;;381    
;;;382            u32RegTIME  = ((sPt->u32Hour   / 10ul) << 20);
000064  6921              LDR      r1,[r4,#0x10]
000066  4316              ORRS     r6,r6,r2              ;380
000068  fbb1f2f0          UDIV     r2,r1,r0
;;;383            u32RegTIME |= ((sPt->u32Hour   % 10ul) << 16);
00006c  fbb1f3f0          UDIV     r3,r1,r0
000070  fb001113          MLS      r1,r0,r3,r1
000074  0512              LSLS     r2,r2,#20             ;382
000076  ea424201          ORR      r2,r2,r1,LSL #16
;;;384            u32RegTIME |= ((sPt->u32Minute / 10ul) << 12);
00007a  6961              LDR      r1,[r4,#0x14]
00007c  fbb1f3f0          UDIV     r3,r1,r0
000080  ea423203          ORR      r2,r2,r3,LSL #12
;;;385            u32RegTIME |= ((sPt->u32Minute % 10ul) << 8);
000084  fbb1f3f0          UDIV     r3,r1,r0
000088  fb001113          MLS      r1,r0,r3,r1
00008c  ea422201          ORR      r2,r2,r1,LSL #8
;;;386            u32RegTIME |= ((sPt->u32Second / 10ul) << 4);
000090  69a1              LDR      r1,[r4,#0x18]
000092  fbb1f3f0          UDIV     r3,r1,r0
000096  ea421203          ORR      r2,r2,r3,LSL #4
;;;387            u32RegTIME |= (sPt->u32Second % 10ul);
00009a  fbb1f3f0          UDIV     r3,r1,r0
00009e  fb001413          MLS      r4,r0,r3,r1
0000a2  4314              ORRS     r4,r4,r2
;;;388    
;;;389            /*-----------------------------------------------------------------------------------------------------*/
;;;390            /* Set RTC Calender and Time Loading                                                                   */
;;;391            /*-----------------------------------------------------------------------------------------------------*/
;;;392            RTC_WaitAccessEnable();
0000a4  f7fffffe          BL       RTC_WaitAccessEnable
;;;393            RTC->CAL  = (uint32_t)u32RegCAL;
0000a8  612e              STR      r6,[r5,#0x10]
;;;394            RTC_WaitAccessEnable();
0000aa  f7fffffe          BL       RTC_WaitAccessEnable
;;;395            RTC->TIME = (uint32_t)u32RegTIME;
0000ae  60ec              STR      r4,[r5,#0xc]
                  |L20.176|
;;;396        }
;;;397    }
0000b0  bd70              POP      {r4-r6,pc}
                  |L20.178|
0000b2  f0200001          BIC      r0,r0,#1              ;353
0000b6  6168              STR      r0,[r5,#0x14]         ;353
0000b8  6a20              LDR      r0,[r4,#0x20]         ;358
0000ba  2802              CMP      r0,#2                 ;358
0000bc  d1ad              BNE      |L20.26|
0000be  6920              LDR      r0,[r4,#0x10]         ;360
0000c0  3014              ADDS     r0,r0,#0x14           ;360
0000c2  6120              STR      r0,[r4,#0x10]         ;360
0000c4  e7a9              B        |L20.26|
;;;398    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L20.200|
                          DCD      0x40041000

                          AREA ||i.RTC_SetTickPeriod||, CODE, READONLY, ALIGN=2

                  RTC_SetTickPeriod PROC
;;;717      */
;;;718    void RTC_SetTickPeriod(uint32_t u32TickSelection)
000000  b510              PUSH     {r4,lr}
;;;719    {
000002  4604              MOV      r4,r0
;;;720        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;721    
;;;722        RTC->TICK = (RTC->TICK & ~RTC_TICK_TICK_Msk) | u32TickSelection;
000008  4903              LDR      r1,|L21.24|
00000a  6b08              LDR      r0,[r1,#0x30]
00000c  f0200207          BIC      r2,r0,#7
000010  4322              ORRS     r2,r2,r4
000012  630a              STR      r2,[r1,#0x30]
;;;723    }
000014  bd10              POP      {r4,pc}
;;;724    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      0x40041000

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;519      */
;;;520    void RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  001d              MOVS     r5,r3
000004  9b04              LDR      r3,[sp,#0x10]
000006  d102              BNE      |L22.14|
;;;522        uint32_t u32RegTIME;
;;;523    
;;;524        /* Important, range of 12-hour PM mode is 21 up to 32 */
;;;525        if((u32TimeMode == RTC_CLOCK_12) && (u32AmPm == RTC_PM))
000008  2b02              CMP      r3,#2
00000a  d100              BNE      |L22.14|
00000c  3014              ADDS     r0,r0,#0x14
                  |L22.14|
;;;526        {
;;;527            u32Hour += 20ul;
;;;528        }
;;;529    
;;;530        u32RegTIME  = ((u32Hour   / 10ul) << 20);
00000e  240a              MOVS     r4,#0xa
000010  fbb0f3f4          UDIV     r3,r0,r4
;;;531        u32RegTIME |= ((u32Hour   % 10ul) << 16);
000014  fbb0f6f4          UDIV     r6,r0,r4
000018  fb040016          MLS      r0,r4,r6,r0
00001c  051b              LSLS     r3,r3,#20             ;530
00001e  ea434000          ORR      r0,r3,r0,LSL #16
;;;532        u32RegTIME |= ((u32Minute / 10ul) << 12);
000022  fbb1f3f4          UDIV     r3,r1,r4
000026  ea403003          ORR      r0,r0,r3,LSL #12
;;;533        u32RegTIME |= ((u32Minute % 10ul) << 8);
00002a  fbb1f3f4          UDIV     r3,r1,r4
00002e  fb041113          MLS      r1,r4,r3,r1
000032  ea402001          ORR      r0,r0,r1,LSL #8
;;;534        u32RegTIME |= ((u32Second / 10ul) << 4);
000036  fbb2f1f4          UDIV     r1,r2,r4
00003a  ea401001          ORR      r0,r0,r1,LSL #4
;;;535        u32RegTIME |= (u32Second % 10ul);
00003e  fbb2f1f4          UDIV     r1,r2,r4
000042  fb042611          MLS      r6,r4,r1,r2
000046  4306              ORRS     r6,r6,r0
;;;536    
;;;537        /*-----------------------------------------------------------------------------------------------------*/
;;;538        /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;539        /*-----------------------------------------------------------------------------------------------------*/
;;;540        RTC_WaitAccessEnable();
000048  f7fffffe          BL       RTC_WaitAccessEnable
;;;541        if(u32TimeMode == RTC_CLOCK_12)
;;;542        {
;;;543            RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00004c  4c06              LDR      r4,|L22.104|
;;;544        }
;;;545        else
;;;546        {
;;;547            RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
00004e  6960              LDR      r0,[r4,#0x14]
000050  b135              CBZ      r5,|L22.96|
000052  f0400001          ORR      r0,r0,#1
                  |L22.86|
000056  6160              STR      r0,[r4,#0x14]
;;;548        }
;;;549    
;;;550        RTC_WaitAccessEnable();
000058  f7fffffe          BL       RTC_WaitAccessEnable
;;;551        RTC->TIME = (uint32_t)u32RegTIME;
00005c  60e6              STR      r6,[r4,#0xc]
;;;552    }
00005e  bd70              POP      {r4-r6,pc}
                  |L22.96|
000060  f0200001          BIC      r0,r0,#1              ;543
000064  e7f7              B        |L22.86|
;;;553    
                          ENDP

000066  0000              DCW      0x0000
                  |L22.104|
                          DCD      0x40041000

                          AREA ||i.RTC_StaticTamperDisable||, CODE, READONLY, ALIGN=2

                  RTC_StaticTamperDisable PROC
;;;868      */
;;;869    void RTC_StaticTamperDisable(uint32_t u32TamperSelect)
000000  b570              PUSH     {r4-r6,lr}
;;;870    {
000002  4605              MOV      r5,r0
;;;871        uint32_t i;
;;;872        uint32_t u32Reg;
;;;873        uint32_t u32TmpReg;
;;;874    
;;;875        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;876        u32Reg = RTC->TAMPCTL;
000008  4e0a              LDR      r6,|L23.52|
00000a  f8d64120          LDR      r4,[r6,#0x120]
;;;877    
;;;878        u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk);
00000e  15b0              ASRS     r0,r6,#22
;;;879    
;;;880        for(i = 0ul; i < MAX_TAMPER_PIN_NUM; i++)
000010  2100              MOVS     r1,#0
;;;881        {
;;;882            if(u32TamperSelect & (0x1ul << i))
000012  2301              MOVS     r3,#1
                  |L23.20|
000014  fa03f201          LSL      r2,r3,r1
000018  422a              TST      r2,r5
00001a  d003              BEQ      |L23.36|
;;;883            {
;;;884                u32Reg &= ~(u32TmpReg << (i*4ul));
00001c  008a              LSLS     r2,r1,#2
00001e  fa00f202          LSL      r2,r0,r2
000022  4394              BICS     r4,r4,r2
                  |L23.36|
000024  1c49              ADDS     r1,r1,#1
000026  2906              CMP      r1,#6                 ;880
000028  d3f4              BCC      |L23.20|
;;;885            }
;;;886        }
;;;887    
;;;888        RTC_WaitAccessEnable();
00002a  f7fffffe          BL       RTC_WaitAccessEnable
;;;889        RTC->TAMPCTL = u32Reg;
00002e  f8c64120          STR      r4,[r6,#0x120]
;;;890    }
000032  bd70              POP      {r4-r6,pc}
;;;891    
                          ENDP

                  |L23.52|
                          DCD      0x40041000

                          AREA ||i.RTC_StaticTamperEnable||, CODE, READONLY, ALIGN=2

                  RTC_StaticTamperEnable PROC
;;;827      */
;;;828    void RTC_StaticTamperEnable(uint32_t u32TamperSelect, uint32_t u32DetecLevel, uint32_t u32DebounceEn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;829    {
000004  4690              MOV      r8,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;830        uint32_t i;
;;;831        uint32_t u32Reg;
;;;832        uint32_t u32TmpReg;
;;;833    
;;;834        RTC_WaitAccessEnable();
00000a  f7fffffe          BL       RTC_WaitAccessEnable
;;;835        u32Reg = RTC->TAMPCTL;
00000e  4e11              LDR      r6,|L24.84|
000010  f8d64120          LDR      r4,[r6,#0x120]
;;;836    
;;;837        u32TmpReg = ( RTC_TAMPCTL_TAMP0EN_Msk | (u32DetecLevel << RTC_TAMPCTL_TAMP0LV_Pos) |
000014  0279              LSLS     r1,r7,#9
000016  ea412088          ORR      r0,r1,r8,LSL #10
;;;838                      (u32DebounceEn << RTC_TAMPCTL_TAMP0DBEN_Pos) );
;;;839    
;;;840        for(i = 0ul; i < MAX_TAMPER_PIN_NUM; i++)
00001a  2100              MOVS     r1,#0
00001c  f4407280          ORR      r2,r0,#0x100          ;837
;;;841        {
;;;842            if(u32TamperSelect & (0x1ul << i))
000020  2301              MOVS     r3,#1
;;;843            {
;;;844                u32Reg &= ~((RTC_TAMPCTL_TAMP0EN_Msk|RTC_TAMPCTL_TAMP0LV_Msk|RTC_TAMPCTL_TAMP0DBEN_Msk) << (i*4ul));
000022  f44f67e0          MOV      r7,#0x700
                  |L24.38|
000026  fa03f001          LSL      r0,r3,r1              ;842
00002a  4228              TST      r0,r5                 ;842
00002c  d008              BEQ      |L24.64|
00002e  0088              LSLS     r0,r1,#2
000030  fa07fc00          LSL      r12,r7,r0
000034  ea24040c          BIC      r4,r4,r12
;;;845                u32Reg |= (u32TmpReg << (i*4ul));
000038  fa02fc00          LSL      r12,r2,r0
00003c  ea4c0404          ORR      r4,r12,r4
                  |L24.64|
000040  1c49              ADDS     r1,r1,#1
000042  2906              CMP      r1,#6                 ;840
000044  d3ef              BCC      |L24.38|
;;;846            }
;;;847        }
;;;848    
;;;849        RTC_WaitAccessEnable();
000046  f7fffffe          BL       RTC_WaitAccessEnable
;;;850        RTC->TAMPCTL = u32Reg;
00004a  f8c64120          STR      r4,[r6,#0x120]
;;;851    
;;;852    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;853    
                          ENDP

000052  0000              DCW      0x0000
                  |L24.84|
                          DCD      0x40041000

                          AREA ||i.RTC_WaitAccessEnable||, CODE, READONLY, ALIGN=2

                  RTC_WaitAccessEnable PROC
;;;285      */
;;;286    __STATIC_INLINE void RTC_WaitAccessEnable(void)
000000  4805              LDR      r0,|L25.24|
                  |L25.2|
;;;287    {
;;;288        while((RTC->RWEN & RTC_RWEN_RTCBUSY_Msk) == RTC_RWEN_RTCBUSY_Msk)
000002  6841              LDR      r1,[r0,#4]
000004  01c9              LSLS     r1,r1,#7
000006  d4fc              BMI      |L25.2|
;;;289        {
;;;290        }
;;;291    
;;;292        /* To wait RWENF bit is cleared and enable RWENF bit (Access Enable bit) again */
;;;293        RTC->RWEN = RTC_WRITE_KEY;
000008  f64a1165          MOV      r1,#0xa965
00000c  6041              STR      r1,[r0,#4]
                  |L25.14|
;;;294    
;;;295        /* To wait RWENF bit is set and user can access the protected-register of RTC from now on */
;;;296        while((RTC->RWEN & RTC_RWEN_RWENF_Msk) == (uint32_t)0x0)
00000e  6841              LDR      r1,[r0,#4]
000010  03c9              LSLS     r1,r1,#15
000012  d5fc              BPL      |L25.14|
;;;297        {
;;;298        }
;;;299    }
000014  4770              BX       lr
;;;300    
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      0x40041000

                          AREA ||.data||, DATA, ALIGN=2

                  g_u32hiYear
                          DCD      0x00000000
                  g_u32loYear
                          DCD      0x00000000
                  g_u32hiMonth
                          DCD      0x00000000
                  g_u32loMonth
                          DCD      0x00000000
                  g_u32hiDay
                          DCD      0x00000000
                  g_u32loDay
                          DCD      0x00000000
                  g_u32hiHour
                          DCD      0x00000000
                  g_u32loHour
                          DCD      0x00000000
                  g_u32hiMin
                          DCD      0x00000000
                  g_u32loMin
                          DCD      0x00000000
                  g_u32hiSec
                          DCD      0x00000000
                  g_u32loSec
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_rtc_c_RTC_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____REVSH|
#line 402
|__asm___5_rtc_c_RTC_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____RRX|
#line 587
|__asm___5_rtc_c_RTC_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
