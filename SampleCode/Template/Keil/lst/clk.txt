; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L1.8|
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;33     }
;;;34     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x57c00006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;724      */
;;;725    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;726    {
;;;727        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;728    
;;;729        u32tmpVal = ~(1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;730        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L2.24|
;;;731        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;732    
;;;733        *(uint32_t *)u32tmpAddr &= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;734    }
000016  4770              BX       lr
;;;735    
                          ENDP

                  |L2.24|
                          DCD      0x40000204

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;899      */
;;;900    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;901    {
;;;902        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;903    }
000010  4770              BX       lr
;;;904    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;978      */
;;;979    void CLK_DisableSysTick(void)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;980    {
;;;981        /* Set System Tick counter disabled */
;;;982        SysTick->CTRL = 0UL;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;983    }
000008  4770              BX       lr
;;;984    
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;584      */
;;;585    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;586    {
;;;587        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;588    }
00000e  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;51       */
;;;52     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  4603              MOV      r3,r0
;;;53     {
;;;54         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;55         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | (u32ClkDiv) | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  ea411042          ORR      r0,r1,r2,LSL #5
000006  b510              PUSH     {r4,lr}               ;53
000008  f04f4280          MOV      r2,#0x40000000
00000c  f0400110          ORR      r1,r0,#0x10
000010  f8c21260          STR      r1,[r2,#0x260]
;;;56     
;;;57         /* Enable CKO clock source */
;;;58         CLK_EnableModuleClock(CLKO_MODULE);
000014  4c05              LDR      r4,|L6.44|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;59     
;;;60         /* Select CKO clock source */
;;;61         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0UL);
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2200              MOVS     r2,#0
000024  4619              MOV      r1,r3
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;62     }
;;;63     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x57c00006

                          AREA ||i.CLK_EnableDPDWKPin||, CODE, READONLY, ALIGN=1

                  CLK_EnableDPDWKPin PROC
;;;1026   
;;;1027   void CLK_EnableDPDWKPin(uint32_t u32TriggerType)
000000  f04f4180          MOV      r1,#0x40000000
;;;1028   {
;;;1029       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
000004  f8d12290          LDR      r2,[r1,#0x290]
000008  f4223240          BIC      r2,r2,#0x30000
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12290          STR      r2,[r1,#0x290]
;;;1030   }
000012  4770              BX       lr
;;;1031   
                          ENDP


                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;651      */
;;;652    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;653    {
;;;654        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;655    
;;;656        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;657        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L8.24|
;;;658        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;659    
;;;660        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  430a              ORRS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;661    }
000016  4770              BX       lr
;;;662    
                          ENDP

                  |L8.24|
                          DCD      0x40000204

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;746      */
;;;747    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;748    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;749        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;750        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;751    
;;;752        /* Disable PLL first to avoid unstable when setting PLL */
;;;753        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;754    
;;;755        /* PLL source clock is from HXT */
;;;756        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;757        {
;;;758            /* Enable HXT clock */
;;;759            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;760    
;;;761            /* Wait for HXT clock ready */
;;;762            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;763    
;;;764            /* Select PLL source clock from HXT */
;;;765            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;766            u32PllSrcClk = __HXT;
;;;767    
;;;768            /* u32NR start from 2 */
;;;769            u32NR = 2UL;
;;;770        }
;;;771    
;;;772        /* PLL source clock is from HIRC */
;;;773        else
;;;774        {
;;;775            /* Enable HIRC clock */
;;;776            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  f04f4080          MOV      r0,#0x40000000
000010  4e48              LDR      r6,|L9.308|
000012  f8d01200          LDR      r1,[r0,#0x200]
000016  b1c4              CBZ      r4,|L9.74|
000018  f0410104          ORR      r1,r1,#4
00001c  f8c01200          STR      r1,[r0,#0x200]
;;;777    
;;;778            /* Wait for HIRC clock ready */
;;;779            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       CLK_WaitClockReady
;;;780    
;;;781            /* Select PLL source clock from HIRC */
;;;782            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000026  f44f2000          MOV      r0,#0x80000
                  |L9.42|
;;;783            u32PllSrcClk = __HIRC;
;;;784    
;;;785            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;786            u32NR = 4UL;
;;;787        }
;;;788    
;;;789        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
00002a  9000              STR      r0,[sp,#0]
00002c  4842              LDR      r0,|L9.312|
00002e  4943              LDR      r1,|L9.316|
000030  4428              ADD      r0,r0,r5
000032  46b3              MOV      r11,r6                ;783
000034  4288              CMP      r0,r1
000036  d86d              BHI      |L9.276|
;;;790        {
;;;791    
;;;792            /* Find best solution */
;;;793            u32Min = (uint32_t) - 1;
;;;794            u32MinNR = 0UL;
000038  f04f0900          MOV      r9,#0
00003c  f04f32ff          MOV      r2,#0xffffffff        ;793
;;;795            u32MinNF = 0UL;
000040  464f              MOV      r7,r9
;;;796            u32MinNO = 0UL;
000042  464e              MOV      r6,r9
;;;797            u32basFreq = u32PllFreq;
000044  46ae              MOV      lr,r5
;;;798    
;;;799            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
000046  2001              MOVS     r0,#1
000048  e015              B        |L9.118|
                  |L9.74|
00004a  f0410101          ORR      r1,r1,#1              ;759
00004e  f8c01200          STR      r1,[r0,#0x200]        ;759
000052  2001              MOVS     r0,#1                 ;762
000054  f7fffffe          BL       CLK_WaitClockReady
000058  2000              MOVS     r0,#0                 ;765
00005a  e7e6              B        |L9.42|
                  |L9.92|
;;;800            {
;;;801                /* Break when get good results */
;;;802                if (u32Min == 0UL)
00005c  b3f2              CBZ      r2,|L9.220|
;;;803                {
;;;804                    break;
;;;805                }
;;;806    
;;;807                if (u32NO != 3UL)
00005e  2803              CMP      r0,#3
000060  d039              BEQ      |L9.214|
;;;808                {
;;;809    
;;;810                    if(u32NO == 4UL)
000062  2804              CMP      r0,#4
000064  d002              BEQ      |L9.108|
;;;811                    {
;;;812                        u32PllFreq = u32basFreq << 2;
;;;813                    }
;;;814                    else if(u32NO == 2UL)
000066  2802              CMP      r0,#2
000068  d105              BNE      |L9.118|
00006a  e002              B        |L9.114|
                  |L9.108|
00006c  ea4f058e          LSL      r5,lr,#2              ;812
000070  e001              B        |L9.118|
                  |L9.114|
;;;815                    {
;;;816                        u32PllFreq = u32basFreq << 1;
000072  ea4f054e          LSL      r5,lr,#1
                  |L9.118|
;;;817                    }
;;;818                    else
;;;819                    {
;;;820                    }
;;;821    
;;;822                    for(u32NR = 2UL; u32NR <= 32UL; u32NR++)
000076  2302              MOVS     r3,#2
                  |L9.120|
;;;823                    {
;;;824                        /* Break when get good results */
;;;825                        if (u32Min == 0UL)
000078  b36a              CBZ      r2,|L9.214|
;;;826                        {
;;;827                            break;
;;;828                        }
;;;829    
;;;830                        u32Tmp = u32PllSrcClk / u32NR;
00007a  fbbbf1f3          UDIV     r1,r11,r3
;;;831                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
00007e  4c30              LDR      r4,|L9.320|
000080  f8dfc0bc          LDR      r12,|L9.320|
000084  440c              ADD      r4,r4,r1
000086  f1cc0c00          RSB      r12,r12,#0
00008a  4564              CMP      r4,r12
00008c  d820              BHI      |L9.208|
;;;832                        {
;;;833                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
00008e  2402              MOVS     r4,#2
;;;834                            {
;;;835                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;836                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
000090  f3c10a5d          UBFX     r10,r1,#1,#30
                  |L9.148|
;;;837    
;;;838                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000094  f8dfc0a0          LDR      r12,|L9.312|
000098  fb0af104          MUL      r1,r10,r4             ;836
00009c  eb01080c          ADD      r8,r1,r12
0000a0  f8dfc0a0          LDR      r12,|L9.324|
0000a4  45e0              CMP      r8,r12
0000a6  d80e              BHI      |L9.198|
;;;839                                {
;;;840                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
0000a8  ebb10f95          CMP      r1,r5,LSR #2
0000ac  d902              BLS      |L9.180|
0000ae  eba10195          SUB      r1,r1,r5,LSR #2
0000b2  e001              B        |L9.184|
                  |L9.180|
0000b4  ebc10195          RSB      r1,r1,r5,LSR #2
                  |L9.184|
;;;841                                    if(u32Tmp3 < u32Min)
0000b8  4291              CMP      r1,r2
0000ba  d204              BCS      |L9.198|
;;;842                                    {
;;;843                                        u32Min = u32Tmp3;
0000bc  000a              MOVS     r2,r1
;;;844                                        u32MinNR = u32NR;
0000be  4699              MOV      r9,r3
;;;845                                        u32MinNF = u32NF;
0000c0  4627              MOV      r7,r4
;;;846                                        u32MinNO = u32NO;
0000c2  4606              MOV      r6,r0
;;;847    
;;;848                                        /* Break when get good results */
;;;849                                        if(u32Min == 0UL)
0000c4  d004              BEQ      |L9.208|
                  |L9.198|
0000c6  f2402101          MOV      r1,#0x201             ;833
0000ca  1c64              ADDS     r4,r4,#1              ;833
0000cc  428c              CMP      r4,r1                 ;833
0000ce  d9e1              BLS      |L9.148|
                  |L9.208|
0000d0  1c5b              ADDS     r3,r3,#1              ;833
0000d2  2b20              CMP      r3,#0x20              ;822
0000d4  d9d0              BLS      |L9.120|
                  |L9.214|
0000d6  1c40              ADDS     r0,r0,#1              ;822
0000d8  2804              CMP      r0,#4                 ;799
0000da  e000              B        |L9.222|
                  |L9.220|
0000dc  e000              B        |L9.224|
                  |L9.222|
0000de  d9bd              BLS      |L9.92|
                  |L9.224|
;;;850                                        {
;;;851                                            break;
;;;852                                        }
;;;853                                    }
;;;854                                }
;;;855                            }
;;;856                        }
;;;857                    }
;;;858                }
;;;859            }
;;;860    
;;;861            /* Enable and apply new PLL setting. */
;;;862            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
0000e0  4819              LDR      r0,|L9.328|
0000e2  9900              LDR      r1,[sp,#0]
0000e4  eb003086          ADD      r0,r0,r6,LSL #14
0000e8  4a18              LDR      r2,|L9.332|
0000ea  4308              ORRS     r0,r0,r1
0000ec  eb022149          ADD      r1,r2,r9,LSL #9
0000f0  4308              ORRS     r0,r0,r1
0000f2  1eb9              SUBS     r1,r7,#2
0000f4  4308              ORRS     r0,r0,r1
0000f6  f04f4180          MOV      r1,#0x40000000
0000fa  f8c10240          STR      r0,[r1,#0x240]
;;;863    
;;;864            /* Wait for PLL clock stable */
;;;865            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000fe  2004              MOVS     r0,#4
000100  f7fffffe          BL       CLK_WaitClockReady
;;;866    
;;;867            /* Actual PLL output clock frequency */
;;;868            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
000104  fb06f609          MUL      r6,r6,r9
000108  fbbbf0f6          UDIV     r0,r11,r6
00010c  4378              MULS     r0,r7,r0
00010e  0040              LSLS     r0,r0,#1
;;;869        }
;;;870        else
;;;871        {
;;;872            /* Wrong frequency request. Just return default setting. */
;;;873            /* Apply default PLL setting and return */
;;;874            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;875            {
;;;876                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;877            }
;;;878            else
;;;879            {
;;;880                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;881            }
;;;882    
;;;883            /* Wait for PLL clock stable */
;;;884            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;885    
;;;886            /* Actual PLL output clock frequency */
;;;887            u32PllClk = CLK_GetPLLClockFreq();
;;;888        }
;;;889    
;;;890        return u32PllClk;
;;;891    }
000110  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.276|
000114  b15c              CBZ      r4,|L9.302|
000116  490e              LDR      r1,|L9.336|
                  |L9.280|
000118  f04f4080          MOV      r0,#0x40000000        ;880
00011c  f8c01240          STR      r1,[r0,#0x240]        ;880
000120  2004              MOVS     r0,#4                 ;884
000122  f7fffffe          BL       CLK_WaitClockReady
000126  e8bd4ff8          POP      {r3-r11,lr}           ;887
00012a  f7ffbffe          B.W      CLK_GetPLLClockFreq
                  |L9.302|
00012e  f244211e          MOV      r1,#0x421e            ;876
000132  e7f1              B        |L9.280|
;;;892    
                          ENDP

                  |L9.308|
                          DCD      0x00b71b00
                  |L9.312|
                          DCD      0xfd050f80
                  |L9.316|
                          DCD      0x1ad27480
                  |L9.320|
                          DCD      0xffc2f700
                  |L9.324|
                          DCD      0x047868c0
                  |L9.328|
                          DCD      0xffffc000
                  |L9.332|
                          DCD      0xfffffe00
                  |L9.336|
                          DCD      0x0008421e

                          AREA ||i.CLK_EnableSPDWKPin||, CODE, READONLY, ALIGN=2

                  CLK_EnableSPDWKPin PROC
;;;1061    */
;;;1062   void CLK_EnableSPDWKPin(uint32_t u32Port, uint32_t u32Pin, uint32_t u32TriggerType, uint32_t u32DebounceEn)
000000  b530              PUSH     {r4,r5,lr}
;;;1063   {
;;;1064       uint32_t u32tmpAddr = 0UL;
;;;1065       uint32_t u32tmpVal = 0UL;
;;;1066   
;;;1067       /* GPx Stand-by Power-down Wake-up Pin Select */
;;;1068       u32tmpAddr = (uint32_t)&CLK->PASWKCTL;
000002  4c07              LDR      r4,|L10.32|
;;;1069       u32tmpAddr += (0x4UL * u32Port);
000004  eb040080          ADD      r0,r4,r0,LSL #2
;;;1070   
;;;1071       u32tmpVal = inpw((uint32_t *)u32tmpAddr);
000008  6804              LDR      r4,[r0,#0]
;;;1072       u32tmpVal = (u32tmpVal & ~(CLK_PASWKCTL_WKPSEL_Msk | CLK_PASWKCTL_PRWKEN_Msk | CLK_PASWKCTL_PFWKEN_Msk | CLK_PASWKCTL_DBEN_Msk | CLK_PASWKCTL_WKEN_Msk)) |
00000a  f24015f7          MOV      r5,#0x1f7
00000e  43ac              BICS     r4,r4,r5
000010  ea441101          ORR      r1,r4,r1,LSL #4
000014  4311              ORRS     r1,r1,r2
000016  4319              ORRS     r1,r1,r3
000018  f0410101          ORR      r1,r1,#1
;;;1073                   (u32Pin << CLK_PASWKCTL_WKPSEL_Pos) | u32TriggerType | u32DebounceEn | CLK_SPDWKPIN_ENABLE;
;;;1074       outpw((uint32_t *)u32tmpAddr, u32tmpVal);
00001c  6001              STR      r1,[r0,#0]
;;;1075   }
00001e  bd30              POP      {r4,r5,pc}
;;;1076   
                          ENDP

                  |L10.32|
                          DCD      0x400002a0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;947      */
;;;948    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b530              PUSH     {r4,r5,lr}
;;;949    {
;;;950        /* Set System Tick counter disabled */
;;;951        SysTick->CTRL = 0UL;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2500              MOVS     r5,#0
000008  6115              STR      r5,[r2,#0x10]
;;;952    
;;;953        /* Set System Tick clock source */
;;;954        if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L11.46|
;;;955        {
;;;956            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;957        }
;;;958        else
;;;959        {
;;;960            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000e  f04f4380          MOV      r3,#0x40000000
000012  f8d34210          LDR      r4,[r3,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4304              ORRS     r4,r4,r0
00001c  f8c34210          STR      r4,[r3,#0x210]
                  |L11.32|
;;;961        }
;;;962    
;;;963        /* Set System Tick reload value */
;;;964        SysTick->LOAD = u32Count;
000020  6151              STR      r1,[r2,#0x14]
;;;965    
;;;966        /* Clear System Tick current value and counter flag */
;;;967        SysTick->VAL = 0UL;
000022  6195              STR      r5,[r2,#0x18]
;;;968    
;;;969        /* Set System Tick interrupt enabled and counter enabled */
;;;970        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;971    }
00002c  bd30              POP      {r4,r5,pc}
                  |L11.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;956
000030  f0400004          ORR      r0,r0,#4              ;956
000034  6110              STR      r0,[r2,#0x10]         ;956
000036  e7f3              B        |L11.32|
;;;972    
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;568      */
;;;569    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;570    {
;;;571        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4302              ORRS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;572    }
00000e  4770              BX       lr
;;;573    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;278      */
;;;279    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;282        return SystemCoreClock;
000006  4801              LDR      r0,|L13.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;283    }
00000a  bd10              POP      {r4,pc}
;;;284    
                          ENDP

                  |L13.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;265      */
;;;266    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;267    {
;;;268        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;269        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;270    }
00000a  bd10              POP      {r4,pc}
;;;271    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;107      */
;;;108    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;109    {
;;;110        uint32_t u32Freq;
;;;111    
;;;112        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L15.14|
;;;113        {
;;;114            u32Freq = __HXT;
00000c  4800              LDR      r0,|L15.16|
                  |L15.14|
;;;115        }
;;;116        else
;;;117        {
;;;118            u32Freq = 0UL;
;;;119        }
;;;120    
;;;121        return u32Freq;
;;;122    }
00000e  4770              BX       lr
;;;123    
                          ENDP

                  |L15.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;130      */
;;;131    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;132    {
;;;133        uint32_t u32Freq;
;;;134        if((CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk) == CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L16.18|
;;;135        {
;;;136            u32Freq = __LXT;
00000c  f44f4000          MOV      r0,#0x8000
;;;137        }
;;;138        else
;;;139        {
;;;140            u32Freq = 0UL;
;;;141        }
;;;142    
;;;143        return u32Freq;
;;;144    }
000010  4770              BX       lr
                  |L16.18|
000012  2000              MOVS     r0,#0                 ;140
000014  4770              BX       lr
;;;145    
                          ENDP


                          AREA ||i.CLK_GetModuleClockDivider||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockDivider PROC
;;;1208     */
;;;1209   uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1210   {
;;;1211       uint32_t u32div = 0;
;;;1212       uint32_t u32DivTbl[4] = {0x0, 0x4, 0x8, 0x10};
000002  490c              LDR      r1,|L17.52|
;;;1213   
;;;1214       if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000004  f4103f7f          TST      r0,#0x3fc00
000008  c91e              LDM      r1,{r1-r4}            ;1212
00000a  e88d001e          STM      sp,{r1-r4}            ;1212
00000e  d00f              BEQ      |L17.48|
;;;1215       {
;;;1216           /* Get clock divider control register address */
;;;1217           u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000010  f3c04281          UBFX     r2,r0,#18,#2
000014  f85d1022          LDR      r1,[sp,r2,LSL #2]
000018  4a07              LDR      r2,|L17.56|
;;;1218           /* Get clock divider number setting */
;;;1219           return ((M32(u32div) & (MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx))) >> MODULE_CLKDIV_Pos(u32ModuleIdx));
00001a  5889              LDR      r1,[r1,r2]
00001c  f3c02287          UBFX     r2,r0,#10,#8
000020  f3c01044          UBFX     r0,r0,#5,#5
000024  4082              LSLS     r2,r2,r0
000026  4011              ANDS     r1,r1,r2
000028  fa21f000          LSR      r0,r1,r0
                  |L17.44|
;;;1220       }
;;;1221       else
;;;1222           return 0;
;;;1223   }
00002c  b004              ADD      sp,sp,#0x10
00002e  bd10              POP      {r4,pc}
                  |L17.48|
000030  2000              MOVS     r0,#0                 ;1222
000032  e7fb              B        |L17.44|
;;;1224   
                          ENDP

                  |L17.52|
                          DCD      ||.constdata||+0x10
                  |L17.56|
                          DCD      0x40000220

                          AREA ||i.CLK_GetModuleClockSource||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockSource PROC
;;;1164     */
;;;1165   uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1166   {
;;;1167       uint32_t u32sel = 0;
;;;1168       uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};
000002  491d              LDR      r1,|L18.120|
000004  c91e              LDM      r1,{r1-r4}
000006  e88d001e          STM      sp,{r1-r4}
;;;1169   
;;;1170       /* Get clock source selection setting */
;;;1171       if(u32ModuleIdx == EPWM0_MODULE)
00000a  4a1c              LDR      r2,|L18.124|
;;;1172           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk) >> CLK_CLKSEL2_EPWM0SEL_Pos);
00000c  0691              LSLS     r1,r2,#26
00000e  4290              CMP      r0,r2                 ;1171
000010  d105              BNE      |L18.30|
000012  f8d10218          LDR      r0,[r1,#0x218]
000016  f0000001          AND      r0,r0,#1
                  |L18.26|
;;;1173       else if(u32ModuleIdx == EPWM1_MODULE)
;;;1174           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk) >> CLK_CLKSEL2_EPWM1SEL_Pos);
;;;1175       else if(u32ModuleIdx == BPWM0_MODULE)
;;;1176           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk) >> CLK_CLKSEL2_BPWM0SEL_Pos);
;;;1177       else if(u32ModuleIdx == BPWM1_MODULE)
;;;1178           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk) >> CLK_CLKSEL2_BPWM1SEL_Pos);
;;;1179       else if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
;;;1180       {
;;;1181           /* Get clock select control register address */
;;;1182           u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
;;;1183           /* Get clock source selection setting */
;;;1184           return ((M32(u32sel) & (MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx))) >> MODULE_CLKSEL_Pos(u32ModuleIdx));
;;;1185       }
;;;1186       else
;;;1187           return 0;
;;;1188   }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4a18              LDR      r2,|L18.128|
000020  4290              CMP      r0,r2                 ;1173
000022  d104              BNE      |L18.46|
000024  f8d10218          LDR      r0,[r1,#0x218]        ;1174
000028  f3c00040          UBFX     r0,r0,#1,#1           ;1174
00002c  e7f5              B        |L18.26|
                  |L18.46|
00002e  4a15              LDR      r2,|L18.132|
000030  4290              CMP      r0,r2                 ;1175
000032  d104              BNE      |L18.62|
000034  f8d10218          LDR      r0,[r1,#0x218]        ;1176
000038  f3c02000          UBFX     r0,r0,#8,#1           ;1176
00003c  e7ed              B        |L18.26|
                  |L18.62|
00003e  4a12              LDR      r2,|L18.136|
000040  4290              CMP      r0,r2                 ;1177
000042  d104              BNE      |L18.78|
000044  f8d10218          LDR      r0,[r1,#0x218]        ;1178
000048  f3c02040          UBFX     r0,r0,#9,#1           ;1178
00004c  e7e5              B        |L18.26|
                  |L18.78|
00004e  0e41              LSRS     r1,r0,#25             ;1179
000050  0749              LSLS     r1,r1,#29             ;1179
000052  d00e              BEQ      |L18.114|
000054  f3c07201          UBFX     r2,r0,#28,#2          ;1182
000058  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1182
00005c  4a0b              LDR      r2,|L18.140|
00005e  5889              LDR      r1,[r1,r2]            ;1184
000060  f3c06242          UBFX     r2,r0,#25,#3          ;1184
000064  f3c05004          UBFX     r0,r0,#20,#5          ;1184
000068  4082              LSLS     r2,r2,r0              ;1184
00006a  4011              ANDS     r1,r1,r2              ;1184
00006c  fa21f000          LSR      r0,r1,r0              ;1184
000070  e7d3              B        |L18.26|
                  |L18.114|
000072  2000              MOVS     r0,#0                 ;1187
000074  e7d1              B        |L18.26|
;;;1189   
                          ENDP

000076  0000              DCW      0x0000
                  |L18.120|
                          DCD      ||.constdata||
                  |L18.124|
                          DCD      0xa2000010
                  |L18.128|
                          DCD      0xa2100011
                  |L18.132|
                          DCD      0xa2800012
                  |L18.136|
                          DCD      0xa2900013
                  |L18.140|
                          DCD      0x40000210

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;151      */
;;;152    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154        uint32_t u32Freq;
;;;155        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;156    
;;;157    #if(1)
;;;158        if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  0742              LSLS     r2,r0,#29
;;;159        {
;;;160            u32Freq = SystemCoreClock;
000010  4813              LDR      r0,|L19.96|
000012  d017              BEQ      |L19.68|
;;;161        }
;;;162        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV2)
000014  f8d12234          LDR      r2,[r1,#0x234]
000018  f0020207          AND      r2,r2,#7
00001c  2a01              CMP      r2,#1
00001e  d013              BEQ      |L19.72|
;;;163        {
;;;164            u32Freq = SystemCoreClock / 2UL;
;;;165        }
;;;166        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV4)
000020  f8d12234          LDR      r2,[r1,#0x234]
000024  f0020207          AND      r2,r2,#7
000028  2a02              CMP      r2,#2
00002a  d010              BEQ      |L19.78|
;;;167        {
;;;168            u32Freq = SystemCoreClock / 4UL;
;;;169        }
;;;170        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV8)
00002c  f8d12234          LDR      r2,[r1,#0x234]
000030  f0020207          AND      r2,r2,#7
000034  2a03              CMP      r2,#3
000036  d00d              BEQ      |L19.84|
;;;171        {
;;;172            u32Freq = SystemCoreClock / 8UL;
;;;173        }
;;;174        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV16)
000038  f8d11234          LDR      r1,[r1,#0x234]
00003c  f0010107          AND      r1,r1,#7
000040  2904              CMP      r1,#4
000042  d00a              BEQ      |L19.90|
                  |L19.68|
000044  6800              LDR      r0,[r0,#0]            ;160  ; SystemCoreClock
;;;175        {
;;;176            u32Freq = SystemCoreClock / 16UL;
;;;177        }
;;;178        else
;;;179        {
;;;180            u32Freq = SystemCoreClock;
;;;181        }
;;;182    
;;;183    
;;;184    #else
;;;185        if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk) == CLK_CLKSEL0_PCLK0DIV1)
;;;186        {
;;;187            u32Freq =  SystemCoreClock;
;;;188        }
;;;189        else if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk) == CLK_CLKSEL0_PCLK0DIV2)
;;;190        {
;;;191            u32Freq =  SystemCoreClock / 2UL;
;;;192        }
;;;193        else
;;;194        {
;;;195            u32Freq =  SystemCoreClock;
;;;196        }
;;;197    #endif
;;;198    
;;;199        return u32Freq;
;;;200    }
000046  bd10              POP      {r4,pc}
                  |L19.72|
000048  6800              LDR      r0,[r0,#0]            ;164  ; SystemCoreClock
00004a  0840              LSRS     r0,r0,#1              ;164
00004c  bd10              POP      {r4,pc}
                  |L19.78|
00004e  6800              LDR      r0,[r0,#0]            ;168  ; SystemCoreClock
000050  0880              LSRS     r0,r0,#2              ;168
000052  bd10              POP      {r4,pc}
                  |L19.84|
000054  6800              LDR      r0,[r0,#0]            ;172  ; SystemCoreClock
000056  08c0              LSRS     r0,r0,#3              ;172
000058  bd10              POP      {r4,pc}
                  |L19.90|
00005a  6800              LDR      r0,[r0,#0]            ;176  ; SystemCoreClock
00005c  0900              LSRS     r0,r0,#4              ;176
00005e  bd10              POP      {r4,pc}
;;;201    
                          ENDP

                  |L19.96|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;208      */
;;;209    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211        uint32_t u32Freq;
;;;212        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;213    
;;;214    #if(1)
;;;215        if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f70          TST      r0,#0x70
;;;216        {
;;;217            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L20.100|
000014  d017              BEQ      |L20.70|
;;;218        }
;;;219        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f3c21202          UBFX     r2,r2,#4,#3
00001e  2a01              CMP      r2,#1
000020  d013              BEQ      |L20.74|
;;;220        {
;;;221            u32Freq = SystemCoreClock / 2UL;
;;;222        }
;;;223        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV4)
000022  f8d12234          LDR      r2,[r1,#0x234]
000026  f3c21202          UBFX     r2,r2,#4,#3
00002a  2a02              CMP      r2,#2
00002c  d010              BEQ      |L20.80|
;;;224        {
;;;225            u32Freq = SystemCoreClock / 4UL;
;;;226        }
;;;227        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV8)
00002e  f8d12234          LDR      r2,[r1,#0x234]
000032  f3c21202          UBFX     r2,r2,#4,#3
000036  2a03              CMP      r2,#3
000038  d00d              BEQ      |L20.86|
;;;228        {
;;;229            u32Freq = SystemCoreClock / 8UL;
;;;230        }
;;;231        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV16)
00003a  f8d11234          LDR      r1,[r1,#0x234]
00003e  f3c11102          UBFX     r1,r1,#4,#3
000042  2904              CMP      r1,#4
000044  d00a              BEQ      |L20.92|
                  |L20.70|
000046  6800              LDR      r0,[r0,#0]            ;217  ; SystemCoreClock
;;;232        {
;;;233            u32Freq = SystemCoreClock / 16UL;
;;;234        }
;;;235        else
;;;236        {
;;;237            u32Freq = SystemCoreClock;
;;;238        }
;;;239    
;;;240    
;;;241    #else
;;;242        if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk) == CLK_CLKSEL0_PCLK1DIV1)
;;;243        {
;;;244            u32Freq =  SystemCoreClock;
;;;245        }
;;;246        else if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk) == CLK_CLKSEL0_PCLK1DIV2)
;;;247        {
;;;248            u32Freq =  SystemCoreClock / 2UL;
;;;249        }
;;;250        else
;;;251        {
;;;252            u32Freq =  SystemCoreClock;
;;;253        }
;;;254    #endif
;;;255    
;;;256        return u32Freq;
;;;257    }
000048  bd10              POP      {r4,pc}
                  |L20.74|
00004a  6800              LDR      r0,[r0,#0]            ;221  ; SystemCoreClock
00004c  0840              LSRS     r0,r0,#1              ;221
00004e  bd10              POP      {r4,pc}
                  |L20.80|
000050  6800              LDR      r0,[r0,#0]            ;225  ; SystemCoreClock
000052  0880              LSRS     r0,r0,#2              ;225
000054  bd10              POP      {r4,pc}
                  |L20.86|
000056  6800              LDR      r0,[r0,#0]            ;229  ; SystemCoreClock
000058  08c0              LSRS     r0,r0,#3              ;229
00005a  bd10              POP      {r4,pc}
                  |L20.92|
00005c  6800              LDR      r0,[r0,#0]            ;233  ; SystemCoreClock
00005e  0900              LSRS     r0,r0,#4              ;233
000060  bd10              POP      {r4,pc}
;;;258    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;1082     */
;;;1083   uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;1084   {
;;;1085       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1086       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1087       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000002  a110              ADR      r1,|L21.68|
000004  2000              MOVS     r0,#0                 ;1085
000006  6809              LDR      r1,[r1,#0]
;;;1088   
;;;1089       u32PllReg = CLK->PLLCTL;
000008  9100              STR      r1,[sp,#0]
00000a  f04f4180          MOV      r1,#0x40000000
00000e  f8d11240          LDR      r1,[r1,#0x240]
;;;1090   
;;;1091       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000012  f4112fa0          TST      r1,#0x50000
000016  d113              BNE      |L21.64|
;;;1092       {
;;;1093           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1094       }
;;;1095       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1096       {
;;;1097           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1098           {
;;;1099               u32FIN = __HIRC;    /* PLL source clock from HIRC */
000018  480b              LDR      r0,|L21.72|
00001a  038a              LSLS     r2,r1,#14             ;1095
00001c  d410              BMI      |L21.64|
;;;1100           }
;;;1101           else
;;;1102           {
;;;1103               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1104           }
;;;1105   
;;;1106           u32PllFreq = u32FIN;
;;;1107       }
;;;1108       else
;;;1109       {
;;;1110           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1111           {
;;;1112               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1113           }
;;;1114           else
;;;1115           {
;;;1116               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1117           }
;;;1118           /* PLL is output enabled in normal work mode */
;;;1119           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1120           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
00001e  f3c10008          UBFX     r0,r1,#0,#9
000022  f3c13281          UBFX     r2,r1,#14,#2          ;1119
;;;1121           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1122   
;;;1123           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1124           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
000026  4b09              LDR      r3,|L21.76|
000028  1c80              ADDS     r0,r0,#2
00002a  f81d2002          LDRB     r2,[sp,r2]            ;1119
00002e  f3c12144          UBFX     r1,r1,#9,#5           ;1121
000032  4358              MULS     r0,r3,r0
000034  1c49              ADDS     r1,r1,#1
000036  fb11f102          SMULBB   r1,r1,r2
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  00c0              LSLS     r0,r0,#3
                  |L21.64|
;;;1125       }
;;;1126   
;;;1127       return u32PllFreq;
;;;1128   }
000040  bd08              POP      {r3,pc}
;;;1129   
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
000044  01020204          DCB      1,2,2,4
                  |L21.72|
                          DCD      0x00b71b00
                  |L21.76|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_GetPMUWKSrc||, CODE, READONLY, ALIGN=1

                  CLK_GetPMUWKSrc PROC
;;;1040   
;;;1041   uint32_t CLK_GetPMUWKSrc(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;1042   {
;;;1043       return (CLK->PMUSTS);
000004  f8d00294          LDR      r0,[r0,#0x294]
;;;1044   }
000008  4770              BX       lr
;;;1045   
                          ENDP


                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;89       */
;;;90     void CLK_Idle(void)
000000  4806              LDR      r0,|L23.28|
;;;91     {
;;;92         /* Set the processor uses sleep as its low power mode */
;;;93         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;94     
;;;95         /* Set chip in idle mode because of WFI command */
;;;96         CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;97     
;;;98         /* Chip enter idle mode after CPU run WFI instruction */
;;;99         __WFI();
000018  bf30              WFI      
;;;100    }
00001a  4770              BX       lr
;;;101    
                          ENDP

                  |L23.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;70       */
;;;71     void CLK_PowerDown(void)
000000  4806              LDR      r0,|L24.28|
;;;72     {
;;;73         /* Set the processor uses deep sleep as its low power mode */
;;;74         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;75     
;;;76         /* Set system Power-down enabled and Power-down entry condition */
;;;77         CLK->PWRCTL |= CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;78     
;;;79         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;80         __WFI();
000018  bf30              WFI      
;;;81     }
00001a  4770              BX       lr
;;;82     
                          ENDP

                  |L24.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;292      */
;;;293    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;294    {
;;;295        uint32_t u32HIRCSTB;
;;;296    
;;;297        /* Read HIRC clock source stable flag */
;;;298        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  4606              MOV      r6,r0                 ;294
000008  f8d40250          LDR      r0,[r4,#0x250]
00000c  f0000510          AND      r5,r0,#0x10
;;;299    
;;;300        /* The range of u32Hclk is running up to 192 MHz */
;;;301        if(u32Hclk > FREQ_192MHZ)
000010  481b              LDR      r0,|L25.128|
000012  4286              CMP      r6,r0
000014  d900              BLS      |L25.24|
;;;302        {
;;;303            u32Hclk = FREQ_192MHZ;
000016  4606              MOV      r6,r0
                  |L25.24|
;;;304        }
;;;305    
;;;306        /* Switch HCLK clock source to HIRC clock for safe */
;;;307        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d40200          LDR      r0,[r4,#0x200]
00001c  f0400004          ORR      r0,r0,#4
000020  f8c40200          STR      r0,[r4,#0x200]
;;;308        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000024  2010              MOVS     r0,#0x10
000026  f5047400          ADD      r4,r4,#0x200
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;309        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
00002e  6920              LDR      r0,[r4,#0x10]
000030  f0400007          ORR      r0,r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;310        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f020000f          BIC      r0,r0,#0xf
00003c  6220              STR      r0,[r4,#0x20]
;;;311    
;;;312        /* Configure PLL setting if HXT clock is enabled */
;;;313        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
00003e  6820              LDR      r0,[r4,#0]
000040  f5a47400          SUB      r4,r4,#0x200
000044  07c0              LSLS     r0,r0,#31
;;;314        {
;;;315            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;316        }
;;;317        /* Configure PLL setting if HXT clock is not enabled */
;;;318        else
;;;319        {
;;;320            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
000046  4631              MOV      r1,r6
000048  d004              BEQ      |L25.84|
00004a  2000              MOVS     r0,#0                 ;315
00004c  f7fffffe          BL       CLK_EnablePLL
000050  4606              MOV      r6,r0                 ;315
000052  e008              B        |L25.102|
                  |L25.84|
000054  f44f2000          MOV      r0,#0x80000
000058  f7fffffe          BL       CLK_EnablePLL
00005c  4606              MOV      r6,r0
;;;321    
;;;322            /* Read HIRC clock source stable flag */
;;;323            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00005e  f8d40250          LDR      r0,[r4,#0x250]
000062  f0000510          AND      r5,r0,#0x10
                  |L25.102|
;;;324        }
;;;325    
;;;326        /* Select HCLK clock source to PLL,
;;;327           and update system core clock
;;;328        */
;;;329        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
000066  2100              MOVS     r1,#0
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       CLK_SetHCLK
;;;330    
;;;331        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;332        if(u32HIRCSTB == 0UL)
00006e  b92d              CBNZ     r5,|L25.124|
;;;333        {
;;;334            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000070  f8d40200          LDR      r0,[r4,#0x200]
000074  f0200004          BIC      r0,r0,#4
000078  f8c40200          STR      r0,[r4,#0x200]
                  |L25.124|
;;;335        }
;;;336    
;;;337        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;338        return u32Hclk;
00007c  4630              MOV      r0,r6
;;;339    }
00007e  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

                  |L25.128|
                          DCD      0x0b71b000

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=1

                  CLK_SetHCLK PROC
;;;354      */
;;;355    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;356    {
;;;357        uint32_t u32HIRCSTB;
;;;358    
;;;359        /* Read HIRC clock source stable flag */
;;;360        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4480          MOV      r4,#0x40000000
000008  4607              MOV      r7,r0                 ;356
00000a  f8d40250          LDR      r0,[r4,#0x250]
00000e  460e              MOV      r6,r1                 ;356
000010  f0000510          AND      r5,r0,#0x10
;;;361    
;;;362        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;363        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f0400004          ORR      r0,r0,#4
00001c  f8c40200          STR      r0,[r4,#0x200]
;;;364        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f5047400          ADD      r4,r4,#0x200
000026  f7fffffe          BL       CLK_WaitClockReady
;;;365        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400007          ORR      r0,r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;366    
;;;367        /* Apply new Divider */
;;;368        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000032  6a20              LDR      r0,[r4,#0x20]
000034  f020000f          BIC      r0,r0,#0xf
000038  4330              ORRS     r0,r0,r6
00003a  6220              STR      r0,[r4,#0x20]
;;;369    
;;;370        /* Switch HCLK to new HCLK source */
;;;371        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0200007          BIC      r0,r0,#7
000042  4338              ORRS     r0,r0,r7
000044  6120              STR      r0,[r4,#0x10]
000046  f5a47400          SUB      r4,r4,#0x200
;;;372    
;;;373        /* Update System Core Clock */
;;;374        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;375    
;;;376        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;377        if(u32HIRCSTB == 0UL)
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L26.94|
;;;378        {
;;;379            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000052  f8d40200          LDR      r0,[r4,#0x200]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c40200          STR      r0,[r4,#0x200]
                  |L26.94|
;;;380        }
;;;381    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;382    
                          ENDP


                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;506      */
;;;507    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;508    {
;;;509        uint32_t u32sel = 0U, u32div = 0U;
;;;510    
;;;511        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d013              BEQ      |L27.48|
;;;512        {
;;;513            /* Get clock divider control register address */
;;;514            if(MODULE_CLKDIV(u32ModuleIdx) == 2U)
000008  f3c04381          UBFX     r3,r0,#18,#2
00000c  2b02              CMP      r3,#2
00000e  d022              BEQ      |L27.86|
;;;515            {
;;;516                u32div = (uint32_t)&CLK->CLKDIV3;
;;;517            }
;;;518            else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
000010  ea6f4490          MVN      r4,r0,LSR #18
000014  07a4              LSLS     r4,r4,#30
000016  d021              BEQ      |L27.92|
;;;519            {
;;;520                u32div = (uint32_t)&CLK->CLKDIV4;
;;;521            }
;;;522            else
;;;523            {
;;;524                u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
000018  4c12              LDR      r4,|L27.100|
00001a  eb040383          ADD      r3,r4,r3,LSL #2
                  |L27.30|
;;;525            }
;;;526    
;;;527            /* Apply new divider */
;;;528            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
00001e  681c              LDR      r4,[r3,#0]
000020  f3c02587          UBFX     r5,r0,#10,#8
000024  f3c01644          UBFX     r6,r0,#5,#5
000028  40b5              LSLS     r5,r5,r6
00002a  43ac              BICS     r4,r4,r5
00002c  4314              ORRS     r4,r4,r2
00002e  601c              STR      r4,[r3,#0]
                  |L27.48|
;;;529        }
;;;530    
;;;531        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000030  0e42              LSRS     r2,r0,#25
000032  0752              LSLS     r2,r2,#29
000034  d00e              BEQ      |L27.84|
;;;532        {
;;;533            /* Get clock select control register address */
;;;534            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4U);
000036  4b0b              LDR      r3,|L27.100|
000038  f3c07201          UBFX     r2,r0,#28,#2
00003c  3b10              SUBS     r3,r3,#0x10
00003e  eb030282          ADD      r2,r3,r2,LSL #2
;;;535            /* Set new clock selection setting */
;;;536            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000042  6813              LDR      r3,[r2,#0]
000044  f3c06442          UBFX     r4,r0,#25,#3
000048  f3c05004          UBFX     r0,r0,#20,#5
00004c  4084              LSLS     r4,r4,r0
00004e  43a3              BICS     r3,r3,r4
000050  430b              ORRS     r3,r3,r1
000052  6013              STR      r3,[r2,#0]
                  |L27.84|
;;;537        }
;;;538    }
000054  bd70              POP      {r4-r6,pc}
                  |L27.86|
000056  4b03              LDR      r3,|L27.100|
000058  330c              ADDS     r3,r3,#0xc            ;516
00005a  e7e0              B        |L27.30|
                  |L27.92|
00005c  4b01              LDR      r3,|L27.100|
00005e  3310              ADDS     r3,r3,#0x10           ;520
000060  e7dd              B        |L27.30|
;;;539    
                          ENDP

000062  0000              DCW      0x0000
                  |L27.100|
                          DCD      0x40000220

                          AREA ||i.CLK_SetPowerDownMode||, CODE, READONLY, ALIGN=1

                  CLK_SetPowerDownMode PROC
;;;999    
;;;1000   void CLK_SetPowerDownMode(uint32_t u32PDMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1001   {
000002  4604              MOV      r4,r0
;;;1002       /* Enable LIRC clock before entering to Standby Power-down Mode */
;;;1003       if((u32PDMode == CLK_PMUCTL_PDMSEL_SPD0) || (u32PDMode == CLK_PMUCTL_PDMSEL_SPD1))
;;;1004       {
;;;1005           /* Enable LIRC clock */
;;;1006           CLK->PWRCTL |= CLK_PWRCTL_LIRCEN_Msk;
000004  f04f4580          MOV      r5,#0x40000000
000008  2804              CMP      r0,#4                 ;1003
00000a  d001              BEQ      |L28.16|
00000c  2c05              CMP      r4,#5                 ;1003
00000e  d108              BNE      |L28.34|
                  |L28.16|
000010  f8d50200          LDR      r0,[r5,#0x200]
000014  f0400008          ORR      r0,r0,#8
000018  f8c50200          STR      r0,[r5,#0x200]
;;;1007   
;;;1008           /* Wait for LIRC clock stable */
;;;1009           CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
00001c  2008              MOVS     r0,#8
00001e  f7fffffe          BL       CLK_WaitClockReady
                  |L28.34|
;;;1010       }
;;;1011   
;;;1012       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_PDMSEL_Msk)) | u32PDMode;
000022  f8d50290          LDR      r0,[r5,#0x290]
000026  f0200007          BIC      r0,r0,#7
00002a  4320              ORRS     r0,r0,r4
00002c  f8c50290          STR      r0,[r5,#0x290]
;;;1013   }
000030  bd30              POP      {r4,r5,pc}
;;;1014   
                          ENDP


                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;551      */
;;;552    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;553    {
;;;554        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12210          STR      r2,[r1,#0x210]
;;;555    
;;;556    }
000012  4770              BX       lr
;;;557    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;917      */
;;;918    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;919    {
;;;920        int32_t i32TimeOutCnt = 2160000;
;;;921        uint32_t u32Ret = 1U;
000002  2401              MOVS     r4,#1
000004  4605              MOV      r5,r0                 ;919
000006  4908              LDR      r1,|L30.40|
;;;922    
;;;923        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000008  07a2              LSLS     r2,r4,#30
00000a  e005              B        |L30.24|
                  |L30.12|
;;;924        {
;;;925            if(i32TimeOutCnt-- <= 0)
00000c  1e08              SUBS     r0,r1,#0
00000e  f1a10101          SUB      r1,r1,#1
000012  dc01              BGT      |L30.24|
;;;926            {
;;;927                u32Ret = 0U;
000014  2400              MOVS     r4,#0
;;;928                break;
000016  e004              B        |L30.34|
                  |L30.24|
000018  f8d23250          LDR      r3,[r2,#0x250]        ;923
00001c  ea350003          BICS     r0,r5,r3              ;923
000020  d1f4              BNE      |L30.12|
                  |L30.34|
;;;929            }
;;;930        }
;;;931        return u32Ret;
000022  4620              MOV      r0,r4
;;;932    }
000024  bd30              POP      {r4,r5,pc}
;;;933    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      0x0020f580

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____RRX|
#line 587
|__asm___5_clk_c_9b5832dc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
