; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;62     
;;;63     void GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65         GPIO_SetMode(PH, BIT0, GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;66         GPIO_SetMode(PH, BIT1, GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;67         GPIO_SetMode(PH, BIT2, GPIO_MODE_OUTPUT);	
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;68     }
;;;69     
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.TIMER0_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_Init PROC
;;;54     
;;;55     void TIMER0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;56     {
;;;57         TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L3.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;58         TIMER_EnableInt(TIMER0);
;;;59         NVIC_EnableIRQ(TMR0_IRQn);	
00001a  2020              MOVS     r0,#0x20
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;60         TIMER_Start(TIMER0);
;;;61     }
000028  bd10              POP      {r4,pc}
;;;62     
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40050000

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR0_IRQHandler PROC
;;;25     
;;;26     void TMR0_IRQHandler(void)
000000  480c              LDR      r0,|L4.52|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;27     {
000008  2900              CMP      r1,#0
00000a  d011              BEQ      |L4.48|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;28     //	static uint16_t cnt_gpio = 0;
;;;29     
;;;30     	static uint32_t LOG = 0;
;;;31     	static uint16_t CNT = 0;
;;;32     
;;;33         if(TIMER_GetIntFlag(TIMER0) == 1)
;;;34         {
;;;35             /* Clear Timer0 time-out interrupt flag */
;;;36             TIMER_ClearIntFlag(TIMER0);
;;;37     
;;;38     		if (CNT++ >= 1000)
000010  4909              LDR      r1,|L4.56|
000012  8808              LDRH     r0,[r1,#0]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  800a              STRH     r2,[r1,#0]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d308              BCC      |L4.48|
;;;39     		{
;;;40     			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;41             	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
000022  684a              LDR      r2,[r1,#4]  ; LOG
000024  1c50              ADDS     r0,r2,#1
000026  6048              STR      r0,[r1,#4]  ; LOG
000028  4904              LDR      r1,|L4.60|
00002a  a005              ADR      r0,|L4.64|
00002c  f7ffbffe          B.W      __2printf
                  |L4.48|
;;;42     		}
;;;43     
;;;44     //		if (cnt_gpio++ >= 1000)
;;;45     //		{
;;;46     //			cnt_gpio = 0;
;;;47     //			GPIO_TOGGLE(PH1);
;;;48     //			PH1 = ~PH1;
;;;49     //		}
;;;50     		
;;;51     
;;;52         }
;;;53     }
000030  4770              BX       lr
;;;54     
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x40050000
                  |L4.56|
                          DCD      ||.data||
                  |L4.60|
                          DCD      ||.constdata||
                  |L4.64|
000040  2573203a          DCB      "%s : %4d\r\n",0
000044  20253464
000048  0d0a00  
00004b  00                DCB      0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;69     
;;;70     void UART0_IRQHandler(void)
000000  4912              LDR      r1,|L5.76|
;;;71     {
;;;72     	if (UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk))
000002  69c8              LDR      r0,[r1,#0x1c]
000004  05c2              LSLS     r2,r0,#23
;;;73     	{
;;;74     		while(!UART_GET_RX_EMPTY(UART0))
;;;75     		{
;;;76     			uartDev.buf[uartDev.len++] = UART_READ(UART0);
000006  4812              LDR      r0,|L5.80|
000008  d409              BMI      |L5.30|
00000a  e00b              B        |L5.36|
                  |L5.12|
00000c  680a              LDR      r2,[r1,#0]
00000e  f8b03400          LDRH     r3,[r0,#0x400]  ; uartDev
000012  54c2              STRB     r2,[r0,r3]
000014  f8b02400          LDRH     r2,[r0,#0x400]  ; uartDev
000018  1c52              ADDS     r2,r2,#1
00001a  f8a02400          STRH     r2,[r0,#0x400]
                  |L5.30|
00001e  698a              LDR      r2,[r1,#0x18]         ;74
000020  0452              LSLS     r2,r2,#17             ;74
000022  d5f3              BPL      |L5.12|
                  |L5.36|
;;;77     		}
;;;78     	}
;;;79     	
;;;80     	if (UART_GET_INT_FLAG(UART0,UART_INTSTS_RXTOIF_Msk))
000024  69ca              LDR      r2,[r1,#0x1c]
000026  06d2              LSLS     r2,r2,#27
000028  d409              BMI      |L5.62|
;;;81     	{
;;;82     		while(!UART_GET_RX_EMPTY(UART0))
;;;83     		{
;;;84     			uartDev.buf[uartDev.len++] = UART_READ(UART0);
;;;85     		}
;;;86     		
;;;87     		uartDev.end = 1;
;;;88     	}
;;;89     }
00002a  4770              BX       lr
                  |L5.44|
00002c  680a              LDR      r2,[r1,#0]            ;84
00002e  f8b03400          LDRH     r3,[r0,#0x400]        ;84  ; uartDev
000032  54c2              STRB     r2,[r0,r3]            ;84
000034  f8b02400          LDRH     r2,[r0,#0x400]        ;84  ; uartDev
000038  1c52              ADDS     r2,r2,#1              ;84
00003a  f8a02400          STRH     r2,[r0,#0x400]        ;84
                  |L5.62|
00003e  698a              LDR      r2,[r1,#0x18]         ;82
000040  0452              LSLS     r2,r2,#17             ;82
000042  d5f3              BPL      |L5.44|
000044  2101              MOVS     r1,#1                 ;87
000046  f8801402          STRB     r1,[r0,#0x402]        ;87
00004a  4770              BX       lr
;;;90     
                          ENDP

                  |L5.76|
                          DCD      0x40070000
                  |L5.80|
                          DCD      ||.bss||

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;116    
;;;117    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;120        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000002  f04f4080          MOV      r0,#0x40000000
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  f421017f          BIC      r1,r1,#0xff0000
00000c  63c1              STR      r1,[r0,#0x3c]
;;;121        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00000e  6bc1              LDR      r1,[r0,#0x3c]
000010  f44101cc          ORR      r1,r1,#0x660000
000014  63c1              STR      r1,[r0,#0x3c]
;;;122    
;;;123        SYS_ResetModule(UART0_RST);
000016  481e              LDR      r0,|L6.144|
000018  f7fffffe          BL       SYS_ResetModule
;;;124    
;;;125        /* Configure UART0 and set UART0 baud rate */
;;;126        UART_Open(UART0, 115200);
00001c  4c1d              LDR      r4,|L6.148|
00001e  f44f31e1          MOV      r1,#0x1c200
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       UART_Open
;;;127    
;;;128    	/* Set UART receive time-out */
;;;129    	UART_SetTimeoutCnt(UART0, 20);
000028  2114              MOVS     r1,#0x14
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_SetTimeoutCnt
;;;130    
;;;131    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;132    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
000030  68a0              LDR      r0,[r4,#8]
000032  f0200010          BIC      r0,r0,#0x10
000036  60a0              STR      r0,[r4,#8]
;;;133    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000038  68a0              LDR      r0,[r4,#8]
00003a  f0400020          ORR      r0,r0,#0x20
00003e  60a0              STR      r0,[r4,#8]
;;;134    
;;;135    	/* Enable UART Interrupt - */
;;;136    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
000040  6860              LDR      r0,[r4,#4]
000042  f6400111          MOV      r1,#0x811
000046  4308              ORRS     r0,r0,r1
000048  6060              STR      r0,[r4,#4]
;;;137    	
;;;138    	NVIC_EnableIRQ(UART0_IRQn);
00004a  2024              MOVS     r0,#0x24
00004c  f7fffffe          BL       NVIC_EnableIRQ
;;;139    	
;;;140    	memset(&uartDev, 0x00, sizeof(UART_BUF_t));
000050  f2404104          MOV      r1,#0x404
000054  4810              LDR      r0,|L6.152|
000056  f7fffffe          BL       __aeabi_memclr
;;;141    
;;;142    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00005a  f7fffffe          BL       CLK_GetCPUFreq
00005e  4601              MOV      r1,r0
000060  a00e              ADR      r0,|L6.156|
000062  f7fffffe          BL       __2printf
;;;143    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
000066  f7fffffe          BL       CLK_GetHCLKFreq
00006a  4601              MOV      r1,r0
00006c  a012              ADR      r0,|L6.184|
00006e  f7fffffe          BL       __2printf
;;;144    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000072  f7fffffe          BL       CLK_GetPCLK0Freq
000076  4601              MOV      r1,r0
000078  a015              ADR      r0,|L6.208|
00007a  f7fffffe          BL       __2printf
;;;145    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00007e  f7fffffe          BL       CLK_GetPCLK1Freq
000082  4601              MOV      r1,r0
000084  e8bd4010          POP      {r4,lr}
000088  a018              ADR      r0,|L6.236|
00008a  f7ffbffe          B.W      __2printf
;;;146    	
;;;147    }
;;;148    
                          ENDP

00008e  0000              DCW      0x0000
                  |L6.144|
                          DCD      0x04000010
                  |L6.148|
                          DCD      0x40070000
                  |L6.152|
                          DCD      ||.bss||
                  |L6.156|
00009c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000a0  4b5f4765
0000a4  74435055
0000a8  46726571
0000ac  203a2025
0000b0  38640d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L6.184|
0000b8  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000bc  47657448
0000c0  434c4b46
0000c4  72657120
0000c8  3a202538
0000cc  640d0a00
                  |L6.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L6.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UART0_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  UART0_Process PROC
;;;90     
;;;91     void UART0_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;92     {
;;;93     	/*
;;;94     		EC_M451_UART_Timerout_V1.00.zip
;;;95     		https://www.nuvoton.com/hq/resource-download.jsp?tp_GUID=EC0120160728090754
;;;96     	*/
;;;97     	
;;;98     	if (uartDev.end)
000002  4c12              LDR      r4,|L7.76|
;;;99     	{
;;;100    		while(!UART_GET_RX_EMPTY(UART0))
;;;101    		{
;;;102    			uartDev.buf[uartDev.len++] = UART_READ(UART0);
000004  4d12              LDR      r5,|L7.80|
000006  f8940402          LDRB     r0,[r4,#0x402]        ;98  ; uartDev
00000a  b948              CBNZ     r0,|L7.32|
;;;103    		}
;;;104    
;;;105    		#if 1
;;;106    		printf("%s : %d\r\n",__FUNCTION__,uartDev.len);
;;;107    		#endif
;;;108    
;;;109    		UART_Write(UART0,uartDev.buf,uartDev.len);
;;;110    		
;;;111    		memset(&uartDev, 0x00, sizeof(UART_BUF_t));
;;;112    	}
;;;113    
;;;114    }
00000c  bd70              POP      {r4-r6,pc}
                  |L7.14|
00000e  6828              LDR      r0,[r5,#0]            ;102
000010  f8b41400          LDRH     r1,[r4,#0x400]        ;102  ; uartDev
000014  5460              STRB     r0,[r4,r1]            ;102
000016  f8b41400          LDRH     r1,[r4,#0x400]        ;102  ; uartDev
00001a  1c49              ADDS     r1,r1,#1              ;102
00001c  f8a41400          STRH     r1,[r4,#0x400]        ;102
                  |L7.32|
000020  69a8              LDR      r0,[r5,#0x18]         ;100
000022  0440              LSLS     r0,r0,#17             ;100
000024  d5f3              BPL      |L7.14|
000026  f8b42400          LDRH     r2,[r4,#0x400]        ;106  ; uartDev
00002a  490a              LDR      r1,|L7.84|
00002c  a00a              ADR      r0,|L7.88|
00002e  f7fffffe          BL       __2printf
000032  f8b42400          LDRH     r2,[r4,#0x400]        ;109  ; uartDev
000036  4905              LDR      r1,|L7.76|
000038  4628              MOV      r0,r5                 ;109
00003a  f7fffffe          BL       UART_Write
00003e  e8bd4070          POP      {r4-r6,lr}            ;111
000042  f2404104          MOV      r1,#0x404             ;111
000046  4801              LDR      r0,|L7.76|
000048  f7ffbffe          B.W      __aeabi_memclr
;;;115    
                          ENDP

                  |L7.76|
                          DCD      ||.bss||
                  |L7.80|
                          DCD      0x40070000
                  |L7.84|
                          DCD      ||.constdata||+0x10
                  |L7.88|
000058  2573203a          DCB      "%s : %d\r\n",0
00005c  2025640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;156    
;;;157    int main()
000000  f7fffffe          BL       SYS_Init
;;;158    {
;;;159    
;;;160        SYS_Init();
;;;161    	
;;;162        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;163    
;;;164    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;165    	
;;;166    	TIMER0_Init();
00000c  f7fffffe          BL       TIMER0_Init
                  |L8.16|
;;;167    	
;;;168        /* Got no where to go, just loop forever */
;;;169        while(1)
;;;170        {
;;;171    //        CLK_SysTickDelay(delays(100));
;;;172    //		GPIO_TOGGLE(PH2);
;;;173    
;;;174    		UART0_Process();
000010  f7fffffe          BL       UART0_Process
000014  e7fc              B        |L8.16|
;;;175        }
;;;176    
;;;177    }
;;;178    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  uartDev
                          %        1028

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5230          DCB      0x54,0x4d,0x52,0x30
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00
                  |symbol_number.29|
000010  55415254          DCB      0x55,0x41,0x52,0x54
000014  305f5072          DCB      0x30,0x5f,0x50,0x72
000018  6f636573          DCB      0x6f,0x63,0x65,0x73
00001c  7300              DCB      0x73,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ||CNT||
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d50ddd2d____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d50ddd2d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d50ddd2d____REVSH|
#line 402
|__asm___6_main_c_d50ddd2d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d50ddd2d____RRX|
#line 587
|__asm___6_main_c_d50ddd2d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
