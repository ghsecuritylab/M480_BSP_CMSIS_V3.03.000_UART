; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\emac.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\emac.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\emac.crf ..\..\..\Library\StdDriver\src\emac.c]
                          THUMB

                          AREA ||i.EMAC_CheckLinkStatus||, CODE, READONLY, ALIGN=2

                  EMAC_CheckLinkStatus PROC
;;;940      */
;;;941    uint32_t EMAC_CheckLinkStatus(void)
000000  b510              PUSH     {r4,lr}
;;;942    {
;;;943        uint32_t reg, ret = EMAC_LINK_DOWN;
;;;944    
;;;945        /* Check link valid again */
;;;946        if(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_LINK_VALID)
000002  2101              MOVS     r1,#1
000004  2400              MOVS     r4,#0                 ;943
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       EMAC_MdioRead
00000c  0740              LSLS     r0,r0,#29
00000e  d52f              BPL      |L1.112|
;;;947        {
;;;948            /* Check link partner capability */
;;;949            reg = EMAC_MdioRead(PHY_ANLPA_REG, EMAC_PHY_ADDR) ;
000010  2101              MOVS     r1,#1
000012  2005              MOVS     r0,#5
000014  f7fffffe          BL       EMAC_MdioRead
;;;950            if (reg & PHY_ANLPA_DR100_TX_FULL)
;;;951            {
;;;952                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
000018  4916              LDR      r1,|L1.116|
00001a  05c2              LSLS     r2,r0,#23             ;950
00001c  d50a              BPL      |L1.52|
00001e  f8510f90          LDR      r0,[r1,#0x90]!
000022  f4401080          ORR      r0,r0,#0x100000
000026  6008              STR      r0,[r1,#0]
;;;953                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
000028  6808              LDR      r0,[r1,#0]
00002a  f4402080          ORR      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;954                ret = EMAC_LINK_100F;
000030  2401              MOVS     r4,#1
000032  e01d              B        |L1.112|
                  |L1.52|
;;;955            }
;;;956            else if (reg & PHY_ANLPA_DR100_TX_HALF)
000034  0602              LSLS     r2,r0,#24
000036  d50a              BPL      |L1.78|
;;;957            {
;;;958                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
000038  f8510f90          LDR      r0,[r1,#0x90]!
00003c  f4401080          ORR      r0,r0,#0x100000
000040  6008              STR      r0,[r1,#0]
;;;959                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
000042  6808              LDR      r0,[r1,#0]
000044  f4202080          BIC      r0,r0,#0x40000
000048  6008              STR      r0,[r1,#0]
;;;960                ret = EMAC_LINK_100H;
00004a  2402              MOVS     r4,#2
00004c  e010              B        |L1.112|
                  |L1.78|
;;;961            }
;;;962            else if (reg & PHY_ANLPA_DR10_TX_FULL)
00004e  0640              LSLS     r0,r0,#25
;;;963            {
;;;964                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
;;;965                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
;;;966                ret = EMAC_LINK_10F;
;;;967            }
;;;968            else
;;;969            {
;;;970                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
000050  f8510f90          LDR      r0,[r1,#0x90]!
000054  f4201080          BIC      r0,r0,#0x100000
000058  6008              STR      r0,[r1,#0]
;;;971                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
00005a  6808              LDR      r0,[r1,#0]
00005c  d504              BPL      |L1.104|
00005e  f4402080          ORR      r0,r0,#0x40000        ;965
000062  6008              STR      r0,[r1,#0]            ;965
000064  2403              MOVS     r4,#3                 ;966
000066  e003              B        |L1.112|
                  |L1.104|
000068  f4202080          BIC      r0,r0,#0x40000
00006c  6008              STR      r0,[r1,#0]
;;;972                ret = EMAC_LINK_10H;
00006e  2404              MOVS     r4,#4
                  |L1.112|
;;;973            }
;;;974        }
;;;975        return ret;
000070  4620              MOV      r0,r4
;;;976    }
000072  bd10              POP      {r4,pc}
;;;977    
                          ENDP

                  |L1.116|
                          DCD      0x4000b000

                          AREA ||i.EMAC_Close||, CODE, READONLY, ALIGN=2

                  EMAC_Close PROC
;;;426    
;;;427    void EMAC_Close(void)
000000  4805              LDR      r0,|L2.24|
;;;428    {
;;;429        EMAC->CTL |= EMAC_CTL_RST_Msk;
000002  f8d01090          LDR      r1,[r0,#0x90]
000006  f0417180          ORR      r1,r1,#0x1000000
00000a  f8c01090          STR      r1,[r0,#0x90]
                  |L2.14|
;;;430        while(EMAC->CTL & EMAC_CTL_RST_Msk) {}
00000e  f8d01090          LDR      r1,[r0,#0x90]
000012  01c9              LSLS     r1,r1,#7
000014  d4fb              BMI      |L2.14|
;;;431    }
000016  4770              BX       lr
;;;432    
                          ENDP

                  |L2.24|
                          DCD      0x4000b000

                          AREA ||i.EMAC_DisableAlarm||, CODE, READONLY, ALIGN=2

                  EMAC_DisableAlarm PROC
;;;903      */
;;;904    void EMAC_DisableAlarm(void)
000000  4803              LDR      r0,|L3.16|
;;;905    {
;;;906    
;;;907        EMAC->TSCTL &= ~EMAC_TSCTL_TSALMEN_Msk;
000002  f8d01100          LDR      r1,[r0,#0x100]
000006  f0210120          BIC      r1,r1,#0x20
00000a  f8c01100          STR      r1,[r0,#0x100]
;;;908    
;;;909    }
00000e  4770              BX       lr
;;;910    
                          ENDP

                  |L3.16|
                          DCD      0x4000b000

                          AREA ||i.EMAC_DisableCamEntry||, CODE, READONLY, ALIGN=2

                  EMAC_DisableCamEntry PROC
;;;473      */
;;;474    void EMAC_DisableCamEntry(uint32_t u32Entry)
000000  4903              LDR      r1,|L4.16|
;;;475    {
;;;476        EMAC->CAMEN &= ~(1UL << u32Entry);
000002  684a              LDR      r2,[r1,#4]
000004  2301              MOVS     r3,#1
000006  4083              LSLS     r3,r3,r0
000008  439a              BICS     r2,r2,r3
00000a  604a              STR      r2,[r1,#4]
;;;477    }
00000c  4770              BX       lr
;;;478    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x4000b000

                          AREA ||i.EMAC_DisableTS||, CODE, READONLY, ALIGN=2

                  EMAC_DisableTS PROC
;;;849      */
;;;850    void EMAC_DisableTS(void)
000000  4902              LDR      r1,|L5.12|
;;;851    {
;;;852        EMAC->TSCTL = 0UL;
000002  2000              MOVS     r0,#0
000004  f8c10100          STR      r0,[r1,#0x100]
;;;853    }
000008  4770              BX       lr
;;;854    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x4000b000

                          AREA ||i.EMAC_EnableAlarm||, CODE, READONLY, ALIGN=2

                  EMAC_EnableAlarm PROC
;;;889      */
;;;890    void EMAC_EnableAlarm(uint32_t u32Sec, uint32_t u32Nsec)
000000  b510              PUSH     {r4,lr}
;;;891    {
;;;892    
;;;893        EMAC->ALMSEC = u32Sec;
000002  4c07              LDR      r4,|L6.32|
000004  f8c40128          STR      r0,[r4,#0x128]
;;;894        EMAC->ALMSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
000008  4608              MOV      r0,r1
00000a  f5047480          ADD      r4,r4,#0x100
00000e  f7fffffe          BL       EMAC_Nsec2Subsec
000012  62e0              STR      r0,[r4,#0x2c]
;;;895        EMAC->TSCTL |= EMAC_TSCTL_TSALMEN_Msk;
000014  6820              LDR      r0,[r4,#0]
000016  f0400020          ORR      r0,r0,#0x20
00001a  6020              STR      r0,[r4,#0]
;;;896    
;;;897    }
00001c  bd10              POP      {r4,pc}
;;;898    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x4000b000

                          AREA ||i.EMAC_EnableCamEntry||, CODE, READONLY, ALIGN=2

                  EMAC_EnableCamEntry PROC
;;;449      */
;;;450    void EMAC_EnableCamEntry(uint32_t u32Entry, uint8_t pu8MacAddr[])
000000  888a              LDRH     r2,[r1,#4]
;;;451    {
;;;452        uint32_t u32Lsw, u32Msw;
;;;453        uint32_t reg;
;;;454        u32Lsw = (uint32_t)(((uint32_t)pu8MacAddr[4] << 24) |
000002  ba52              REV16    r2,r2
000004  0413              LSLS     r3,r2,#16
;;;455                            ((uint32_t)pu8MacAddr[5] << 16));
;;;456        u32Msw = (uint32_t)(((uint32_t)pu8MacAddr[0] << 24)|
000006  680a              LDR      r2,[r1,#0]
000008  78c9              LDRB     r1,[r1,#3]
00000a  ba12              REV      r2,r2
00000c  f02202ff          BIC      r2,r2,#0xff
000010  430a              ORRS     r2,r2,r1
;;;457                            ((uint32_t)pu8MacAddr[1] << 16)|
;;;458                            ((uint32_t)pu8MacAddr[2] << 8)|
;;;459                            (uint32_t)pu8MacAddr[3]);
;;;460    
;;;461        reg = (uint32_t)&EMAC->CAM0M + u32Entry * 2UL * 4UL;
000012  4907              LDR      r1,|L7.48|
;;;462        *(uint32_t volatile *)reg = u32Msw;
000014  f8412030          STR      r2,[r1,r0,LSL #3]
;;;463        reg = (uint32_t)&EMAC->CAM0L + u32Entry * 2UL * 4UL;
000018  1d09              ADDS     r1,r1,#4
;;;464        *(uint32_t volatile *)reg = u32Lsw;
00001a  f8413030          STR      r3,[r1,r0,LSL #3]
;;;465    
;;;466        EMAC->CAMEN |= (1UL << u32Entry);
00001e  4904              LDR      r1,|L7.48|
000020  3908              SUBS     r1,r1,#8
000022  684a              LDR      r2,[r1,#4]
000024  2301              MOVS     r3,#1
000026  4083              LSLS     r3,r3,r0
000028  431a              ORRS     r2,r2,r3
00002a  604a              STR      r2,[r1,#4]
;;;467    }
00002c  4770              BX       lr
;;;468    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x4000b008

                          AREA ||i.EMAC_EnableTS||, CODE, READONLY, ALIGN=2

                  EMAC_EnableTS PROC
;;;821      */
;;;822    void EMAC_EnableTS(uint32_t u32Sec, uint32_t u32Nsec)
000000  b510              PUSH     {r4,lr}
;;;823    {
;;;824        double f;
;;;825        uint32_t reg;
;;;826        EMAC->TSCTL = EMAC_TSCTL_TSEN_Msk;
000002  4c1a              LDR      r4,|L8.108|
000004  2201              MOVS     r2,#1
000006  ed2d8b02          VPUSH    {d8}                  ;823
00000a  f8c42100          STR      r2,[r4,#0x100]
;;;827        EMAC->UPDSEC = u32Sec;   /* Assume current time is 0 sec + 0 nano sec */
00000e  f8c40120          STR      r0,[r4,#0x120]
;;;828        EMAC->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
000012  4608              MOV      r0,r1
000014  f5047480          ADD      r4,r4,#0x100
000018  f7fffffe          BL       EMAC_Nsec2Subsec
00001c  6260              STR      r0,[r4,#0x24]
;;;829    
;;;830        /* PTP source clock is 160MHz (Real chip using PLL). Each tick is 6.25ns
;;;831           Assume we want to set each tick to 100ns.
;;;832           Increase register = (100 * 2^31) / (10^9) = 214.71 =~ 215 = 0xD7
;;;833           Addend register = 2^32 * tick_freq / (160MHz), where tick_freq = (2^31 / 215) MHz
;;;834           From above equation, addend register = 2^63 / (160M * 215) ~= 268121280 = 0xFFB34C0
;;;835           So:
;;;836            EMAC->TSIR = 0xD7;
;;;837            EMAC->TSAR = 0x1E70C600; */
;;;838        f = (100.0 * 2147483648.0) / (1000000000.0) + 0.5;
00001e  ed9f0b14          VLDR     d0,|L8.112|
;;;839        EMAC->TSINC = (reg = (uint32_t)f);
000022  ec510b10          VMOV     r0,r1,d0
000026  f7fffffe          BL       __aeabi_d2uiz
00002a  61a0              STR      r0,[r4,#0x18]
;;;840        f = (double)9223372036854775808.0 / ((double)(CLK_GetHCLKFreq()) * (double)reg);
00002c  f7fffffe          BL       __aeabi_ui2d
000030  ec410b18          VMOV     d8,r0,r1
000034  f7fffffe          BL       CLK_GetHCLKFreq
000038  f7fffffe          BL       __aeabi_ui2d
00003c  ec532b18          VMOV     r2,r3,d8
000040  f7fffffe          BL       __aeabi_dmul
000044  ec410b10          VMOV     d0,r0,r1
000048  ec532b10          VMOV     r2,r3,d0
00004c  ed9f0b0a          VLDR     d0,|L8.120|
000050  ec510b10          VMOV     r0,r1,d0
000054  f7fffffe          BL       __aeabi_ddiv
;;;841        EMAC->TSADDEND = (uint32_t)f;
000058  f7fffffe          BL       __aeabi_d2uiz
00005c  61e0              STR      r0,[r4,#0x1c]
;;;842        EMAC->TSCTL |= (EMAC_TSCTL_TSUPDATE_Msk | EMAC_TSCTL_TSIEN_Msk | EMAC_TSCTL_TSMODE_Msk); /* Fine update */
00005e  6820              LDR      r0,[r4,#0]
000060  f040000e          ORR      r0,r0,#0xe
000064  6020              STR      r0,[r4,#0]
;;;843    }
000066  ecbd8b02          VPOP     {d8}
00006a  bd10              POP      {r4,pc}
;;;844    
                          ENDP

                  |L8.108|
                          DCD      0x4000b000
                  |L8.112|
000070  9abcaf48          DCFD     0x406ae7f29abcaf48 ; 215.24836479999999
000074  406ae7f2
                  |L8.120|
000078  00000000          DCFD     0x43e0000000000000 ; 9223372036854775800
00007c  43e00000

                          AREA ||i.EMAC_GetTime||, CODE, READONLY, ALIGN=2

                  EMAC_GetTime PROC
;;;860      */
;;;861    void EMAC_GetTime(uint32_t *pu32Sec, uint32_t *pu32Nsec)
000000  b570              PUSH     {r4-r6,lr}
;;;862    {
;;;863        /* Must read TSLSR firstly. Hardware will preserve TSMSR value at the time TSLSR read. */
;;;864        *pu32Nsec = EMAC_Subsec2Nsec(EMAC->TSSUBSEC);
000002  4c06              LDR      r4,|L9.28|
000004  4606              MOV      r6,r0                 ;862
000006  460d              MOV      r5,r1                 ;862
000008  f8d40114          LDR      r0,[r4,#0x114]
00000c  f5047488          ADD      r4,r4,#0x110
000010  f7fffffe          BL       EMAC_Subsec2Nsec
;;;865        *pu32Sec = EMAC->TSSEC;
000014  6028              STR      r0,[r5,#0]
000016  6820              LDR      r0,[r4,#0]
000018  6030              STR      r0,[r6,#0]
;;;866    }
00001a  bd70              POP      {r4-r6,pc}
;;;867    
                          ENDP

                  |L9.28|
                          DCD      0x4000b000

                          AREA ||i.EMAC_MdioRead||, CODE, READONLY, ALIGN=2

                  EMAC_MdioRead PROC
;;;183      */
;;;184    static uint32_t EMAC_MdioRead(uint32_t u32Reg, uint32_t u32Addr)
000000  ea402001          ORR      r0,r0,r1,LSL #8
;;;185    {
;;;186        /* Set PHY address, PHY register address, busy bit */
;;;187        EMAC->MIIMCTL = u32Reg | (u32Addr << EMAC_MIIMCTL_PHYADDR_Pos) | EMAC_MIIMCTL_BUSY_Msk | EMAC_MIIMCTL_MDCON_Msk;
000004  f4402120          ORR      r1,r0,#0xa0000
000008  4804              LDR      r0,|L10.28|
00000a  f8c01098          STR      r1,[r0,#0x98]
                  |L10.14|
;;;188        /* Wait read complete by polling busy bit */
;;;189        while(EMAC->MIIMCTL & EMAC_MIIMCTL_BUSY_Msk)
00000e  f8d01098          LDR      r1,[r0,#0x98]
000012  0389              LSLS     r1,r1,#14
000014  d4fb              BMI      |L10.14|
;;;190        {
;;;191            ;
;;;192        }
;;;193        /* Get return data */
;;;194        return EMAC->MIIMDAT;
000016  f8d00094          LDR      r0,[r0,#0x94]
;;;195    }
00001a  4770              BX       lr
;;;196    
                          ENDP

                  |L10.28|
                          DCD      0x4000b000

                          AREA ||i.EMAC_MdioWrite||, CODE, READONLY, ALIGN=2

                  EMAC_MdioWrite PROC
;;;163      */
;;;164    static void EMAC_MdioWrite(uint32_t u32Reg, uint32_t u32Addr, uint32_t u32Data)
000000  4b06              LDR      r3,|L11.28|
;;;165    {
;;;166        /* Set data register */
;;;167        EMAC->MIIMDAT = u32Data ;
000002  f8c32094          STR      r2,[r3,#0x94]
;;;168        /* Set PHY address, PHY register address, busy bit and write bit */
;;;169        EMAC->MIIMCTL = u32Reg | (u32Addr << 8) | EMAC_MIIMCTL_BUSY_Msk | EMAC_MIIMCTL_WRITE_Msk | EMAC_MIIMCTL_MDCON_Msk;
000006  ea402001          ORR      r0,r0,r1,LSL #8
00000a  f4402030          ORR      r0,r0,#0xb0000
00000e  f8c30098          STR      r0,[r3,#0x98]
                  |L11.18|
;;;170        /* Wait write complete by polling busy bit. */
;;;171        while(EMAC->MIIMCTL & EMAC_MIIMCTL_BUSY_Msk)
000012  f8d30098          LDR      r0,[r3,#0x98]
000016  0380              LSLS     r0,r0,#14
000018  d4fb              BMI      |L11.18|
;;;172        {
;;;173            ;
;;;174        }
;;;175    
;;;176    }
00001a  4770              BX       lr
;;;177    
                          ENDP

                  |L11.28|
                          DCD      0x4000b000

                          AREA ||i.EMAC_Nsec2Subsec||, CODE, READONLY, ALIGN=2

                  EMAC_Nsec2Subsec PROC
;;;355      */
;;;356    static uint32_t EMAC_Nsec2Subsec(uint32_t nsec)
000000  b510              PUSH     {r4,lr}
;;;357    {
;;;358        /* 10^9 ns =  2^31 subsec */
;;;359        uint64_t i;
;;;360        i = (1ull << 31) * nsec;
000002  0841              LSRS     r1,r0,#1
000004  07c0              LSLS     r0,r0,#31
;;;361        i /= 1000000000ull;
000006  4a02              LDR      r2,|L12.16|
000008  2300              MOVS     r3,#0
00000a  f7fffffe          BL       __aeabi_uldivmod
;;;362        return((uint32_t)i);
;;;363    }
00000e  bd10              POP      {r4,pc}
;;;364    
                          ENDP

                  |L12.16|
                          DCD      0x3b9aca00

                          AREA ||i.EMAC_Open||, CODE, READONLY, ALIGN=2

                  EMAC_Open PROC
;;;386      */
;;;387    void EMAC_Open(uint8_t *pu8MacAddr)
000000  b510              PUSH     {r4,lr}
;;;388    {
000002  4604              MOV      r4,r0
;;;389        /* Enable transmit and receive descriptor */
;;;390        EMAC_TxDescInit();
000004  f7fffffe          BL       EMAC_TxDescInit
;;;391        EMAC_RxDescInit();
000008  f7fffffe          BL       EMAC_RxDescInit
;;;392    
;;;393        /* Set the CAM Control register and the MAC address value */
;;;394        EMAC_SetMacAddr(pu8MacAddr);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       EMAC_SetMacAddr
;;;395    
;;;396        /* Configure the MAC interrupt enable register. */
;;;397        EMAC->INTEN = EMAC_INTEN_RXIEN_Msk |
000012  4809              LDR      r0,|L13.56|
000014  4907              LDR      r1,|L13.52|
000016  f8c010ac          STR      r1,[r0,#0xac]
;;;398                      EMAC_INTEN_TXIEN_Msk |
;;;399                      EMAC_INTEN_RXGDIEN_Msk |
;;;400                      EMAC_INTEN_TXCPIEN_Msk |
;;;401                      EMAC_INTEN_RXBEIEN_Msk |
;;;402                      EMAC_INTEN_TXBEIEN_Msk |
;;;403                      EMAC_INTEN_RDUIEN_Msk |
;;;404                      EMAC_INTEN_TSALMIEN_Msk |
;;;405                      EMAC_INTEN_WOLIEN_Msk;
;;;406    
;;;407        /* Configure the MAC control register. */
;;;408        EMAC->CTL = EMAC_CTL_STRIPCRC_Msk |
00001a  4908              LDR      r1,|L13.60|
00001c  f8c01090          STR      r1,[r0,#0x90]
;;;409                    EMAC_CTL_RMIIEN_Msk;
;;;410    
;;;411        /* Accept packets for us and all broadcast and multicast packets */
;;;412        EMAC->CAMCTL =  EMAC_CAMCTL_CMPEN_Msk |
000020  2116              MOVS     r1,#0x16
000022  f8401b30          STR      r1,[r0],#0x30
;;;413                        EMAC_CAMCTL_AMP_Msk |
;;;414                        EMAC_CAMCTL_ABP_Msk;
;;;415    
;;;416        /* Limit the max receive frame length to 1514 + 4 */
;;;417        EMAC->MRFL = 1518;
000026  f24051ee          MOV      r1,#0x5ee
00002a  6781              STR      r1,[r0,#0x78]
;;;418        EMAC_PhyInit();
00002c  e8bd4010          POP      {r4,lr}
000030  f7ffbffe          B.W      EMAC_PhyInit
;;;419    }
;;;420    
                          ENDP

                  |L13.52|
                          DCD      0x11058c11
                  |L13.56|
                          DCD      0x4000b000
                  |L13.60|
                          DCD      0x00400020

                          AREA ||i.EMAC_PhyInit||, CODE, READONLY, ALIGN=2

                  EMAC_PhyInit PROC
;;;201      */
;;;202    static void EMAC_PhyInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;203    {
;;;204        uint32_t reg;
;;;205        uint32_t i = 0UL;
000002  2400              MOVS     r4,#0
;;;206    
;;;207        /* Reset Phy Chip */
;;;208        EMAC_MdioWrite(PHY_CNTL_REG, EMAC_PHY_ADDR, PHY_CNTL_RESET_PHY);
000004  f44f4200          MOV      r2,#0x8000
000008  2101              MOVS     r1,#1
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       EMAC_MdioWrite
                  |L14.16|
;;;209    
;;;210        /* Wait until reset complete */
;;;211        while (1)
;;;212        {
;;;213            reg = EMAC_MdioRead(PHY_CNTL_REG, EMAC_PHY_ADDR) ;
000010  2101              MOVS     r1,#1
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       EMAC_MdioRead
;;;214            if ((reg & PHY_CNTL_RESET_PHY)==0UL)
000018  0400              LSLS     r0,r0,#16
00001a  d4f9              BMI      |L14.16|
;;;215            {
;;;216                break;
;;;217            }
;;;218        }
;;;219        while(!(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_LINK_VALID))
;;;220        {
;;;221            if(i++ > 80000UL)       /* Cable not connected */
00001c  4e2b              LDR      r6,|L14.204|
;;;222            {
;;;223                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
00001e  4d2c              LDR      r5,|L14.208|
                  |L14.32|
000020  2101              MOVS     r1,#1                 ;219
000022  4608              MOV      r0,r1                 ;219
000024  f7fffffe          BL       EMAC_MdioRead
000028  0740              LSLS     r0,r0,#29             ;219
00002a  d40f              BMI      |L14.76|
00002c  4620              MOV      r0,r4                 ;221
00002e  1c64              ADDS     r4,r4,#1              ;221
000030  42b0              CMP      r0,r6                 ;221
000032  d9f5              BLS      |L14.32|
000034  f8d50090          LDR      r0,[r5,#0x90]
000038  f4201080          BIC      r0,r0,#0x100000
00003c  f8c50090          STR      r0,[r5,#0x90]
;;;224                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
000040  f8d50090          LDR      r0,[r5,#0x90]
000044  f4202080          BIC      r0,r0,#0x40000
000048  f8c50090          STR      r0,[r5,#0x90]
                  |L14.76|
;;;225                break;
;;;226            }
;;;227        }
;;;228    
;;;229        if(i <= 80000UL)
00004c  42b4              CMP      r4,r6
00004e  d835              BHI      |L14.188|
;;;230        {
;;;231            /* Configure auto negotiation capability */
;;;232            EMAC_MdioWrite(PHY_ANA_REG, EMAC_PHY_ADDR, PHY_ANA_DR100_TX_FULL |
000050  f24012e1          MOV      r2,#0x1e1
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       EMAC_MdioWrite
;;;233                           PHY_ANA_DR100_TX_HALF |
;;;234                           PHY_ANA_DR10_TX_FULL |
;;;235                           PHY_ANA_DR10_TX_HALF |
;;;236                           PHY_ANA_IEEE_802_3_CSMA_CD);
;;;237            /* Restart auto negotiation */
;;;238            EMAC_MdioWrite(PHY_CNTL_REG, EMAC_PHY_ADDR, EMAC_MdioRead(PHY_CNTL_REG, EMAC_PHY_ADDR) | PHY_CNTL_RESTART_AN);
00005c  2101              MOVS     r1,#1
00005e  2000              MOVS     r0,#0
000060  f7fffffe          BL       EMAC_MdioRead
000064  f4407200          ORR      r2,r0,#0x200
000068  2101              MOVS     r1,#1
00006a  2000              MOVS     r0,#0
00006c  f7fffffe          BL       EMAC_MdioWrite
                  |L14.112|
;;;239    
;;;240            /* Wait for auto-negotiation complete */
;;;241            while(!(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_AN_COMPLETE))
000070  2101              MOVS     r1,#1
000072  4608              MOV      r0,r1
000074  f7fffffe          BL       EMAC_MdioRead
000078  0680              LSLS     r0,r0,#26
00007a  d5f9              BPL      |L14.112|
                  |L14.124|
;;;242            {
;;;243                ;
;;;244            }
;;;245            /* Check link valid again. Some PHYs needs to check result after link valid bit set */
;;;246            while(!(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_LINK_VALID))
00007c  2101              MOVS     r1,#1
00007e  4608              MOV      r0,r1
000080  f7fffffe          BL       EMAC_MdioRead
000084  0740              LSLS     r0,r0,#29
000086  d5f9              BPL      |L14.124|
;;;247            {
;;;248                ;
;;;249            }
;;;250    
;;;251            /* Check link partner capability */
;;;252            reg = EMAC_MdioRead(PHY_ANLPA_REG, EMAC_PHY_ADDR) ;
000088  2101              MOVS     r1,#1
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       EMAC_MdioRead
;;;253            if (reg & PHY_ANLPA_DR100_TX_FULL)
000090  05c1              LSLS     r1,r0,#23
000092  d508              BPL      |L14.166|
;;;254            {
;;;255                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
000094  f8550f90          LDR      r0,[r5,#0x90]!
000098  f4401080          ORR      r0,r0,#0x100000
                  |L14.156|
;;;256                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
;;;257            }
;;;258            else if (reg & PHY_ANLPA_DR100_TX_HALF)
;;;259            {
;;;260                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
;;;261                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
;;;262            }
;;;263            else if (reg & PHY_ANLPA_DR10_TX_FULL)
;;;264            {
;;;265                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
00009c  6028              STR      r0,[r5,#0]
;;;266                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
00009e  6828              LDR      r0,[r5,#0]
0000a0  f4402080          ORR      r0,r0,#0x40000
0000a4  e009              B        |L14.186|
                  |L14.166|
0000a6  0601              LSLS     r1,r0,#24             ;258
0000a8  d509              BPL      |L14.190|
0000aa  f8550f90          LDR      r0,[r5,#0x90]!        ;260
0000ae  f4401080          ORR      r0,r0,#0x100000       ;260
                  |L14.178|
;;;267            }
;;;268            else
;;;269            {
;;;270                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
0000b2  6028              STR      r0,[r5,#0]
;;;271                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
0000b4  6828              LDR      r0,[r5,#0]
0000b6  f4202080          BIC      r0,r0,#0x40000
                  |L14.186|
0000ba  6028              STR      r0,[r5,#0]            ;256
                  |L14.188|
;;;272            }
;;;273        }
;;;274    }
0000bc  bd70              POP      {r4-r6,pc}
                  |L14.190|
0000be  0640              LSLS     r0,r0,#25             ;263
0000c0  f8550f90          LDR      r0,[r5,#0x90]!        ;270
0000c4  f4201080          BIC      r0,r0,#0x100000       ;270
0000c8  d4e8              BMI      |L14.156|
0000ca  e7f2              B        |L14.178|
;;;275    
                          ENDP

                  |L14.204|
                          DCD      0x00013880
                  |L14.208|
                          DCD      0x4000b000

                          AREA ||i.EMAC_RecvPkt||, CODE, READONLY, ALIGN=2

                  EMAC_RecvPkt PROC
;;;488      */
;;;489    uint32_t EMAC_RecvPkt(uint8_t *pu8Data, uint32_t *pu32Size)
000000  b570              PUSH     {r4-r6,lr}
;;;490    {
;;;491        EMAC_DESCRIPTOR_T *desc;
;;;492        uint32_t status, reg;
;;;493        uint32_t u32Count = 0UL;
;;;494    
;;;495        /* Clear Rx interrupt flags */
;;;496        reg = EMAC->INTSTS;
000002  4b0d              LDR      r3,|L15.56|
000004  4605              MOV      r5,r0                 ;490
000006  2000              MOVS     r0,#0                 ;493
000008  f8532fb0          LDR      r2,[r3,#0xb0]!
;;;497        EMAC->INTSTS = reg & 0xFFFFUL;  /* Clear all RX related interrupt status */
00000c  b294              UXTH     r4,r2
00000e  601c              STR      r4,[r3,#0]
;;;498    
;;;499        if (reg & EMAC_INTSTS_RXBEIF_Msk)
000010  0512              LSLS     r2,r2,#20
000012  d500              BPL      |L15.22|
                  |L15.20|
;;;500        {
;;;501            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;502            while(1) {}
000014  e7fe              B        |L15.20|
                  |L15.22|
;;;503        }
;;;504        else
;;;505        {
;;;506    
;;;507            /* Get Rx Frame Descriptor */
;;;508            desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;
000016  4a09              LDR      r2,|L15.60|
;;;509    
;;;510            /* If we reach last recv Rx descriptor, leave the loop */
;;;511            if ((desc->u32Status1 & EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)   /* ownership=CPU */
000018  68d3              LDR      r3,[r2,#0xc]  ; u32CurrentRxDesc
00001a  681a              LDR      r2,[r3,#0]
00001c  2a00              CMP      r2,#0
00001e  db09              BLT      |L15.52|
;;;512            {
;;;513    
;;;514                status = desc->u32Status1 >> 16;
000020  0c14              LSRS     r4,r2,#16
;;;515    
;;;516                /* If Rx frame is good, process received frame */
;;;517                if(status & EMAC_RXFD_RXGD)
000022  06e4              LSLS     r4,r4,#27
000024  d506              BPL      |L15.52|
;;;518                {
;;;519                    /* lower 16 bit in descriptor status1 stores the Rx packet length */
;;;520                    *pu32Size = desc->u32Status1 & 0xFFFFUL;
000026  b292              UXTH     r2,r2
;;;521                    memcpy(pu8Data, (uint8_t *)desc->u32Backup1, *pu32Size);
000028  600a              STR      r2,[r1,#0]
00002a  4628              MOV      r0,r5
00002c  6919              LDR      r1,[r3,#0x10]
00002e  f7fffffe          BL       __aeabi_memcpy
;;;522                    u32Count = 1UL;
000032  2001              MOVS     r0,#1
                  |L15.52|
;;;523                }
;;;524                else
;;;525                {
;;;526                    /* Save Error status if necessary */
;;;527                    if (status & EMAC_RXFD_RP) {}
;;;528                    if (status & EMAC_RXFD_ALIE) {}
;;;529                    if (status & EMAC_RXFD_PTLE) {}
;;;530                    if (status & EMAC_RXFD_CRCE) {}
;;;531                }
;;;532            }
;;;533        }
;;;534        return(u32Count);
;;;535    }
000034  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x4000b000
                  |L15.60|
                          DCD      ||.data||

                          AREA ||i.EMAC_RecvPktDone||, CODE, READONLY, ALIGN=2

                  EMAC_RecvPktDone PROC
;;;611      */
;;;612    void EMAC_RecvPktDone(void)
000000  4a07              LDR      r2,|L16.32|
;;;613    {
;;;614        EMAC_DESCRIPTOR_T *desc;
;;;615        /* Get Rx Frame Descriptor */
;;;616        desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;
;;;617    
;;;618        /* Restore descriptor link list and data pointer they will be overwrite if time stamp enabled */
;;;619        desc->u32Data = desc->u32Backup1;
000002  68d0              LDR      r0,[r2,#0xc]  ; u32CurrentRxDesc
000004  6901              LDR      r1,[r0,#0x10]
;;;620        desc->u32Next = desc->u32Backup2;
000006  6041              STR      r1,[r0,#4]
000008  6941              LDR      r1,[r0,#0x14]
;;;621    
;;;622        /* Get Next Frame Descriptor pointer to process */
;;;623        desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
;;;624    
;;;625        /* Save last processed Rx descriptor */
;;;626        u32CurrentRxDesc = (uint32_t)desc;
00000a  60c1              STR      r1,[r0,#0xc]
;;;627    
;;;628        /* Change ownership to DMA for next use */
;;;629        desc->u32Status1 |= EMAC_DESC_OWN_EMAC;
00000c  60d1              STR      r1,[r2,#0xc]  ; u32CurrentRxDesc
00000e  6808              LDR      r0,[r1,#0]
000010  f0404000          ORR      r0,r0,#0x80000000
;;;630    
;;;631        EMAC_TRIGGER_RX();
000014  6008              STR      r0,[r1,#0]
000016  4903              LDR      r1,|L16.36|
000018  2000              MOVS     r0,#0
00001a  f8c100a4          STR      r0,[r1,#0xa4]
;;;632    }
00001e  4770              BX       lr
;;;633    
                          ENDP

                  |L16.32|
                          DCD      ||.data||
                  |L16.36|
                          DCD      0x4000b000

                          AREA ||i.EMAC_RecvPktTS||, CODE, READONLY, ALIGN=2

                  EMAC_RecvPktTS PROC
;;;549      */
;;;550    uint32_t EMAC_RecvPktTS(uint8_t *pu8Data, uint32_t *pu32Size, uint32_t *pu32Sec, uint32_t *pu32Nsec)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;551    {
;;;552        EMAC_DESCRIPTOR_T *desc;
;;;553        uint32_t status, reg;
;;;554        uint32_t u32Count = 0UL;
;;;555    
;;;556        /* Clear Rx interrupt flags */
;;;557        reg = EMAC->INTSTS;
000004  4f13              LDR      r7,|L17.84|
000006  461d              MOV      r5,r3                 ;551
000008  4616              MOV      r6,r2                 ;551
00000a  4603              MOV      r3,r0                 ;551
00000c  f8d720b0          LDR      r2,[r7,#0xb0]
000010  2000              MOVS     r0,#0                 ;554
;;;558        EMAC->INTSTS = reg & 0xFFFFUL; /* Clear all Rx related interrupt status */
000012  b294              UXTH     r4,r2
000014  f8c740b0          STR      r4,[r7,#0xb0]
;;;559    
;;;560        if (reg & EMAC_INTSTS_RXBEIF_Msk)
000018  0512              LSLS     r2,r2,#20
00001a  d500              BPL      |L17.30|
                  |L17.28|
;;;561        {
;;;562            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;563            while(1) {}
00001c  e7fe              B        |L17.28|
                  |L17.30|
;;;564        }
;;;565        else
;;;566        {
;;;567    
;;;568            /* Get Rx Frame Descriptor */
;;;569            desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;
00001e  4a0e              LDR      r2,|L17.88|
;;;570    
;;;571            /* If we reach last recv Rx descriptor, leave the loop */
;;;572            if(EMAC->CRXDSA != (uint32_t)desc)
000020  68d4              LDR      r4,[r2,#0xc]  ; u32CurrentRxDesc
000022  f8d720d4          LDR      r2,[r7,#0xd4]
000026  42a2              CMP      r2,r4
000028  d012              BEQ      |L17.80|
;;;573            {
;;;574                if ((desc->u32Status1 | EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)   /* ownership=CPU */
00002a  6822              LDR      r2,[r4,#0]
00002c  0057              LSLS     r7,r2,#1
00002e  d00f              BEQ      |L17.80|
;;;575                {
;;;576    
;;;577                    status = desc->u32Status1 >> 16;
000030  0c17              LSRS     r7,r2,#16
;;;578    
;;;579                    /* If Rx frame is good, process received frame */
;;;580                    if(status & EMAC_RXFD_RXGD)
000032  06ff              LSLS     r7,r7,#27
000034  d50c              BPL      |L17.80|
;;;581                    {
;;;582                        /* lower 16 bit in descriptor status1 stores the Rx packet length */
;;;583                        *pu32Size = desc->u32Status1 & 0xFFFFUL;
000036  b292              UXTH     r2,r2
;;;584                        memcpy(pu8Data, (uint8_t *)desc->u32Backup1, *pu32Size);
000038  600a              STR      r2,[r1,#0]
00003a  4618              MOV      r0,r3
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f7fffffe          BL       __aeabi_memcpy
;;;585    
;;;586                        *pu32Sec = desc->u32Next; /* second stores in descriptor's NEXT field */
000042  68e0              LDR      r0,[r4,#0xc]
;;;587                        *pu32Nsec = EMAC_Subsec2Nsec(desc->u32Data); /* Sub nano second store in DATA field */
000044  6030              STR      r0,[r6,#0]
000046  6860              LDR      r0,[r4,#4]
000048  f7fffffe          BL       EMAC_Subsec2Nsec
;;;588    
;;;589                        u32Count = 1UL;
00004c  6028              STR      r0,[r5,#0]
00004e  2001              MOVS     r0,#1
                  |L17.80|
;;;590                    }
;;;591                    else
;;;592                    {
;;;593                        /* Save Error status if necessary */
;;;594                        if (status & EMAC_RXFD_RP) {}
;;;595                        if (status & EMAC_RXFD_ALIE) {}
;;;596                        if (status & EMAC_RXFD_PTLE) {}
;;;597                        if (status & EMAC_RXFD_CRCE) {}
;;;598                    }
;;;599                }
;;;600            }
;;;601        }
;;;602        return(u32Count);
;;;603    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;604    
                          ENDP

                  |L17.84|
                          DCD      0x4000b000
                  |L17.88|
                          DCD      ||.data||

                          AREA ||i.EMAC_RxDescInit||, CODE, READONLY, ALIGN=2

                  EMAC_RxDescInit PROC
;;;315      */
;;;316    static void EMAC_RxDescInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;317    {
;;;318    
;;;319        uint32_t i;
;;;320    
;;;321        /* Get Frame descriptor's base address. */
;;;322        EMAC->RXDSA = (uint32_t)&rx_desc[0];
000002  4816              LDR      r0,|L18.92|
000004  4a14              LDR      r2,|L18.88|
000006  f8c0208c          STR      r2,[r0,#0x8c]
;;;323        u32CurrentRxDesc = (uint32_t)&rx_desc[0];
00000a  4815              LDR      r0,|L18.96|
;;;324    
;;;325        for(i = 0UL; i < EMAC_RX_DESC_SIZE; i++)
00000c  2100              MOVS     r1,#0
00000e  460b              MOV      r3,r1
;;;326        {
;;;327            rx_desc[i].u32Status1 = EMAC_DESC_OWN_EMAC;
000010  f04f4400          MOV      r4,#0x80000000
;;;328            rx_desc[i].u32Data = (uint32_t)((uint32_t)&rx_buf[i]);
000014  f1020560          ADD      r5,r2,#0x60
000018  60c2              STR      r2,[r0,#0xc]  ; u32CurrentRxDesc
                  |L18.26|
00001a  eb010041          ADD      r0,r1,r1,LSL #1       ;327
00001e  f8424030          STR      r4,[r2,r0,LSL #3]     ;327
000022  ebc11641          RSB      r6,r1,r1,LSL #5
000026  eb061681          ADD      r6,r6,r1,LSL #6
00002a  eb0200c0          ADD      r0,r2,r0,LSL #3
00002e  eb051606          ADD      r6,r5,r6,LSL #4
000032  6046              STR      r6,[r0,#4]
;;;329            rx_desc[i].u32Backup1 = rx_desc[i].u32Data;
000034  6846              LDR      r6,[r0,#4]
000036  6106              STR      r6,[r0,#0x10]
;;;330            rx_desc[i].u32Status2 = 0UL;
000038  6083              STR      r3,[r0,#8]
;;;331            rx_desc[i].u32Next = (uint32_t)&rx_desc[(i + 1UL) % EMAC_RX_DESC_SIZE];
00003a  1c4e              ADDS     r6,r1,#1
00003c  f0060603          AND      r6,r6,#3
000040  eb060646          ADD      r6,r6,r6,LSL #1
000044  eb0206c6          ADD      r6,r2,r6,LSL #3
000048  60c6              STR      r6,[r0,#0xc]
;;;332            rx_desc[i].u32Backup2 = rx_desc[i].u32Next;
00004a  68c6              LDR      r6,[r0,#0xc]
00004c  6146              STR      r6,[r0,#0x14]
00004e  1c49              ADDS     r1,r1,#1
000050  2904              CMP      r1,#4                 ;325
000052  d3e2              BCC      |L18.26|
;;;333        }
;;;334    
;;;335    }
000054  bd70              POP      {r4-r6,pc}
;;;336    
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      ||.bss||
                  |L18.92|
                          DCD      0x4000b000
                  |L18.96|
                          DCD      ||.data||

                          AREA ||i.EMAC_SendPkt||, CODE, READONLY, ALIGN=2

                  EMAC_SendPkt PROC
;;;643      */
;;;644    uint32_t EMAC_SendPkt(uint8_t *pu8Data, uint32_t u32Size)
000000  b570              PUSH     {r4-r6,lr}
;;;645    {
;;;646        EMAC_DESCRIPTOR_T *desc;
;;;647        uint32_t status;
;;;648        uint32_t ret = 0UL;
;;;649        /* Get Tx frame descriptor & data pointer */
;;;650        desc = (EMAC_DESCRIPTOR_T *)u32NextTxDesc;
000002  4d0d              LDR      r5,|L19.56|
000004  460e              MOV      r6,r1                 ;645
000006  4603              MOV      r3,r0                 ;645
;;;651    
;;;652        status = desc->u32Status1;
000008  68ac              LDR      r4,[r5,#8]  ; u32NextTxDesc
00000a  2000              MOVS     r0,#0                 ;648
;;;653    
;;;654        /* Check descriptor ownership */
;;;655        if((status & EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)
00000c  6821              LDR      r1,[r4,#0]
00000e  2900              CMP      r1,#0
000010  db10              BLT      |L19.52|
;;;656        {
;;;657            memcpy((uint8_t *)desc->u32Data, pu8Data, u32Size);
000012  4632              MOV      r2,r6
000014  4619              MOV      r1,r3
000016  6860              LDR      r0,[r4,#4]
000018  f7fffffe          BL       __aeabi_memcpy
;;;658    
;;;659            /* Set Tx descriptor transmit byte count */
;;;660            desc->u32Status2 = u32Size;
;;;661    
;;;662            /* Change descriptor ownership to EMAC */
;;;663            desc->u32Status1 |= EMAC_DESC_OWN_EMAC;
00001c  60a6              STR      r6,[r4,#8]
00001e  6820              LDR      r0,[r4,#0]
;;;664    
;;;665            /* Get next Tx descriptor */
;;;666            u32NextTxDesc = (uint32_t)(desc->u32Next);
;;;667    
;;;668            /* Trigger EMAC to send the packet */
;;;669            EMAC_TRIGGER_TX();
000020  4906              LDR      r1,|L19.60|
000022  f0404000          ORR      r0,r0,#0x80000000     ;663
000026  6020              STR      r0,[r4,#0]            ;666
000028  68e0              LDR      r0,[r4,#0xc]          ;666
00002a  60a8              STR      r0,[r5,#8]  ; u32NextTxDesc
00002c  2000              MOVS     r0,#0
00002e  f8c100a0          STR      r0,[r1,#0xa0]
;;;670            ret = 1UL;
000032  2001              MOVS     r0,#1
                  |L19.52|
;;;671        }
;;;672        return(ret);
;;;673    }
000034  bd70              POP      {r4-r6,pc}
;;;674    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      ||.data||
                  |L19.60|
                          DCD      0x4000b000

                          AREA ||i.EMAC_SendPktDone||, CODE, READONLY, ALIGN=2

                  EMAC_SendPktDone PROC
;;;682      */
;;;683    uint32_t EMAC_SendPktDone(void)
000000  4a10              LDR      r2,|L20.68|
;;;684    {
000002  b510              PUSH     {r4,lr}
;;;685        EMAC_DESCRIPTOR_T *desc;
;;;686        uint32_t status, reg;
;;;687        uint32_t last_tx_desc;
;;;688        uint32_t u32Count = 0UL;
;;;689    
;;;690        reg = EMAC->INTSTS;
000004  f8d210b0          LDR      r1,[r2,#0xb0]
000008  2000              MOVS     r0,#0                 ;688
;;;691        /* Clear Tx interrupt flags */
;;;692        EMAC->INTSTS = reg & (0xFFFF0000UL & ~EMAC_INTSTS_TSALMIF_Msk);
00000a  4b0f              LDR      r3,|L20.72|
00000c  400b              ANDS     r3,r3,r1
00000e  f8c230b0          STR      r3,[r2,#0xb0]
;;;693    
;;;694    
;;;695        if (reg & EMAC_INTSTS_TXBEIF_Msk)
000012  01c9              LSLS     r1,r1,#7
000014  d500              BPL      |L20.24|
                  |L20.22|
;;;696        {
;;;697            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;698            while(1) {}
000016  e7fe              B        |L20.22|
                  |L20.24|
;;;699        }
;;;700        else
;;;701        {
;;;702            /* Process the descriptor(s). */
;;;703            last_tx_desc = EMAC->CTXDSA ;
000018  f8d230cc          LDR      r3,[r2,#0xcc]
;;;704            /* Get our first descriptor to process */
;;;705            desc = (EMAC_DESCRIPTOR_T *) u32CurrentTxDesc;
00001c  4c0b              LDR      r4,|L20.76|
00001e  6861              LDR      r1,[r4,#4]  ; u32CurrentTxDesc
                  |L20.32|
;;;706            do
;;;707            {
;;;708                /* Descriptor ownership is still EMAC, so this packet haven't been send. */
;;;709                if(desc->u32Status1 & EMAC_DESC_OWN_EMAC)
000020  680a              LDR      r2,[r1,#0]
000022  2a00              CMP      r2,#0
000024  db0b              BLT      |L20.62|
;;;710                {
;;;711                    break;
;;;712                }
;;;713                /* Get Tx status stored in descriptor */
;;;714                status = desc->u32Status2 >> 16UL;
000026  688a              LDR      r2,[r1,#8]
000028  0c12              LSRS     r2,r2,#16
;;;715                if (status & EMAC_TXFD_TXCP)
00002a  0712              LSLS     r2,r2,#28
00002c  d500              BPL      |L20.48|
00002e  1c40              ADDS     r0,r0,#1
                  |L20.48|
;;;716                {
;;;717                    u32Count++;
;;;718                }
;;;719                else
;;;720                {
;;;721                    /* Do nothing here on error. */
;;;722                    if (status & EMAC_TXFD_TXABT) {}
;;;723                    if (status & EMAC_TXFD_DEF) {}
;;;724                    if (status & EMAC_TXFD_PAU) {}
;;;725                    if (status & EMAC_TXFD_EXDEF) {}
;;;726                    if (status & EMAC_TXFD_NCS) {}
;;;727                    if (status & EMAC_TXFD_SQE) {}
;;;728                    if (status & EMAC_TXFD_LC) {}
;;;729                    if (status & EMAC_TXFD_TXHA) {}
;;;730                }
;;;731    
;;;732                /* restore descriptor link list and data pointer they will be overwrite if time stamp enabled */
;;;733                desc->u32Data = desc->u32Backup1;
000030  690a              LDR      r2,[r1,#0x10]
;;;734                desc->u32Next = desc->u32Backup2;
000032  604a              STR      r2,[r1,#4]
000034  694a              LDR      r2,[r1,#0x14]
;;;735                /* go to next descriptor in link */
;;;736                desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
000036  60ca              STR      r2,[r1,#0xc]
000038  4611              MOV      r1,r2
;;;737            }
;;;738            while (last_tx_desc != (uint32_t)desc);      /* If we reach last sent Tx descriptor, leave the loop */
00003a  428b              CMP      r3,r1
00003c  d1f0              BNE      |L20.32|
                  |L20.62|
;;;739            /* Save last processed Tx descriptor */
;;;740            u32CurrentTxDesc = (uint32_t)desc;
00003e  6061              STR      r1,[r4,#4]  ; u32CurrentTxDesc
;;;741        }
;;;742        return(u32Count);
;;;743    }
000040  bd10              POP      {r4,pc}
;;;744    
                          ENDP

000042  0000              DCW      0x0000
                  |L20.68|
                          DCD      0x4000b000
                  |L20.72|
                          DCD      0xefff0000
                  |L20.76|
                          DCD      ||.data||

                          AREA ||i.EMAC_SendPktDoneTS||, CODE, READONLY, ALIGN=2

                  EMAC_SendPktDoneTS PROC
;;;754      */
;;;755    uint32_t EMAC_SendPktDoneTS(uint32_t *pu32Sec, uint32_t *pu32Nsec)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;756    {
000004  460e              MOV      r6,r1
000006  4601              MOV      r1,r0
;;;757    
;;;758        EMAC_DESCRIPTOR_T *desc;
;;;759        uint32_t status, reg;
;;;760        uint32_t u32Count = 0UL;
;;;761    
;;;762        reg = EMAC->INTSTS;
000008  4810              LDR      r0,|L21.76|
00000a  2500              MOVS     r5,#0                 ;760
00000c  f8502fb0          LDR      r2,[r0,#0xb0]!
;;;763        /* Clear Tx interrupt flags */
;;;764        EMAC->INTSTS = reg & (0xFFFF0000UL & ~EMAC_INTSTS_TSALMIF_Msk);
000010  4b0f              LDR      r3,|L21.80|
000012  4013              ANDS     r3,r3,r2
000014  6003              STR      r3,[r0,#0]
;;;765    
;;;766    
;;;767        if (reg & EMAC_INTSTS_TXBEIF_Msk)
000016  01d0              LSLS     r0,r2,#7
000018  d500              BPL      |L21.28|
                  |L21.26|
;;;768        {
;;;769            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;770            while(1) {}
00001a  e7fe              B        |L21.26|
                  |L21.28|
;;;771        }
;;;772        else
;;;773        {
;;;774            /* Process the descriptor.
;;;775               Get our first descriptor to process */
;;;776            desc = (EMAC_DESCRIPTOR_T *) u32CurrentTxDesc;
00001c  4f0d              LDR      r7,|L21.84|
;;;777    
;;;778            /* Descriptor ownership is still EMAC, so this packet haven't been send. */
;;;779            if((desc->u32Status1 & EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)
00001e  687c              LDR      r4,[r7,#4]  ; u32CurrentTxDesc
000020  6820              LDR      r0,[r4,#0]
000022  2800              CMP      r0,#0
000024  db0f              BLT      |L21.70|
;;;780            {
;;;781                /* Get Tx status stored in descriptor */
;;;782                status = desc->u32Status2 >> 16UL;
000026  68a0              LDR      r0,[r4,#8]
000028  0c00              LSRS     r0,r0,#16
;;;783                if (status & EMAC_TXFD_TXCP)
00002a  0700              LSLS     r0,r0,#28
00002c  d506              BPL      |L21.60|
;;;784                {
;;;785                    u32Count = 1UL;
;;;786                    *pu32Sec = desc->u32Next; /* second stores in descriptor's NEXT field */
00002e  68e0              LDR      r0,[r4,#0xc]
;;;787                    *pu32Nsec = EMAC_Subsec2Nsec(desc->u32Data); /* Sub nano second store in DATA field */
000030  6008              STR      r0,[r1,#0]
000032  2501              MOVS     r5,#1                 ;785
000034  6860              LDR      r0,[r4,#4]
000036  f7fffffe          BL       EMAC_Subsec2Nsec
00003a  6030              STR      r0,[r6,#0]
                  |L21.60|
;;;788                }
;;;789                else
;;;790                {
;;;791                    /* Do nothing here on error. */
;;;792                    if (status & EMAC_TXFD_TXABT) {}
;;;793                    if (status & EMAC_TXFD_DEF) {}
;;;794                    if (status & EMAC_TXFD_PAU) {}
;;;795                    if (status & EMAC_TXFD_EXDEF) {}
;;;796                    if (status & EMAC_TXFD_NCS) {}
;;;797                    if (status & EMAC_TXFD_SQE) {}
;;;798                    if (status & EMAC_TXFD_LC) {}
;;;799                    if (status & EMAC_TXFD_TXHA) {}
;;;800                }
;;;801    
;;;802                /* restore descriptor link list and data pointer they will be overwrite if time stamp enabled */
;;;803                desc->u32Data = desc->u32Backup1;
00003c  6920              LDR      r0,[r4,#0x10]
;;;804                desc->u32Next = desc->u32Backup2;
00003e  6060              STR      r0,[r4,#4]
000040  6960              LDR      r0,[r4,#0x14]
;;;805                /* go to next descriptor in link */
;;;806                desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
;;;807    
;;;808                /* Save last processed Tx descriptor */
;;;809                u32CurrentTxDesc = (uint32_t)desc;
000042  60e0              STR      r0,[r4,#0xc]
000044  6078              STR      r0,[r7,#4]  ; u32CurrentTxDesc
                  |L21.70|
;;;810            }
;;;811        }
;;;812    
;;;813        return(u32Count);
000046  4628              MOV      r0,r5
;;;814    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;815    
                          ENDP

                  |L21.76|
                          DCD      0x4000b000
                  |L21.80|
                          DCD      0xefff0000
                  |L21.84|
                          DCD      ||.data||

                          AREA ||i.EMAC_SetMacAddr||, CODE, READONLY, ALIGN=1

                  EMAC_SetMacAddr PROC
;;;437      */
;;;438    void EMAC_SetMacAddr(uint8_t *pu8MacAddr)
000000  4601              MOV      r1,r0
;;;439    {
;;;440        EMAC_EnableCamEntry(0UL, pu8MacAddr);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      EMAC_EnableCamEntry
;;;441    
;;;442    }
;;;443    
                          ENDP


                          AREA ||i.EMAC_SetTime||, CODE, READONLY, ALIGN=2

                  EMAC_SetTime PROC
;;;873      */
;;;874    void EMAC_SetTime(uint32_t u32Sec, uint32_t u32Nsec)
000000  b510              PUSH     {r4,lr}
;;;875    {
;;;876        /* Disable time stamp counter before update time value (clear EMAC_TSCTL_TSIEN_Msk) */
;;;877        EMAC->TSCTL = EMAC_TSCTL_TSEN_Msk;
000002  4c08              LDR      r4,|L23.36|
000004  2201              MOVS     r2,#1
000006  f8c42100          STR      r2,[r4,#0x100]
;;;878        EMAC->UPDSEC = u32Sec;
00000a  f8c40120          STR      r0,[r4,#0x120]
;;;879        EMAC->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
00000e  4608              MOV      r0,r1
000010  f5047480          ADD      r4,r4,#0x100
000014  f7fffffe          BL       EMAC_Nsec2Subsec
000018  6260              STR      r0,[r4,#0x24]
;;;880        EMAC->TSCTL |= (EMAC_TSCTL_TSIEN_Msk | EMAC_TSCTL_TSMODE_Msk);
00001a  6820              LDR      r0,[r4,#0]
00001c  f0400006          ORR      r0,r0,#6
000020  6020              STR      r0,[r4,#0]
;;;881    
;;;882    }
000022  bd10              POP      {r4,pc}
;;;883    
                          ENDP

                  |L23.36|
                          DCD      0x4000b000

                          AREA ||i.EMAC_Subsec2Nsec||, CODE, READONLY, ALIGN=2

                  EMAC_Subsec2Nsec PROC
;;;341      */
;;;342    static uint32_t EMAC_Subsec2Nsec(uint32_t subsec)
000000  4903              LDR      r1,|L24.16|
;;;343    {
;;;344        /* 2^31 subsec == 10^9 ns */
;;;345        uint64_t i;
;;;346        i = 1000000000ull * (uint64_t)subsec;
000002  fba00101          UMULL    r0,r1,r0,r1
;;;347        i >>= 31;
000006  0fc0              LSRS     r0,r0,#31
000008  ea400041          ORR      r0,r0,r1,LSL #1
;;;348        return((uint32_t)i);
;;;349    }
00000c  4770              BX       lr
;;;350    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x3b9aca00

                          AREA ||i.EMAC_TxDescInit||, CODE, READONLY, ALIGN=2

                  EMAC_TxDescInit PROC
;;;280      */
;;;281    static void EMAC_TxDescInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;282    {
;;;283        uint32_t i;
;;;284    
;;;285        /* Get Frame descriptor's base address. */
;;;286        EMAC->TXDSA = (uint32_t)&tx_desc[0];
000002  4819              LDR      r0,|L25.104|
000004  4a17              LDR      r2,|L25.100|
000006  f8c02088          STR      r2,[r0,#0x88]
;;;287        u32NextTxDesc = u32CurrentTxDesc = (uint32_t)&tx_desc[0];
00000a  4918              LDR      r1,|L25.108|
;;;288    
;;;289        for(i = 0UL; i < EMAC_TX_DESC_SIZE; i++)
00000c  2000              MOVS     r0,#0
;;;290        {
;;;291    
;;;292            if(s_u32EnableTs)
00000e  4604              MOV      r4,r0
000010  604a              STR      r2,[r1,#4]            ;287  ; u32CurrentTxDesc
000012  608a              STR      r2,[r1,#8]  ; u32NextTxDesc
;;;293            {
;;;294                tx_desc[i].u32Status1 = EMAC_TXFD_PADEN | EMAC_TXFD_CRCAPP | EMAC_TXFD_INTEN;
;;;295            }
;;;296            else
;;;297            {
;;;298                tx_desc[i].u32Status1 = EMAC_TXFD_PADEN | EMAC_TXFD_CRCAPP | EMAC_TXFD_INTEN | EMAC_TXFD_TTSEN;
;;;299            }
;;;300            tx_desc[i].u32Data = (uint32_t)((uint32_t)&tx_buf[i]);
000014  680b              LDR      r3,[r1,#0]
000016  f1020560          ADD      r5,r2,#0x60
                  |L25.26|
00001a  b10b              CBZ      r3,|L25.32|
00001c  2107              MOVS     r1,#7                 ;294
00001e  e000              B        |L25.34|
                  |L25.32|
000020  210f              MOVS     r1,#0xf               ;298
                  |L25.34|
000022  eb000640          ADD      r6,r0,r0,LSL #1       ;298
000026  f8421036          STR      r1,[r2,r6,LSL #3]     ;298
00002a  ebc01140          RSB      r1,r0,r0,LSL #5
00002e  eb011180          ADD      r1,r1,r0,LSL #6
000032  eb051601          ADD      r6,r5,r1,LSL #4
000036  eb000140          ADD      r1,r0,r0,LSL #1
00003a  eb0201c1          ADD      r1,r2,r1,LSL #3
00003e  604e              STR      r6,[r1,#4]
;;;301            tx_desc[i].u32Backup1 = tx_desc[i].u32Data;
000040  684e              LDR      r6,[r1,#4]
000042  610e              STR      r6,[r1,#0x10]
;;;302            tx_desc[i].u32Status2 = 0UL;
000044  608c              STR      r4,[r1,#8]
;;;303            tx_desc[i].u32Next = (uint32_t)&tx_desc[(i + 1UL) % EMAC_TX_DESC_SIZE];
000046  1c46              ADDS     r6,r0,#1
000048  f0060603          AND      r6,r6,#3
00004c  eb060646          ADD      r6,r6,r6,LSL #1
000050  eb0206c6          ADD      r6,r2,r6,LSL #3
000054  60ce              STR      r6,[r1,#0xc]
;;;304            tx_desc[i].u32Backup2 = tx_desc[i].u32Next;
000056  68ce              LDR      r6,[r1,#0xc]
000058  614e              STR      r6,[r1,#0x14]
00005a  1c40              ADDS     r0,r0,#1
00005c  2804              CMP      r0,#4                 ;289
00005e  d3dc              BCC      |L25.26|
;;;305    
;;;306        }
;;;307    
;;;308    }
000060  bd70              POP      {r4-r6,pc}
;;;309    
                          ENDP

000062  0000              DCW      0x0000
                  |L25.100|
                          DCD      ||.bss||+0x1820
                  |L25.104|
                          DCD      0x4000b000
                  |L25.108|
                          DCD      ||.data||

                          AREA ||i.EMAC_UpdateTime||, CODE, READONLY, ALIGN=2

                  EMAC_UpdateTime PROC
;;;917      */
;;;918    void EMAC_UpdateTime(uint32_t u32Neg, uint32_t u32Sec, uint32_t u32Nsec)
000000  b570              PUSH     {r4-r6,lr}
;;;919    {
;;;920        EMAC->UPDSEC = u32Sec;
000002  4c0b              LDR      r4,|L26.48|
000004  4605              MOV      r5,r0                 ;919
000006  f8c41120          STR      r1,[r4,#0x120]
;;;921        EMAC->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       EMAC_Nsec2Subsec
000010  f8c40124          STR      r0,[r4,#0x124]
;;;922        if(u32Neg)
000014  b12d              CBZ      r5,|L26.34|
;;;923        {
;;;924            EMAC->UPDSUBSEC |= BIT31;   /* Set bit 31 indicates this is a negative value */
000016  f8d40124          LDR      r0,[r4,#0x124]
00001a  f0404000          ORR      r0,r0,#0x80000000
00001e  f8c40124          STR      r0,[r4,#0x124]
                  |L26.34|
;;;925        }
;;;926        EMAC->TSCTL |= EMAC_TSCTL_TSUPDATE_Msk;
000022  f8d40100          LDR      r0,[r4,#0x100]
000026  f0400008          ORR      r0,r0,#8
00002a  f8c40100          STR      r0,[r4,#0x100]
;;;927    
;;;928    }
00002e  bd70              POP      {r4-r6,pc}
;;;929    
                          ENDP

                  |L26.48|
                          DCD      0x4000b000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rx_desc
                          %        96
                  rx_buf
                          %        6080
                  tx_desc
                          %        96
                  tx_buf
                          %        6080

                          AREA ||.data||, DATA, ALIGN=2

                  s_u32EnableTs
                          DCD      0x00000000
                  u32CurrentTxDesc
                          DCD      0x00000000
                  u32NextTxDesc
                          DCD      0x00000000
                  u32CurrentRxDesc
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\emac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_emac_c_34612849____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_emac_c_34612849____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_emac_c_34612849____REVSH|
#line 402
|__asm___6_emac_c_34612849____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_emac_c_34612849____RRX|
#line 587
|__asm___6_emac_c_34612849____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
