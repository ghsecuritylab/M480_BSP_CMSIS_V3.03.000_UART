; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\qspi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\qspi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\qspi.crf ..\..\..\Library\StdDriver\src\qspi.c]
                          THUMB

                          AREA ||i.QSPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  QSPI_ClearIntFlag PROC
;;;630      */
;;;631    void QSPI_ClearIntFlag(QSPI_T *qspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;632    {
000002  d001              BEQ      |L1.8|
;;;633        if(u32Mask & QSPI_UNIT_INT_MASK)
;;;634        {
;;;635            qspi->STATUS = QSPI_STATUS_UNITIF_Msk; /* Clear unit transfer interrupt flag */
000004  2202              MOVS     r2,#2
000006  6142              STR      r2,[r0,#0x14]
                  |L1.8|
;;;636        }
;;;637    
;;;638        if(u32Mask & QSPI_SSACT_INT_MASK)
000008  078a              LSLS     r2,r1,#30
00000a  d501              BPL      |L1.16|
;;;639        {
;;;640            qspi->STATUS = QSPI_STATUS_SSACTIF_Msk; /* Clear slave selection signal active interrupt flag */
00000c  2204              MOVS     r2,#4
00000e  6142              STR      r2,[r0,#0x14]
                  |L1.16|
;;;641        }
;;;642    
;;;643        if(u32Mask & QSPI_SSINACT_INT_MASK)
000010  074a              LSLS     r2,r1,#29
000012  d501              BPL      |L1.24|
;;;644        {
;;;645            qspi->STATUS = QSPI_STATUS_SSINAIF_Msk; /* Clear slave selection signal inactive interrupt flag */
000014  2208              MOVS     r2,#8
000016  6142              STR      r2,[r0,#0x14]
                  |L1.24|
;;;646        }
;;;647    
;;;648        if(u32Mask & QSPI_SLVUR_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d501              BPL      |L1.32|
;;;649        {
;;;650            qspi->STATUS = QSPI_STATUS_SLVURIF_Msk; /* Clear slave TX under run interrupt flag */
00001c  2280              MOVS     r2,#0x80
00001e  6142              STR      r2,[r0,#0x14]
                  |L1.32|
;;;651        }
;;;652    
;;;653        if(u32Mask & QSPI_SLVBE_INT_MASK)
000020  06ca              LSLS     r2,r1,#27
000022  d501              BPL      |L1.40|
;;;654        {
;;;655            qspi->STATUS = QSPI_STATUS_SLVBEIF_Msk; /* Clear slave bit count error interrupt flag */
000024  2240              MOVS     r2,#0x40
000026  6142              STR      r2,[r0,#0x14]
                  |L1.40|
;;;656        }
;;;657    
;;;658        if(u32Mask & QSPI_TXUF_INT_MASK)
000028  064a              LSLS     r2,r1,#25
00002a  d502              BPL      |L1.50|
;;;659        {
;;;660            qspi->STATUS = QSPI_STATUS_TXUFIF_Msk; /* Clear slave TX underflow interrupt flag */
00002c  f44f2200          MOV      r2,#0x80000
000030  6142              STR      r2,[r0,#0x14]
                  |L1.50|
;;;661        }
;;;662    
;;;663        if(u32Mask & QSPI_FIFO_RXOV_INT_MASK)
000032  058a              LSLS     r2,r1,#22
000034  d502              BPL      |L1.60|
;;;664        {
;;;665            qspi->STATUS = QSPI_STATUS_RXOVIF_Msk; /* Clear RX overrun interrupt flag */
000036  f44f6200          MOV      r2,#0x800
00003a  6142              STR      r2,[r0,#0x14]
                  |L1.60|
;;;666        }
;;;667    
;;;668        if(u32Mask & QSPI_FIFO_RXTO_INT_MASK)
00003c  0549              LSLS     r1,r1,#21
00003e  d502              BPL      |L1.70|
;;;669        {
;;;670            qspi->STATUS = QSPI_STATUS_RXTOIF_Msk; /* Clear RX time-out interrupt flag */
000040  f44f5180          MOV      r1,#0x1000
000044  6141              STR      r1,[r0,#0x14]
                  |L1.70|
;;;671        }
;;;672    }
000046  4770              BX       lr
;;;673    
                          ENDP


                          AREA ||i.QSPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  QSPI_ClearRxFIFO PROC
;;;168      */
;;;169    void QSPI_ClearRxFIFO(QSPI_T *qspi)
000000  6901              LDR      r1,[r0,#0x10]
;;;170    {
;;;171        qspi->FIFOCTL |= QSPI_FIFOCTL_RXFBCLR_Msk;
000002  f4417180          ORR      r1,r1,#0x100
000006  6101              STR      r1,[r0,#0x10]
;;;172    }
000008  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.QSPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  QSPI_ClearTxFIFO PROC
;;;180      */
;;;181    void QSPI_ClearTxFIFO(QSPI_T *qspi)
000000  6901              LDR      r1,[r0,#0x10]
;;;182    {
;;;183        qspi->FIFOCTL |= QSPI_FIFOCTL_TXFBCLR_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;184    }
000008  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.QSPI_Close||, CODE, READONLY, ALIGN=1

                  QSPI_Close PROC
;;;155      */
;;;156    void QSPI_Close(QSPI_T *qspi)
000000  f04f4080          MOV      r0,#0x40000000
;;;157    {
;;;158        /* Reset QSPI */
;;;159        SYS->IPRST1 |= SYS_IPRST1_QSPI0RST_Msk;
000004  68c1              LDR      r1,[r0,#0xc]
000006  f4415180          ORR      r1,r1,#0x1000
00000a  60c1              STR      r1,[r0,#0xc]
;;;160        SYS->IPRST1 &= ~SYS_IPRST1_QSPI0RST_Msk;
00000c  68c1              LDR      r1,[r0,#0xc]
00000e  f4215180          BIC      r1,r1,#0x1000
000012  60c1              STR      r1,[r0,#0xc]
;;;161    }
000014  4770              BX       lr
;;;162    
                          ENDP


                          AREA ||i.QSPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  QSPI_DisableAutoSS PROC
;;;191      */
;;;192    void QSPI_DisableAutoSS(QSPI_T *qspi)
000000  6881              LDR      r1,[r0,#8]
;;;193    {
;;;194        qspi->SSCTL &= ~(QSPI_SSCTL_AUTOSS_Msk | QSPI_SSCTL_SS_Msk);
000002  f0210109          BIC      r1,r1,#9
000006  6081              STR      r1,[r0,#8]
;;;195    }
000008  4770              BX       lr
;;;196    
                          ENDP


                          AREA ||i.QSPI_DisableInt||, CODE, READONLY, ALIGN=1

                  QSPI_DisableInt PROC
;;;452      */
;;;453    void QSPI_DisableInt(QSPI_T *qspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;454    {
000002  d003              BEQ      |L6.12|
;;;455        /* Disable unit transfer interrupt flag */
;;;456        if((u32Mask & QSPI_UNIT_INT_MASK) == QSPI_UNIT_INT_MASK)
;;;457        {
;;;458            qspi->CTL &= ~QSPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4223200          BIC      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L6.12|
;;;459        }
;;;460    
;;;461        /* Disable slave selection signal active interrupt flag */
;;;462        if((u32Mask & QSPI_SSACT_INT_MASK) == QSPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L6.24|
;;;463        {
;;;464            qspi->SSCTL &= ~QSPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4225280          BIC      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L6.24|
;;;465        }
;;;466    
;;;467        /* Disable slave selection signal inactive interrupt flag */
;;;468        if((u32Mask & QSPI_SSINACT_INT_MASK) == QSPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L6.36|
;;;469        {
;;;470            qspi->SSCTL &= ~QSPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4225200          BIC      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L6.36|
;;;471        }
;;;472    
;;;473        /* Disable slave TX under run interrupt flag */
;;;474        if((u32Mask & QSPI_SLVUR_INT_MASK) == QSPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L6.48|
;;;475        {
;;;476            qspi->SSCTL &= ~QSPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4227200          BIC      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L6.48|
;;;477        }
;;;478    
;;;479        /* Disable slave bit count error interrupt flag */
;;;480        if((u32Mask & QSPI_SLVBE_INT_MASK) == QSPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L6.60|
;;;481        {
;;;482            qspi->SSCTL &= ~QSPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4227280          BIC      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L6.60|
;;;483        }
;;;484    
;;;485        /* Disable slave TX underflow interrupt flag */
;;;486        if((u32Mask & QSPI_TXUF_INT_MASK) == QSPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L6.72|
;;;487        {
;;;488            qspi->FIFOCTL &= ~QSPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0220280          BIC      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L6.72|
;;;489        }
;;;490    
;;;491        /* Disable TX threshold interrupt flag */
;;;492        if((u32Mask & QSPI_FIFO_TXTH_INT_MASK) == QSPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L6.84|
;;;493        {
;;;494            qspi->FIFOCTL &= ~QSPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0220208          BIC      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L6.84|
;;;495        }
;;;496    
;;;497        /* Disable RX threshold interrupt flag */
;;;498        if((u32Mask & QSPI_FIFO_RXTH_INT_MASK) == QSPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L6.96|
;;;499        {
;;;500            qspi->FIFOCTL &= ~QSPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0220204          BIC      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L6.96|
;;;501        }
;;;502    
;;;503        /* Disable RX overrun interrupt flag */
;;;504        if((u32Mask & QSPI_FIFO_RXOV_INT_MASK) == QSPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L6.108|
;;;505        {
;;;506            qspi->FIFOCTL &= ~QSPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0220220          BIC      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L6.108|
;;;507        }
;;;508    
;;;509        /* Disable RX time-out interrupt flag */
;;;510        if((u32Mask & QSPI_FIFO_RXTO_INT_MASK) == QSPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L6.120|
;;;511        {
;;;512            qspi->FIFOCTL &= ~QSPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0210110          BIC      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L6.120|
;;;513        }
;;;514    }
000078  4770              BX       lr
;;;515    
                          ENDP


                          AREA ||i.QSPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  QSPI_EnableAutoSS PROC
;;;205      */
;;;206    void QSPI_EnableAutoSS(QSPI_T *qspi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6883              LDR      r3,[r0,#8]
;;;207    {
;;;208        qspi->SSCTL = (qspi->SSCTL & (~(QSPI_SSCTL_AUTOSS_Msk | QSPI_SSCTL_SSACTPOL_Msk | QSPI_SSCTL_SS_Msk))) | (u32SSPinMask | u32ActiveLevel | QSPI_SSCTL_AUTOSS_Msk);
000002  4311              ORRS     r1,r1,r2
000004  f023030d          BIC      r3,r3,#0xd
000008  430b              ORRS     r3,r3,r1
00000a  f0430108          ORR      r1,r3,#8
00000e  6081              STR      r1,[r0,#8]
;;;209    }
000010  4770              BX       lr
;;;210    
                          ENDP


                          AREA ||i.QSPI_EnableInt||, CODE, READONLY, ALIGN=1

                  QSPI_EnableInt PROC
;;;369      */
;;;370    void QSPI_EnableInt(QSPI_T *qspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;371    {
000002  d003              BEQ      |L8.12|
;;;372        /* Enable unit transfer interrupt flag */
;;;373        if((u32Mask & QSPI_UNIT_INT_MASK) == QSPI_UNIT_INT_MASK)
;;;374        {
;;;375            qspi->CTL |= QSPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4423200          ORR      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L8.12|
;;;376        }
;;;377    
;;;378        /* Enable slave selection signal active interrupt flag */
;;;379        if((u32Mask & QSPI_SSACT_INT_MASK) == QSPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L8.24|
;;;380        {
;;;381            qspi->SSCTL |= QSPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4425280          ORR      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L8.24|
;;;382        }
;;;383    
;;;384        /* Enable slave selection signal inactive interrupt flag */
;;;385        if((u32Mask & QSPI_SSINACT_INT_MASK) == QSPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L8.36|
;;;386        {
;;;387            qspi->SSCTL |= QSPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4425200          ORR      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L8.36|
;;;388        }
;;;389    
;;;390        /* Enable slave TX under run interrupt flag */
;;;391        if((u32Mask & QSPI_SLVUR_INT_MASK) == QSPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L8.48|
;;;392        {
;;;393            qspi->SSCTL |= QSPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4427200          ORR      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L8.48|
;;;394        }
;;;395    
;;;396        /* Enable slave bit count error interrupt flag */
;;;397        if((u32Mask & QSPI_SLVBE_INT_MASK) == QSPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L8.60|
;;;398        {
;;;399            qspi->SSCTL |= QSPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4427280          ORR      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L8.60|
;;;400        }
;;;401    
;;;402        /* Enable slave TX underflow interrupt flag */
;;;403        if((u32Mask & QSPI_TXUF_INT_MASK) == QSPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L8.72|
;;;404        {
;;;405            qspi->FIFOCTL |= QSPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0420280          ORR      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L8.72|
;;;406        }
;;;407    
;;;408        /* Enable TX threshold interrupt flag */
;;;409        if((u32Mask & QSPI_FIFO_TXTH_INT_MASK) == QSPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L8.84|
;;;410        {
;;;411            qspi->FIFOCTL |= QSPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0420208          ORR      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L8.84|
;;;412        }
;;;413    
;;;414        /* Enable RX threshold interrupt flag */
;;;415        if((u32Mask & QSPI_FIFO_RXTH_INT_MASK) == QSPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L8.96|
;;;416        {
;;;417            qspi->FIFOCTL |= QSPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0420204          ORR      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L8.96|
;;;418        }
;;;419    
;;;420        /* Enable RX overrun interrupt flag */
;;;421        if((u32Mask & QSPI_FIFO_RXOV_INT_MASK) == QSPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L8.108|
;;;422        {
;;;423            qspi->FIFOCTL |= QSPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0420220          ORR      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L8.108|
;;;424        }
;;;425    
;;;426        /* Enable RX time-out interrupt flag */
;;;427        if((u32Mask & QSPI_FIFO_RXTO_INT_MASK) == QSPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L8.120|
;;;428        {
;;;429            qspi->FIFOCTL |= QSPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0410110          ORR      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L8.120|
;;;430        }
;;;431    }
000078  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.QSPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  QSPI_GetBusClock PROC
;;;318      */
;;;319    uint32_t QSPI_GetBusClock(QSPI_T *qspi)
000000  b510              PUSH     {r4,lr}
;;;320    {
;;;321        uint32_t u32Div;
;;;322        uint32_t u32ClkSrc;
;;;323    
;;;324        /* Get DIVIDER setting */
;;;325        u32Div = (qspi->CLKDIV & QSPI_CLKDIV_DIVIDER_Msk) >> QSPI_CLKDIV_DIVIDER_Pos;
000002  6840              LDR      r0,[r0,#4]
;;;326    
;;;327        /* Check clock source of QSPI */
;;;328        if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_HXT)
000004  f04f4180          MOV      r1,#0x40000000
000008  f3c00408          UBFX     r4,r0,#0,#9           ;325
00000c  f8d10218          LDR      r0,[r1,#0x218]
000010  f0100f0c          TST      r0,#0xc
;;;329        {
;;;330            u32ClkSrc = __HXT; /* Clock source is HXT */
000014  480b              LDR      r0,|L9.68|
000016  d011              BEQ      |L9.60|
;;;331        }
;;;332        else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PLL)
000018  f8d12218          LDR      r2,[r1,#0x218]
00001c  f3c20281          UBFX     r2,r2,#2,#2
000020  2a01              CMP      r2,#1
000022  d006              BEQ      |L9.50|
;;;333        {
;;;334            u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;335        }
;;;336        else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PCLK0)
000024  f8d11218          LDR      r1,[r1,#0x218]
000028  f3c10181          UBFX     r1,r1,#2,#2
00002c  2902              CMP      r1,#2
00002e  d003              BEQ      |L9.56|
000030  e004              B        |L9.60|
                  |L9.50|
000032  f7fffffe          BL       CLK_GetPLLClockFreq
000036  e001              B        |L9.60|
                  |L9.56|
;;;337        {
;;;338            /* Clock source is PCLK0 */
;;;339            u32ClkSrc = CLK_GetPCLK0Freq();
000038  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.60|
00003c  1c64              ADDS     r4,r4,#1
;;;340        }
;;;341        else
;;;342        {
;;;343            u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;344        }
;;;345    
;;;346        /* Return QSPI bus clock rate */
;;;347        return (u32ClkSrc / (u32Div + 1U));
00003e  fbb0f0f4          UDIV     r0,r0,r4
;;;348    }
000042  bd10              POP      {r4,pc}
;;;349    
                          ENDP

                  |L9.68|
                          DCD      0x00b71b00

                          AREA ||i.QSPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  QSPI_GetIntFlag PROC
;;;535      */
;;;536    uint32_t QSPI_GetIntFlag(QSPI_T *qspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;537    {
000002  4602              MOV      r2,r0
;;;538        uint32_t u32IntFlag = 0U, u32TmpVal;
000004  2000              MOVS     r0,#0
;;;539    
;;;540        u32TmpVal = qspi->STATUS & QSPI_STATUS_UNITIF_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;541        /* Check unit transfer interrupt flag */
;;;542        if((u32Mask & QSPI_UNIT_INT_MASK) && (u32TmpVal))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030302          AND      r3,r3,#2              ;540
00000e  d001              BEQ      |L10.20|
000010  b103              CBZ      r3,|L10.20|
;;;543        {
;;;544            u32IntFlag |= QSPI_UNIT_INT_MASK;
000012  2001              MOVS     r0,#1
                  |L10.20|
;;;545        }
;;;546    
;;;547        u32TmpVal = qspi->STATUS & QSPI_STATUS_SSACTIF_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;548        /* Check slave selection signal active interrupt flag */
;;;549        if((u32Mask & QSPI_SSACT_INT_MASK) && (u32TmpVal))
000016  078c              LSLS     r4,r1,#30
000018  f0030304          AND      r3,r3,#4              ;547
00001c  d502              BPL      |L10.36|
00001e  b10b              CBZ      r3,|L10.36|
;;;550        {
;;;551            u32IntFlag |= QSPI_SSACT_INT_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L10.36|
;;;552        }
;;;553    
;;;554        u32TmpVal = qspi->STATUS & QSPI_STATUS_SSINAIF_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;555        /* Check slave selection signal inactive interrupt flag */
;;;556        if((u32Mask & QSPI_SSINACT_INT_MASK) && (u32TmpVal))
000026  074c              LSLS     r4,r1,#29
000028  f0030308          AND      r3,r3,#8              ;554
00002c  d502              BPL      |L10.52|
00002e  b10b              CBZ      r3,|L10.52|
;;;557        {
;;;558            u32IntFlag |= QSPI_SSINACT_INT_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L10.52|
;;;559        }
;;;560    
;;;561        u32TmpVal = qspi->STATUS & QSPI_STATUS_SLVURIF_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;562        /* Check slave TX under run interrupt flag */
;;;563        if((u32Mask & QSPI_SLVUR_INT_MASK) && (u32TmpVal))
000036  070c              LSLS     r4,r1,#28
000038  f0030380          AND      r3,r3,#0x80           ;561
00003c  d502              BPL      |L10.68|
00003e  b10b              CBZ      r3,|L10.68|
;;;564        {
;;;565            u32IntFlag |= QSPI_SLVUR_INT_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L10.68|
;;;566        }
;;;567    
;;;568        u32TmpVal = qspi->STATUS & QSPI_STATUS_SLVBEIF_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;569        /* Check slave bit count error interrupt flag */
;;;570        if((u32Mask & QSPI_SLVBE_INT_MASK) && (u32TmpVal))
000046  06cc              LSLS     r4,r1,#27
000048  f0030340          AND      r3,r3,#0x40           ;568
00004c  d502              BPL      |L10.84|
00004e  b10b              CBZ      r3,|L10.84|
;;;571        {
;;;572            u32IntFlag |= QSPI_SLVBE_INT_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L10.84|
;;;573        }
;;;574    
;;;575        u32TmpVal = qspi->STATUS & QSPI_STATUS_TXUFIF_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;576        /* Check slave TX underflow interrupt flag */
;;;577        if((u32Mask & QSPI_TXUF_INT_MASK) && (u32TmpVal))
000056  064c              LSLS     r4,r1,#25
000058  f4032300          AND      r3,r3,#0x80000        ;575
00005c  d502              BPL      |L10.100|
00005e  b10b              CBZ      r3,|L10.100|
;;;578        {
;;;579            u32IntFlag |= QSPI_TXUF_INT_MASK;
000060  f0400040          ORR      r0,r0,#0x40
                  |L10.100|
;;;580        }
;;;581    
;;;582        u32TmpVal = qspi->STATUS & QSPI_STATUS_TXTHIF_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;583        /* Check TX threshold interrupt flag */
;;;584        if((u32Mask & QSPI_FIFO_TXTH_INT_MASK) && (u32TmpVal))
000066  060c              LSLS     r4,r1,#24
000068  f4032380          AND      r3,r3,#0x40000        ;582
00006c  d502              BPL      |L10.116|
00006e  b10b              CBZ      r3,|L10.116|
;;;585        {
;;;586            u32IntFlag |= QSPI_FIFO_TXTH_INT_MASK;
000070  f0400080          ORR      r0,r0,#0x80
                  |L10.116|
;;;587        }
;;;588    
;;;589        u32TmpVal = qspi->STATUS & QSPI_STATUS_RXTHIF_Msk;
000074  6953              LDR      r3,[r2,#0x14]
;;;590        /* Check RX threshold interrupt flag */
;;;591        if((u32Mask & QSPI_FIFO_RXTH_INT_MASK) && (u32TmpVal))
000076  05cc              LSLS     r4,r1,#23
000078  f4036380          AND      r3,r3,#0x400          ;589
00007c  d502              BPL      |L10.132|
00007e  b10b              CBZ      r3,|L10.132|
;;;592        {
;;;593            u32IntFlag |= QSPI_FIFO_RXTH_INT_MASK;
000080  f4407080          ORR      r0,r0,#0x100
                  |L10.132|
;;;594        }
;;;595    
;;;596        u32TmpVal = qspi->STATUS & QSPI_STATUS_RXOVIF_Msk;
000084  6953              LDR      r3,[r2,#0x14]
;;;597        /* Check RX overrun interrupt flag */
;;;598        if((u32Mask & QSPI_FIFO_RXOV_INT_MASK) && (u32TmpVal))
000086  058c              LSLS     r4,r1,#22
000088  f4036300          AND      r3,r3,#0x800          ;596
00008c  d502              BPL      |L10.148|
00008e  b10b              CBZ      r3,|L10.148|
;;;599        {
;;;600            u32IntFlag |= QSPI_FIFO_RXOV_INT_MASK;
000090  f4407000          ORR      r0,r0,#0x200
                  |L10.148|
;;;601        }
;;;602    
;;;603        u32TmpVal = qspi->STATUS & QSPI_STATUS_RXTOIF_Msk;
000094  6952              LDR      r2,[r2,#0x14]
;;;604        /* Check RX time-out interrupt flag */
;;;605        if((u32Mask & QSPI_FIFO_RXTO_INT_MASK) && (u32TmpVal))
000096  0549              LSLS     r1,r1,#21
000098  f4025280          AND      r2,r2,#0x1000         ;603
00009c  d503              BPL      |L10.166|
00009e  2a00              CMP      r2,#0
0000a0  d001              BEQ      |L10.166|
;;;606        {
;;;607            u32IntFlag |= QSPI_FIFO_RXTO_INT_MASK;
0000a2  f4406080          ORR      r0,r0,#0x400
                  |L10.166|
;;;608        }
;;;609    
;;;610        return u32IntFlag;
;;;611    }
0000a6  bd10              POP      {r4,pc}
;;;612    
                          ENDP


                          AREA ||i.QSPI_GetStatus||, CODE, READONLY, ALIGN=1

                  QSPI_GetStatus PROC
;;;691      */
;;;692    uint32_t QSPI_GetStatus(QSPI_T *qspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;693    {
000002  4602              MOV      r2,r0
;;;694        uint32_t u32Flag = 0U, u32TmpValue;
000004  2000              MOVS     r0,#0
;;;695    
;;;696        u32TmpValue = qspi->STATUS & QSPI_STATUS_BUSY_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;697        /* Check busy status */
;;;698        if((u32Mask & QSPI_BUSY_MASK) && (u32TmpValue))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030301          AND      r3,r3,#1              ;696
00000e  d001              BEQ      |L11.20|
000010  b103              CBZ      r3,|L11.20|
;;;699        {
;;;700            u32Flag |= QSPI_BUSY_MASK;
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;701        }
;;;702    
;;;703        u32TmpValue = qspi->STATUS & QSPI_STATUS_RXEMPTY_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;704        /* Check RX empty flag */
;;;705        if((u32Mask & QSPI_RX_EMPTY_MASK) && (u32TmpValue))
000016  078c              LSLS     r4,r1,#30
000018  f4037380          AND      r3,r3,#0x100          ;703
00001c  d502              BPL      |L11.36|
00001e  b10b              CBZ      r3,|L11.36|
;;;706        {
;;;707            u32Flag |= QSPI_RX_EMPTY_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L11.36|
;;;708        }
;;;709    
;;;710        u32TmpValue = qspi->STATUS & QSPI_STATUS_RXFULL_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;711        /* Check RX full flag */
;;;712        if((u32Mask & QSPI_RX_FULL_MASK) && (u32TmpValue))
000026  074c              LSLS     r4,r1,#29
000028  f4037300          AND      r3,r3,#0x200          ;710
00002c  d502              BPL      |L11.52|
00002e  b10b              CBZ      r3,|L11.52|
;;;713        {
;;;714            u32Flag |= QSPI_RX_FULL_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L11.52|
;;;715        }
;;;716    
;;;717        u32TmpValue = qspi->STATUS & QSPI_STATUS_TXEMPTY_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;718        /* Check TX empty flag */
;;;719        if((u32Mask & QSPI_TX_EMPTY_MASK) && (u32TmpValue))
000036  070c              LSLS     r4,r1,#28
000038  f4033380          AND      r3,r3,#0x10000        ;717
00003c  d502              BPL      |L11.68|
00003e  b10b              CBZ      r3,|L11.68|
;;;720        {
;;;721            u32Flag |= QSPI_TX_EMPTY_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L11.68|
;;;722        }
;;;723    
;;;724        u32TmpValue = qspi->STATUS & QSPI_STATUS_TXFULL_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;725        /* Check TX full flag */
;;;726        if((u32Mask & QSPI_TX_FULL_MASK) && (u32TmpValue))
000046  06cc              LSLS     r4,r1,#27
000048  f4033300          AND      r3,r3,#0x20000        ;724
00004c  d502              BPL      |L11.84|
00004e  b10b              CBZ      r3,|L11.84|
;;;727        {
;;;728            u32Flag |= QSPI_TX_FULL_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L11.84|
;;;729        }
;;;730    
;;;731        u32TmpValue = qspi->STATUS & QSPI_STATUS_TXRXRST_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;732        /* Check TX/RX reset flag */
;;;733        if((u32Mask & QSPI_TXRX_RESET_MASK) && (u32TmpValue))
000056  068c              LSLS     r4,r1,#26
000058  f4030300          AND      r3,r3,#0x800000       ;731
00005c  d502              BPL      |L11.100|
00005e  b10b              CBZ      r3,|L11.100|
;;;734        {
;;;735            u32Flag |= QSPI_TXRX_RESET_MASK;
000060  f0400020          ORR      r0,r0,#0x20
                  |L11.100|
;;;736        }
;;;737    
;;;738        u32TmpValue = qspi->STATUS & QSPI_STATUS_QSPIENSTS_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;739        /* Check QSPIEN flag */
;;;740        if((u32Mask & QSPI_QSPIEN_STS_MASK) && (u32TmpValue))
000066  064c              LSLS     r4,r1,#25
000068  f4034300          AND      r3,r3,#0x8000         ;738
00006c  d502              BPL      |L11.116|
00006e  b10b              CBZ      r3,|L11.116|
;;;741        {
;;;742            u32Flag |= QSPI_QSPIEN_STS_MASK;
000070  f0400040          ORR      r0,r0,#0x40
                  |L11.116|
;;;743        }
;;;744    
;;;745        u32TmpValue = qspi->STATUS & QSPI_STATUS_SSLINE_Msk;
000074  6952              LDR      r2,[r2,#0x14]
;;;746        /* Check QSPIx_SS line status */
;;;747        if((u32Mask & QSPI_SSLINE_STS_MASK) && (u32TmpValue))
000076  0609              LSLS     r1,r1,#24
000078  f0020210          AND      r2,r2,#0x10           ;745
00007c  d503              BPL      |L11.134|
00007e  2a00              CMP      r2,#0
000080  d001              BEQ      |L11.134|
;;;748        {
;;;749            u32Flag |= QSPI_SSLINE_STS_MASK;
000082  f0400080          ORR      r0,r0,#0x80
                  |L11.134|
;;;750        }
;;;751    
;;;752        return u32Flag;
;;;753    }
000086  bd10              POP      {r4,pc}
;;;754    
                          ENDP


                          AREA ||i.QSPI_Open||, CODE, READONLY, ALIGN=2

                  QSPI_Open PROC
;;;41       */
;;;42     uint32_t QSPI_Open(QSPI_T *qspi,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;43                        uint32_t u32MasterSlave,
;;;44                        uint32_t u32QSPIMode,
;;;45                        uint32_t u32DataWidth,
;;;46                        uint32_t u32BusClock)
;;;47     {
000004  461f              MOV      r7,r3
;;;48         uint32_t u32ClkSrc = 0U, u32Div, u32HCLKFreq, u32RetValue=0U;
;;;49     
;;;50         if(u32DataWidth == 32U)
000006  9d08              LDR      r5,[sp,#0x20]
000008  4691              MOV      r9,r2                 ;47
00000a  4688              MOV      r8,r1                 ;47
00000c  4604              MOV      r4,r0                 ;47
00000e  2b20              CMP      r3,#0x20
000010  d100              BNE      |L12.20|
;;;51         {
;;;52             u32DataWidth = 0U;
000012  2700              MOVS     r7,#0
                  |L12.20|
;;;53         }
;;;54     
;;;55         /* Get system clock frequency */
;;;56         u32HCLKFreq = CLK_GetHCLKFreq();
000014  f7fffffe          BL       CLK_GetHCLKFreq
000018  4606              MOV      r6,r0
00001a  2000              MOVS     r0,#0
;;;57     
;;;58         if(u32MasterSlave == QSPI_MASTER)
;;;59         {
;;;60             /* Default setting: slave selection signal is active low; disable automatic slave selection function. */
;;;61             qspi->SSCTL = QSPI_SS_ACTIVE_LOW;
;;;62     
;;;63             /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;64             qspi->CTL = u32MasterSlave | (u32DataWidth << QSPI_CTL_DWIDTH_Pos) | (u32QSPIMode) | QSPI_CTL_QSPIEN_Msk;
;;;65     
;;;66             if(u32BusClock >= u32HCLKFreq)
;;;67             {
;;;68                 /* Select PCLK as the clock source of QSPI */
;;;69                 CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_QSPI0SEL_Msk)) | CLK_CLKSEL2_QSPI0SEL_PCLK0;
00001c  f04f4180          MOV      r1,#0x40000000
000020  f1b80f00          CMP      r8,#0                 ;58
000024  d014              BEQ      |L12.80|
;;;70             }
;;;71     
;;;72             /* Check clock source of QSPI */
;;;73             if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_HXT)
;;;74             {
;;;75                 u32ClkSrc = __HXT; /* Clock source is HXT */
;;;76             }
;;;77             else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PLL)
;;;78             {
;;;79                 u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;80             }
;;;81             else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PCLK0)
;;;82             {
;;;83                 /* Clock source is PCLK0 */
;;;84                 u32ClkSrc = CLK_GetPCLK0Freq();
;;;85             }
;;;86             else
;;;87             {
;;;88                 u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;89             }
;;;90     
;;;91             if(u32BusClock >= u32HCLKFreq)
;;;92             {
;;;93                 /* Set DIVIDER = 0 */
;;;94                 qspi->CLKDIV = 0U;
;;;95                 /* Return master peripheral clock rate */
;;;96                 u32RetValue = u32ClkSrc;
;;;97             }
;;;98             else if(u32BusClock >= u32ClkSrc)
;;;99             {
;;;100                /* Set DIVIDER = 0 */
;;;101                qspi->CLKDIV = 0U;
;;;102                /* Return master peripheral clock rate */
;;;103                u32RetValue = u32ClkSrc;
;;;104            }
;;;105            else if(u32BusClock == 0U)
;;;106            {
;;;107                /* Set DIVIDER to the maximum value 0xFF. f_qspi = f_qspi_clk_src / (DIVIDER + 1) */
;;;108                qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;109                /* Return master peripheral clock rate */
;;;110                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;111            }
;;;112            else
;;;113            {
;;;114                u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;115                if(u32Div > 0xFFU)
;;;116                {
;;;117                    u32Div = 0xFFU;
;;;118                    qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;119                    /* Return master peripheral clock rate */
;;;120                    u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;121                }
;;;122                else
;;;123                {
;;;124                    qspi->CLKDIV = (qspi->CLKDIV & (~QSPI_CLKDIV_DIVIDER_Msk)) | (u32Div << QSPI_CLKDIV_DIVIDER_Pos);
;;;125                    /* Return master peripheral clock rate */
;;;126                    u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;127                }
;;;128            }
;;;129        }
;;;130        else     /* For slave mode, force the QSPI peripheral clock rate to equal APB clock rate. */
;;;131        {
;;;132            /* Default setting: slave selection signal is low level active. */
;;;133            qspi->SSCTL = QSPI_SS_ACTIVE_LOW;
000026  60a0              STR      r0,[r4,#8]
;;;134    
;;;135            /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;136            qspi->CTL = u32MasterSlave | (u32DataWidth << QSPI_CTL_DWIDTH_Pos) | (u32QSPIMode) | QSPI_CTL_QSPIEN_Msk;
000028  ea482207          ORR      r2,r8,r7,LSL #8
00002c  ea420209          ORR      r2,r2,r9
000030  f0420201          ORR      r2,r2,#1
000034  6022              STR      r2,[r4,#0]
;;;137    
;;;138            /* Set DIVIDER = 0 */
;;;139            qspi->CLKDIV = 0U;
000036  6060              STR      r0,[r4,#4]
;;;140    
;;;141            /* Select PCLK as the clock source of QSPI */
;;;142            CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_QSPI0SEL_Msk)) | CLK_CLKSEL2_QSPI0SEL_PCLK0;
000038  f8d10218          LDR      r0,[r1,#0x218]
00003c  f020000c          BIC      r0,r0,#0xc
000040  f0400008          ORR      r0,r0,#8
000044  f8c10218          STR      r0,[r1,#0x218]
;;;143            /* Return slave peripheral clock rate */
;;;144            u32RetValue = CLK_GetPCLK0Freq();
000048  e8bd47f0          POP      {r4-r10,lr}
00004c  f7ffbffe          B.W      CLK_GetPCLK0Freq
                  |L12.80|
000050  4680              MOV      r8,r0                 ;61
000052  60a0              STR      r0,[r4,#8]            ;61
000054  ea402007          ORR      r0,r0,r7,LSL #8       ;64
000058  ea400009          ORR      r0,r0,r9              ;64
00005c  f0400001          ORR      r0,r0,#1              ;64
000060  6020              STR      r0,[r4,#0]            ;64
000062  42b5              CMP      r5,r6                 ;66
000064  d307              BCC      |L12.118|
000066  f8d10218          LDR      r0,[r1,#0x218]        ;69
00006a  f020000c          BIC      r0,r0,#0xc            ;69
00006e  f0400008          ORR      r0,r0,#8              ;69
000072  f8c10218          STR      r0,[r1,#0x218]        ;69
                  |L12.118|
000076  f8d10218          LDR      r0,[r1,#0x218]        ;73
00007a  f0100f0c          TST      r0,#0xc               ;73
00007e  481c              LDR      r0,|L12.240|
000080  d011              BEQ      |L12.166|
000082  f8d12218          LDR      r2,[r1,#0x218]        ;77
000086  f3c20281          UBFX     r2,r2,#2,#2           ;77
00008a  2a01              CMP      r2,#1                 ;77
00008c  d006              BEQ      |L12.156|
00008e  f8d11218          LDR      r1,[r1,#0x218]        ;81
000092  f3c10181          UBFX     r1,r1,#2,#2           ;81
000096  2902              CMP      r1,#2                 ;81
000098  d003              BEQ      |L12.162|
00009a  e004              B        |L12.166|
                  |L12.156|
00009c  f7fffffe          BL       CLK_GetPLLClockFreq
0000a0  e001              B        |L12.166|
                  |L12.162|
0000a2  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L12.166|
0000a6  42b5              CMP      r5,r6                 ;91
0000a8  d201              BCS      |L12.174|
0000aa  4285              CMP      r5,r0                 ;98
0000ac  d303              BCC      |L12.182|
                  |L12.174|
0000ae  f8c48004          STR      r8,[r4,#4]            ;94
                  |L12.178|
;;;145        }
;;;146    
;;;147        return u32RetValue;
;;;148    }
0000b2  e8bd87f0          POP      {r4-r10,pc}
                  |L12.182|
0000b6  f24012ff          MOV      r2,#0x1ff             ;108
0000ba  b15d              CBZ      r5,|L12.212|
0000bc  eb000180          ADD      r1,r0,r0,LSL #2       ;114
0000c0  0049              LSLS     r1,r1,#1              ;114
0000c2  fbb1f1f5          UDIV     r1,r1,r5              ;114
0000c6  230a              MOVS     r3,#0xa               ;114
0000c8  1d49              ADDS     r1,r1,#5              ;114
0000ca  fbb1f1f3          UDIV     r1,r1,r3              ;114
0000ce  1e49              SUBS     r1,r1,#1              ;114
0000d0  29ff              CMP      r1,#0xff              ;115
0000d2  d904              BLS      |L12.222|
                  |L12.212|
0000d4  6861              LDR      r1,[r4,#4]            ;108
0000d6  4311              ORRS     r1,r1,r2              ;108
0000d8  6061              STR      r1,[r4,#4]            ;108
0000da  0a00              LSRS     r0,r0,#8              ;110
0000dc  e7e9              B        |L12.178|
                  |L12.222|
0000de  6862              LDR      r2,[r4,#4]            ;124
0000e0  f36f0208          BFC      r2,#0,#9              ;124
0000e4  430a              ORRS     r2,r2,r1              ;124
0000e6  6062              STR      r2,[r4,#4]            ;124
0000e8  1c49              ADDS     r1,r1,#1              ;124
0000ea  fbb0f0f1          UDIV     r0,r0,r1              ;126
0000ee  e7e0              B        |L12.178|
;;;149    
                          ENDP

                  |L12.240|
                          DCD      0x00b71b00

                          AREA ||i.QSPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  QSPI_SetBusClock PROC
;;;222      */
;;;223    uint32_t QSPI_SetBusClock(QSPI_T *qspi, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;224    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;225        uint32_t u32ClkSrc, u32HCLKFreq;
;;;226        uint32_t u32Div, u32RetValue;
;;;227    
;;;228        /* Get system clock frequency */
;;;229        u32HCLKFreq = CLK_GetHCLKFreq();
000006  f7fffffe          BL       CLK_GetHCLKFreq
00000a  4606              MOV      r6,r0
;;;230    
;;;231        if(u32BusClock >= u32HCLKFreq)
;;;232        {
;;;233            /* Select PCLK as the clock source of QSPI */
;;;234            CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_QSPI0SEL_Msk)) | CLK_CLKSEL2_QSPI0SEL_PCLK0;
00000c  f04f4180          MOV      r1,#0x40000000
000010  42b5              CMP      r5,r6                 ;231
000012  d307              BCC      |L13.36|
000014  f8d10218          LDR      r0,[r1,#0x218]
000018  f020000c          BIC      r0,r0,#0xc
00001c  f0400008          ORR      r0,r0,#8
000020  f8c10218          STR      r0,[r1,#0x218]
                  |L13.36|
;;;235        }
;;;236    
;;;237        /* Check clock source of SPI */
;;;238        if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_HXT)
000024  f8d10218          LDR      r0,[r1,#0x218]
000028  f0100f0c          TST      r0,#0xc
;;;239        {
;;;240            u32ClkSrc = __HXT; /* Clock source is HXT */
00002c  481c              LDR      r0,|L13.160|
00002e  d011              BEQ      |L13.84|
;;;241        }
;;;242        else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PLL)
000030  f8d12218          LDR      r2,[r1,#0x218]
000034  f3c20281          UBFX     r2,r2,#2,#2
000038  2a01              CMP      r2,#1
00003a  d006              BEQ      |L13.74|
;;;243        {
;;;244            u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;245        }
;;;246        else if((CLK->CLKSEL2 & CLK_CLKSEL2_QSPI0SEL_Msk) == CLK_CLKSEL2_QSPI0SEL_PCLK0)
00003c  f8d11218          LDR      r1,[r1,#0x218]
000040  f3c10181          UBFX     r1,r1,#2,#2
000044  2902              CMP      r1,#2
000046  d003              BEQ      |L13.80|
000048  e004              B        |L13.84|
                  |L13.74|
00004a  f7fffffe          BL       CLK_GetPLLClockFreq
00004e  e001              B        |L13.84|
                  |L13.80|
;;;247        {
;;;248            /* Clock source is PCLK0 */
;;;249            u32ClkSrc = CLK_GetPCLK0Freq();
000050  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.84|
000054  2100              MOVS     r1,#0
;;;250        }
;;;251        else
;;;252        {
;;;253            u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;254        }
;;;255    
;;;256        if(u32BusClock >= u32HCLKFreq)
000056  42b5              CMP      r5,r6
000058  d201              BCS      |L13.94|
;;;257        {
;;;258            /* Set DIVIDER = 0 */
;;;259            qspi->CLKDIV = 0U;
;;;260            /* Return master peripheral clock rate */
;;;261            u32RetValue = u32ClkSrc;
;;;262        }
;;;263        else if(u32BusClock >= u32ClkSrc)
00005a  4285              CMP      r5,r0
00005c  d301              BCC      |L13.98|
                  |L13.94|
00005e  6061              STR      r1,[r4,#4]            ;259
;;;264        {
;;;265            /* Set DIVIDER = 0 */
;;;266            qspi->CLKDIV = 0U;
;;;267            /* Return master peripheral clock rate */
;;;268            u32RetValue = u32ClkSrc;
;;;269        }
;;;270        else if(u32BusClock == 0U)
;;;271        {
;;;272            /* Set DIVIDER to the maximum value 0xFF. f_qspi = f_qspi_clk_src / (DIVIDER + 1) */
;;;273            qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;274            /* Return master peripheral clock rate */
;;;275            u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;276        }
;;;277        else
;;;278        {
;;;279            u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;280            if(u32Div > 0x1FFU)
;;;281            {
;;;282                u32Div = 0x1FFU;
;;;283                qspi->CLKDIV |= QSPI_CLKDIV_DIVIDER_Msk;
;;;284                /* Return master peripheral clock rate */
;;;285                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;286            }
;;;287            else
;;;288            {
;;;289                qspi->CLKDIV = (qspi->CLKDIV & (~QSPI_CLKDIV_DIVIDER_Msk)) | (u32Div << QSPI_CLKDIV_DIVIDER_Pos);
;;;290                /* Return master peripheral clock rate */
;;;291                u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;292            }
;;;293        }
;;;294    
;;;295        return u32RetValue;
;;;296    }
000060  bd70              POP      {r4-r6,pc}
                  |L13.98|
000062  f24012ff          MOV      r2,#0x1ff             ;273
000066  b165              CBZ      r5,|L13.130|
000068  eb000180          ADD      r1,r0,r0,LSL #2       ;279
00006c  0049              LSLS     r1,r1,#1              ;279
00006e  fbb1f1f5          UDIV     r1,r1,r5              ;279
000072  230a              MOVS     r3,#0xa               ;279
000074  1d49              ADDS     r1,r1,#5              ;279
000076  fbb1f1f3          UDIV     r1,r1,r3              ;279
00007a  1e49              SUBS     r1,r1,#1              ;279
00007c  f5b17f00          CMP      r1,#0x200             ;280
000080  d304              BCC      |L13.140|
                  |L13.130|
000082  6861              LDR      r1,[r4,#4]            ;273
000084  4311              ORRS     r1,r1,r2              ;273
000086  6061              STR      r1,[r4,#4]            ;273
000088  0a00              LSRS     r0,r0,#8              ;275
00008a  bd70              POP      {r4-r6,pc}
                  |L13.140|
00008c  6862              LDR      r2,[r4,#4]            ;289
00008e  f36f0208          BFC      r2,#0,#9              ;289
000092  430a              ORRS     r2,r2,r1              ;289
000094  6062              STR      r2,[r4,#4]            ;289
000096  1c49              ADDS     r1,r1,#1              ;289
000098  fbb0f0f1          UDIV     r0,r0,r1              ;291
00009c  bd70              POP      {r4-r6,pc}
;;;297    
                          ENDP

00009e  0000              DCW      0x0000
                  |L13.160|
                          DCD      0x00b71b00

                          AREA ||i.QSPI_SetFIFO||, CODE, READONLY, ALIGN=1

                  QSPI_SetFIFO PROC
;;;305      */
;;;306    void QSPI_SetFIFO(QSPI_T *qspi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  6903              LDR      r3,[r0,#0x10]
;;;307    {
;;;308        qspi->FIFOCTL = (qspi->FIFOCTL & ~(QSPI_FIFOCTL_TXTH_Msk | QSPI_FIFOCTL_RXTH_Msk)) |
000002  f02343ee          BIC      r3,r3,#0x77000000
000006  ea437101          ORR      r1,r3,r1,LSL #28
00000a  ea416102          ORR      r1,r1,r2,LSL #24
00000e  6101              STR      r1,[r0,#0x10]
;;;309                        (u32TxThreshold << QSPI_FIFOCTL_TXTH_Pos) |
;;;310                        (u32RxThreshold << QSPI_FIFOCTL_RXTH_Pos);
;;;311    }
000010  4770              BX       lr
;;;312    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\qspi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_qspi_c_cc4eac31____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_qspi_c_cc4eac31____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_qspi_c_cc4eac31____REVSH|
#line 402
|__asm___6_qspi_c_cc4eac31____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_qspi_c_cc4eac31____RRX|
#line 587
|__asm___6_qspi_c_cc4eac31____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
