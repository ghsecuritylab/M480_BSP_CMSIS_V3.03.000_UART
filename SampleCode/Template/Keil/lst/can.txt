; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\can.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\can.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\can.crf ..\..\..\Library\StdDriver\src\can.c]
                          THUMB

                          AREA ||i.CAN_BasicReceiveMsg||, CODE, READONLY, ALIGN=1

                  CAN_BasicReceiveMsg PROC
;;;452      */
;;;453    int32_t CAN_BasicReceiveMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
;;;454    {
;;;455        int32_t rev = 1l;
;;;456    
;;;457        if((tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk) == 0ul)
000002  f8d03098          LDR      r3,[r0,#0x98]
000006  2201              MOVS     r2,#1                 ;455
000008  041b              LSLS     r3,r3,#16
00000a  d401              BMI      |L1.16|
;;;458        {
;;;459            /* In basic mode, receive data always save in IF2 */
;;;460            rev = 0; /* return FALSE */
00000c  2200              MOVS     r2,#0
00000e  e03a              B        |L1.134|
                  |L1.16|
;;;461        }
;;;462        else
;;;463        {
;;;464    
;;;465            tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000010  6843              LDR      r3,[r0,#4]
000012  f0230310          BIC      r3,r3,#0x10
000016  6043              STR      r3,[r0,#4]
;;;466    
;;;467            tCAN->IF[1].CMASK = CAN_IF_CMASK_ARB_Msk
000018  2333              MOVS     r3,#0x33
00001a  f8c03084          STR      r3,[r0,#0x84]
;;;468                                | CAN_IF_CMASK_CONTROL_Msk
;;;469                                | CAN_IF_CMASK_DATAA_Msk
;;;470                                | CAN_IF_CMASK_DATAB_Msk;
;;;471    
;;;472            if((tCAN->IF[1].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0ul)
00001e  f8d03094          LDR      r3,[r0,#0x94]
000022  045b              LSLS     r3,r3,#17
000024  d406              BMI      |L1.52|
;;;473            {
;;;474                /* standard ID*/
;;;475                pCanMsg->IdType = CAN_STD_ID;
000026  2300              MOVS     r3,#0
;;;476                pCanMsg->Id = (tCAN->IF[1].ARB2 >> 2) & 0x07FFul;
000028  600b              STR      r3,[r1,#0]
00002a  f8d03094          LDR      r3,[r0,#0x94]
00002e  f3c3038a          UBFX     r3,r3,#2,#11
000032  e009              B        |L1.72|
                  |L1.52|
;;;477    
;;;478            }
;;;479            else
;;;480            {
;;;481                /* extended ID*/
;;;482                pCanMsg->IdType = CAN_EXT_ID;
000034  2301              MOVS     r3,#1
;;;483                pCanMsg->Id  = (tCAN->IF[1].ARB2 & 0x1FFFul) << 16;
000036  600b              STR      r3,[r1,#0]
000038  f8d03094          LDR      r3,[r0,#0x94]
00003c  04db              LSLS     r3,r3,#19
00003e  08db              LSRS     r3,r3,#3
;;;484                pCanMsg->Id |= (uint32_t)tCAN->IF[1].ARB1;
000040  608b              STR      r3,[r1,#8]
000042  f8d04090          LDR      r4,[r0,#0x90]
000046  4323              ORRS     r3,r3,r4
                  |L1.72|
;;;485            }
;;;486    
;;;487            pCanMsg->FrameType = (((tCAN->IF[1].ARB2 & CAN_IF_ARB2_DIR_Msk) >> CAN_IF_ARB2_DIR_Pos)) ? 0ul : 1ul;
000048  608b              STR      r3,[r1,#8]
00004a  f8503f94          LDR      r3,[r0,#0x94]!
00004e  f3433340          SBFX     r3,r3,#13,#1
000052  1c5b              ADDS     r3,r3,#1
;;;488    
;;;489            pCanMsg->DLC     = (uint8_t)(tCAN->IF[1].MCON & CAN_IF_MCON_DLC_Msk);
000054  604b              STR      r3,[r1,#4]
000056  6843              LDR      r3,[r0,#4]
000058  f003030f          AND      r3,r3,#0xf
00005c  730b              STRB     r3,[r1,#0xc]
;;;490            pCanMsg->Data[0] = (uint8_t)(tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk);
00005e  6883              LDR      r3,[r0,#8]
000060  734b              STRB     r3,[r1,#0xd]
;;;491            pCanMsg->Data[1] = (uint8_t)((tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos);
000062  6883              LDR      r3,[r0,#8]
000064  0a1b              LSRS     r3,r3,#8
000066  738b              STRB     r3,[r1,#0xe]
;;;492            pCanMsg->Data[2] = (uint8_t)(tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk);
000068  68c3              LDR      r3,[r0,#0xc]
00006a  73cb              STRB     r3,[r1,#0xf]
;;;493            pCanMsg->Data[3] = (uint8_t)((tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos);
00006c  68c3              LDR      r3,[r0,#0xc]
00006e  0a1b              LSRS     r3,r3,#8
000070  740b              STRB     r3,[r1,#0x10]
;;;494            pCanMsg->Data[4] = (uint8_t)(tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk);
000072  6903              LDR      r3,[r0,#0x10]
000074  744b              STRB     r3,[r1,#0x11]
;;;495            pCanMsg->Data[5] = (uint8_t)((tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos);
000076  6903              LDR      r3,[r0,#0x10]
000078  0a1b              LSRS     r3,r3,#8
00007a  748b              STRB     r3,[r1,#0x12]
;;;496            pCanMsg->Data[6] = (uint8_t)(tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk);
00007c  6943              LDR      r3,[r0,#0x14]
00007e  74cb              STRB     r3,[r1,#0x13]
;;;497            pCanMsg->Data[7] = (uint8_t)((tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos);
000080  6940              LDR      r0,[r0,#0x14]
000082  0a00              LSRS     r0,r0,#8
000084  7508              STRB     r0,[r1,#0x14]
                  |L1.134|
;;;498        }
;;;499    
;;;500        return rev;
000086  4610              MOV      r0,r2
;;;501    }
000088  bd10              POP      {r4,pc}
;;;502    
                          ENDP


                          AREA ||i.CAN_BasicSendMsg||, CODE, READONLY, ALIGN=2

                  CAN_BasicSendMsg PROC
;;;367      */
;;;368    int32_t CAN_BasicSendMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
;;;369    {
;;;370        uint32_t i = 0ul;
;;;371        int32_t rev = 1l;
000002  2201              MOVS     r2,#1
                  |L2.4|
;;;372    
;;;373        while(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
000004  6a03              LDR      r3,[r0,#0x20]
000006  041b              LSLS     r3,r3,#16
000008  d4fc              BMI      |L2.4|
;;;374        {
;;;375        }
;;;376    
;;;377        tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
00000a  6843              LDR      r3,[r0,#4]
00000c  f0230308          BIC      r3,r3,#8
000010  6043              STR      r3,[r0,#4]
;;;378    
;;;379        if(pCanMsg->IdType == CAN_STD_ID)
000012  680b              LDR      r3,[r1,#0]
000014  b17b              CBZ      r3,|L2.54|
;;;380        {
;;;381            /* standard ID*/
;;;382            tCAN->IF[0].ARB1 = 0ul;
;;;383            tCAN->IF[0].ARB2 = (((pCanMsg->Id) & 0x7FFul) << 2ul) ;
;;;384        }
;;;385        else
;;;386        {
;;;387            /* extended ID*/
;;;388            tCAN->IF[0].ARB1 = (pCanMsg->Id) & 0xFFFFul;
000016  890b              LDRH     r3,[r1,#8]
000018  b29b              UXTH     r3,r3
00001a  6303              STR      r3,[r0,#0x30]
;;;389            tCAN->IF[0].ARB2 = ((pCanMsg->Id) & 0x1FFF0000ul) >> 16ul  | CAN_IF_ARB2_XTD_Msk;
00001c  688b              LDR      r3,[r1,#8]
00001e  f3c3430c          UBFX     r3,r3,#16,#13
000022  f4434380          ORR      r3,r3,#0x4000
                  |L2.38|
000026  6343              STR      r3,[r0,#0x34]
;;;390    
;;;391        }
;;;392    
;;;393        if(pCanMsg->FrameType)
000028  684b              LDR      r3,[r1,#4]
00002a  2b00              CMP      r3,#0
;;;394        {
;;;395            tCAN->IF[0].ARB2 |= CAN_IF_ARB2_DIR_Msk;
;;;396        }
;;;397        else
;;;398        {
;;;399            tCAN->IF[0].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
00002c  6b43              LDR      r3,[r0,#0x34]
00002e  d008              BEQ      |L2.66|
000030  f4435300          ORR      r3,r3,#0x2000         ;395
000034  e007              B        |L2.70|
                  |L2.54|
000036  2300              MOVS     r3,#0                 ;382
000038  6303              STR      r3,[r0,#0x30]         ;382
00003a  890b              LDRH     r3,[r1,#8]            ;383
00003c  055b              LSLS     r3,r3,#21             ;383
00003e  0cdb              LSRS     r3,r3,#19             ;383
000040  e7f1              B        |L2.38|
                  |L2.66|
000042  f4235300          BIC      r3,r3,#0x2000
                  |L2.70|
000046  6343              STR      r3,[r0,#0x34]
;;;400        }
;;;401    
;;;402        tCAN->IF[0].MCON = (tCAN->IF[0].MCON & (~CAN_IF_MCON_DLC_Msk)) | pCanMsg->DLC;
000048  6b83              LDR      r3,[r0,#0x38]
00004a  7b0c              LDRB     r4,[r1,#0xc]
00004c  f023030f          BIC      r3,r3,#0xf
000050  4323              ORRS     r3,r3,r4
000052  6383              STR      r3,[r0,#0x38]
;;;403        tCAN->IF[0].DAT_A1 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[1] << 8) | pCanMsg->Data[0]);
000054  f8313f0d          LDRH     r3,[r1,#0xd]!
000058  63c3              STR      r3,[r0,#0x3c]
;;;404        tCAN->IF[0].DAT_A2 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[3] << 8) | pCanMsg->Data[2]);
00005a  884b              LDRH     r3,[r1,#2]
00005c  6403              STR      r3,[r0,#0x40]
;;;405        tCAN->IF[0].DAT_B1 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[5] << 8) | pCanMsg->Data[4]);
00005e  888b              LDRH     r3,[r1,#4]
000060  6443              STR      r3,[r0,#0x44]
;;;406        tCAN->IF[0].DAT_B2 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[7] << 8) | pCanMsg->Data[6]);
000062  88c9              LDRH     r1,[r1,#6]
000064  6481              STR      r1,[r0,#0x48]
;;;407    
;;;408        /* request transmission*/
;;;409        tCAN->IF[0].CREQ &= (~CAN_IF_CREQ_BUSY_Msk);
000066  6a01              LDR      r1,[r0,#0x20]
000068  f4214100          BIC      r1,r1,#0x8000
00006c  6201              STR      r1,[r0,#0x20]
;;;410        if(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
00006e  6a01              LDR      r1,[r0,#0x20]
000070  0409              LSLS     r1,r1,#16
000072  d40d              BMI      |L2.144|
;;;411        {
;;;412            /* Cannot clear busy for sending ...*/
;;;413            rev = 0l; /* return FALSE */
;;;414        }
;;;415        else
;;;416        {
;;;417            tCAN->IF[0].CREQ |= CAN_IF_CREQ_BUSY_Msk;  /* sending */
000074  6a01              LDR      r1,[r0,#0x20]
000076  f4414100          ORR      r1,r1,#0x8000
00007a  6201              STR      r1,[r0,#0x20]
;;;418    
;;;419            for(i = 0ul; i < 0xFFFFFul; i++)
00007c  4b06              LDR      r3,|L2.152|
00007e  2100              MOVS     r1,#0
                  |L2.128|
;;;420            {
;;;421                if((tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
000080  6a04              LDR      r4,[r0,#0x20]
000082  0424              LSLS     r4,r4,#16
000084  d502              BPL      |L2.140|
000086  1c49              ADDS     r1,r1,#1
000088  4299              CMP      r1,r3                 ;419
00008a  d3f9              BCC      |L2.128|
                  |L2.140|
;;;422                {
;;;423                    break;
;;;424                }
;;;425                else
;;;426                {
;;;427                }
;;;428            }
;;;429    
;;;430            if(i >= 0xFFFFFul)
00008c  4299              CMP      r1,r3
00008e  d300              BCC      |L2.146|
                  |L2.144|
;;;431            {
;;;432                /* Cannot send out... */
;;;433                rev = 0l; /* return FALSE */
000090  2200              MOVS     r2,#0
                  |L2.146|
;;;434            }
;;;435            else
;;;436            {
;;;437            }
;;;438        }
;;;439    
;;;440        return rev;
000092  4610              MOV      r0,r2
;;;441    }
000094  bd10              POP      {r4,pc}
;;;442    
                          ENDP

000096  0000              DCW      0x0000
                  |L2.152|
                          DCD      0x000fffff

                          AREA ||i.CAN_CLR_INT_PENDING_BIT||, CODE, READONLY, ALIGN=1

                  CAN_CLR_INT_PENDING_BIT PROC
;;;1248     */
;;;1249   void CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum)
000000  b570              PUSH     {r4-r6,lr}
;;;1250   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1251       uint32_t u32MsgIfNum;
;;;1252   
;;;1253       if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000006  f7fffffe          BL       LockIF_TL
00000a  4601              MOV      r1,r0
00000c  2802              CMP      r0,#2
00000e  d100              BNE      |L3.18|
;;;1254       {
;;;1255           u32MsgIfNum = 0ul;
000010  2100              MOVS     r1,#0
                  |L3.18|
;;;1256       }
;;;1257       else
;;;1258       {
;;;1259       }
;;;1260   
;;;1261       tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000012  eb010041          ADD      r0,r1,r1,LSL #1
000016  eb051040          ADD      r0,r5,r0,LSL #5
00001a  220c              MOVS     r2,#0xc
00001c  6242              STR      r2,[r0,#0x24]
00001e  1c64              ADDS     r4,r4,#1
;;;1262       tCAN->IF[u32MsgIfNum].CREQ = 1ul + u32MsgNum;
000020  6204              STR      r4,[r0,#0x20]
;;;1263   
;;;1264       ReleaseIF(tCAN, u32MsgIfNum);
000022  4628              MOV      r0,r5
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      ReleaseIF
;;;1265   }
;;;1266   
                          ENDP


                          AREA ||i.CAN_Close||, CODE, READONLY, ALIGN=1

                  CAN_Close PROC
;;;862      */
;;;863    void CAN_Close(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
000002  f021010e          BIC      r1,r1,#0xe
000006  6001              STR      r1,[r0,#0]
;;;864    {
;;;865        CAN_DisableInt(tCAN, (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
;;;866    }
000008  4770              BX       lr
;;;867    
                          ENDP


                          AREA ||i.CAN_DisableInt||, CODE, READONLY, ALIGN=1

                  CAN_DisableInt PROC
;;;1034     */
;;;1035   void CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;1036   {
;;;1037       tCAN->CON = tCAN->CON & ~((u32Mask & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk)));
000002  f001010e          AND      r1,r1,#0xe
000006  438a              BICS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;1038   }
00000a  4770              BX       lr
;;;1039   
                          ENDP


                          AREA ||i.CAN_EnableInt||, CODE, READONLY, ALIGN=1

                  CAN_EnableInt PROC
;;;1018     */
;;;1019   void CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;1020   {
;;;1021       tCAN->CON = (tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk)) |
000002  f001010e          AND      r1,r1,#0xe
000006  f022020e          BIC      r2,r2,#0xe
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1022                   (u32Mask & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
;;;1023   }
00000e  4770              BX       lr
;;;1024   
                          ENDP


                          AREA ||i.CAN_EnterInitMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterInitMode PROC
;;;230      */
;;;231    void CAN_EnterInitMode(CAN_T *tCAN, uint8_t u8Mask)
000000  f0410141          ORR      r1,r1,#0x41
;;;232    {
;;;233        tCAN->CON = u8Mask | (CAN_CON_INIT_Msk | CAN_CON_CCE_Msk);
000004  6001              STR      r1,[r0,#0]
;;;234    }
000006  4770              BX       lr
;;;235    
                          ENDP


                          AREA ||i.CAN_EnterTestMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterTestMode PROC
;;;323      */
;;;324    void CAN_EnterTestMode(CAN_T *tCAN, uint8_t u8TestMask)
000000  6802              LDR      r2,[r0,#0]
;;;325    {
;;;326        tCAN->CON |= CAN_CON_TEST_Msk;
000002  f0420280          ORR      r2,r2,#0x80
000006  6002              STR      r2,[r0,#0]
;;;327        tCAN->TEST = u8TestMask;
000008  6141              STR      r1,[r0,#0x14]
;;;328    }
00000a  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.CAN_GetCANBitRate||, CODE, READONLY, ALIGN=2

                  CAN_GetCANBitRate PROC
;;;298      */
;;;299    uint32_t CAN_GetCANBitRate(CAN_T *tCAN)
000000  68c1              LDR      r1,[r0,#0xc]
;;;300    {
;;;301        uint32_t u32Tseg1, u32Tseg2;
;;;302        uint32_t u32Bpr;
;;;303    
;;;304        u32Tseg1 = (tCAN->BTIME & CAN_BTIME_TSEG1_Msk) >> CAN_BTIME_TSEG1_Pos;
000002  f3c12203          UBFX     r2,r1,#8,#4
;;;305        u32Tseg2 = (tCAN->BTIME & CAN_BTIME_TSEG2_Msk) >> CAN_BTIME_TSEG2_Pos;
000006  68c1              LDR      r1,[r0,#0xc]
;;;306        u32Bpr   = (tCAN->BTIME & CAN_BTIME_BRP_Msk) | (tCAN->BRPE << 6ul);
000008  6983              LDR      r3,[r0,#0x18]
00000a  f3c13102          UBFX     r1,r1,#12,#3          ;305
00000e  68c0              LDR      r0,[r0,#0xc]
000010  f363109f          BFI      r0,r3,#6,#26
;;;307    
;;;308        return (SystemCoreClock / (u32Bpr + 1ul) / (u32Tseg1 + u32Tseg2 + 3ul));
000014  4b04              LDR      r3,|L9.40|
000016  1c40              ADDS     r0,r0,#1
000018  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
00001a  fbb3f3f0          UDIV     r3,r3,r0
00001e  1850              ADDS     r0,r2,r1
000020  1cc0              ADDS     r0,r0,#3
000022  fbb3f0f0          UDIV     r0,r3,r0
;;;309    }
000026  4770              BX       lr
;;;310    
                          ENDP

                  |L9.40|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_IsNewDataReceived||, CODE, READONLY, ALIGN=1

                  CAN_IsNewDataReceived PROC
;;;351      */
;;;352    uint32_t CAN_IsNewDataReceived(CAN_T *tCAN, uint8_t u8MsgObj)
000000  2201              MOVS     r2,#1
;;;353    {
;;;354        return (u8MsgObj < 16ul ? tCAN->NDAT1 & (1ul << u8MsgObj) : tCAN->NDAT2 & (1ul << (u8MsgObj - 16ul)));
000002  2910              CMP      r1,#0x10
000004  d202              BCS      |L10.12|
000006  f8d00120          LDR      r0,[r0,#0x120]
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  f8d00124          LDR      r0,[r0,#0x124]
000010  3910              SUBS     r1,r1,#0x10
                  |L10.18|
000012  408a              LSLS     r2,r2,r1
000014  4010              ANDS     r0,r0,r2
;;;355    }
000016  4770              BX       lr
;;;356    
                          ENDP


                          AREA ||i.CAN_LeaveInitMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveInitMode PROC
;;;243      */
;;;244    void CAN_LeaveInitMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;245    {
;;;246        tCAN->CON &= (~(CAN_CON_INIT_Msk | CAN_CON_CCE_Msk));
000002  f0210141          BIC      r1,r1,#0x41
000006  6001              STR      r1,[r0,#0]
                  |L11.8|
;;;247        while(tCAN->CON & CAN_CON_INIT_Msk)
000008  6801              LDR      r1,[r0,#0]
00000a  07c9              LSLS     r1,r1,#31
00000c  d1fc              BNE      |L11.8|
;;;248        {
;;;249            /* Check INIT bit is released */
;;;250        }
;;;251    }
00000e  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.CAN_LeaveTestMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveTestMode PROC
;;;336      */
;;;337    void CAN_LeaveTestMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;338    {
;;;339        tCAN->CON |= CAN_CON_TEST_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;340        tCAN->TEST &= ~(CAN_TEST_LBACK_Msk | CAN_TEST_SILENT_Msk | CAN_TEST_BASIC_Msk);
000008  6941              LDR      r1,[r0,#0x14]
00000a  f021011c          BIC      r1,r1,#0x1c
00000e  6141              STR      r1,[r0,#0x14]
;;;341        tCAN->CON &= (~CAN_CON_TEST_Msk);
000010  6801              LDR      r1,[r0,#0]
000012  f0210180          BIC      r1,r1,#0x80
000016  6001              STR      r1,[r0,#0]
;;;342    }
000018  4770              BX       lr
;;;343    
                          ENDP


                          AREA ||i.CAN_Open||, CODE, READONLY, ALIGN=1

                  CAN_Open PROC
;;;880      */
;;;881    uint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;882    {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
;;;883        uint32_t u32CurrentBitRate;
;;;884    
;;;885        u32CurrentBitRate = CAN_SetBaudRate(tCAN, u32BaudRate);
000006  f7fffffe          BL       CAN_SetBaudRate
;;;886    
;;;887        if(u32Mode == CAN_BASIC_MODE)
00000a  2d01              CMP      r5,#1
00000c  d105              BNE      |L13.26|
00000e  6822              LDR      r2,[r4,#0]
;;;888        {
;;;889            CAN_EnterTestMode(tCAN, (uint8_t)CAN_TEST_BASIC_Msk);
000010  2104              MOVS     r1,#4
000012  f0420280          ORR      r2,r2,#0x80
000016  6022              STR      r2,[r4,#0]
000018  6161              STR      r1,[r4,#0x14]
                  |L13.26|
;;;890        }
;;;891        else
;;;892        {
;;;893        }
;;;894    
;;;895        return u32CurrentBitRate;
;;;896    }
00001a  bd70              POP      {r4-r6,pc}
;;;897    
                          ENDP


                          AREA ||i.CAN_ReadMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_ReadMsgObj PROC
;;;653      */
;;;654    int32_t CAN_ReadMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8Release, STR_CANMSG_T* pCanMsg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
000004  461c              MOV      r4,r3
000006  4617              MOV      r7,r2
000008  4688              MOV      r8,r1
00000a  4606              MOV      r6,r0
;;;656        int32_t rev = 1l;
00000c  2501              MOVS     r5,#1
;;;657        uint32_t u32MsgIfNum;
;;;658    
;;;659        if(!CAN_IsNewDataReceived(tCAN, u8MsgObj))
00000e  f7fffffe          BL       CAN_IsNewDataReceived
000012  b160              CBZ      r0,|L14.46|
;;;660        {
;;;661            rev = 0; /* return FALSE */
;;;662        }
;;;663        else
;;;664        {
;;;665            /* Get and lock a free interface */
;;;666            if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       LockIF_TL
00001a  4601              MOV      r1,r0
00001c  2802              CMP      r0,#2
00001e  d006              BEQ      |L14.46|
;;;667            {
;;;668                rev = 0; /* return FALSE */
;;;669            }
;;;670            else
;;;671            {
;;;672                tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000020  6870              LDR      r0,[r6,#4]
000022  f0200010          BIC      r0,r0,#0x10
000026  6070              STR      r0,[r6,#4]
;;;673    
;;;674                /* read the message contents*/
;;;675                tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_MASK_Msk
000028  b11f              CBZ      r7,|L14.50|
;;;676                                              | CAN_IF_CMASK_ARB_Msk
;;;677                                              | CAN_IF_CMASK_CONTROL_Msk
;;;678                                              | CAN_IF_CMASK_CLRINTPND_Msk
;;;679                                              | (u8Release ? CAN_IF_CMASK_TXRQSTNEWDAT_Msk : 0ul)
00002a  2004              MOVS     r0,#4
00002c  e002              B        |L14.52|
                  |L14.46|
00002e  2500              MOVS     r5,#0                 ;668
000030  e03a              B        |L14.168|
                  |L14.50|
000032  2000              MOVS     r0,#0
                  |L14.52|
000034  f040027b          ORR      r2,r0,#0x7b
000038  eb010041          ADD      r0,r1,r1,LSL #1
00003c  eb061040          ADD      r0,r6,r0,LSL #5
000040  6242              STR      r2,[r0,#0x24]
;;;680                                              | CAN_IF_CMASK_DATAA_Msk
;;;681                                              | CAN_IF_CMASK_DATAB_Msk;
;;;682    
;;;683                tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
000042  f1080201          ADD      r2,r8,#1
000046  6202              STR      r2,[r0,#0x20]
                  |L14.72|
;;;684    
;;;685                while(tCAN->IF[u32MsgIfNum].CREQ & CAN_IF_CREQ_BUSY_Msk)
000048  6a02              LDR      r2,[r0,#0x20]
00004a  0412              LSLS     r2,r2,#16
00004c  d4fc              BMI      |L14.72|
;;;686                {
;;;687                    /*Wait*/
;;;688                }
;;;689    
;;;690                if((tCAN->IF[u32MsgIfNum].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0ul)
00004e  6b42              LDR      r2,[r0,#0x34]
000050  0452              LSLS     r2,r2,#17
000052  d405              BMI      |L14.96|
;;;691                {
;;;692                    /* standard ID*/
;;;693                    pCanMsg->IdType = CAN_STD_ID;
000054  2200              MOVS     r2,#0
;;;694                    pCanMsg->Id     = (tCAN->IF[u32MsgIfNum].ARB2 & CAN_IF_ARB2_ID_Msk) >> 2ul;
000056  6022              STR      r2,[r4,#0]
000058  6b42              LDR      r2,[r0,#0x34]
00005a  f3c2028a          UBFX     r2,r2,#2,#11
00005e  e007              B        |L14.112|
                  |L14.96|
;;;695                }
;;;696                else
;;;697                {
;;;698                    /* extended ID*/
;;;699                    pCanMsg->IdType = CAN_EXT_ID;
000060  2201              MOVS     r2,#1
;;;700                    pCanMsg->Id  = (((tCAN->IF[u32MsgIfNum].ARB2) & 0x1FFFul) << 16) | tCAN->IF[u32MsgIfNum].ARB1;
000062  6022              STR      r2,[r4,#0]
000064  6b02              LDR      r2,[r0,#0x30]
000066  6b43              LDR      r3,[r0,#0x34]
000068  f3c3030c          UBFX     r3,r3,#0,#13
00006c  ea424203          ORR      r2,r2,r3,LSL #16
                  |L14.112|
;;;701                }
;;;702    
;;;703                pCanMsg->DLC     = (uint8_t)(tCAN->IF[u32MsgIfNum].MCON & CAN_IF_MCON_DLC_Msk);
000070  60a2              STR      r2,[r4,#8]
000072  6b82              LDR      r2,[r0,#0x38]
000074  f002020f          AND      r2,r2,#0xf
000078  7322              STRB     r2,[r4,#0xc]
;;;704                pCanMsg->Data[0] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk);
00007a  6bc2              LDR      r2,[r0,#0x3c]
00007c  7362              STRB     r2,[r4,#0xd]
;;;705                pCanMsg->Data[1] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos);
00007e  6bc2              LDR      r2,[r0,#0x3c]
000080  0a12              LSRS     r2,r2,#8
000082  73a2              STRB     r2,[r4,#0xe]
;;;706                pCanMsg->Data[2] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk);
000084  6c02              LDR      r2,[r0,#0x40]
000086  73e2              STRB     r2,[r4,#0xf]
;;;707                pCanMsg->Data[3] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos);
000088  6c02              LDR      r2,[r0,#0x40]
00008a  0a12              LSRS     r2,r2,#8
00008c  7422              STRB     r2,[r4,#0x10]
;;;708                pCanMsg->Data[4] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk);
00008e  6c42              LDR      r2,[r0,#0x44]
000090  7462              STRB     r2,[r4,#0x11]
;;;709                pCanMsg->Data[5] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos);
000092  6c42              LDR      r2,[r0,#0x44]
000094  0a12              LSRS     r2,r2,#8
000096  74a2              STRB     r2,[r4,#0x12]
;;;710                pCanMsg->Data[6] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk);
000098  6c82              LDR      r2,[r0,#0x48]
00009a  74e2              STRB     r2,[r4,#0x13]
;;;711                pCanMsg->Data[7] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos);
00009c  6c80              LDR      r0,[r0,#0x48]
00009e  0a00              LSRS     r0,r0,#8
0000a0  7520              STRB     r0,[r4,#0x14]
;;;712    
;;;713                ReleaseIF(tCAN, u32MsgIfNum);
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       ReleaseIF
                  |L14.168|
;;;714            }
;;;715        }
;;;716    
;;;717        return rev;
0000a8  4628              MOV      r0,r5
;;;718    }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;719    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;1220     */
;;;1221   int32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  b430              PUSH     {r4,r5}
;;;1222   {
000002  460c              MOV      r4,r1
;;;1223       int32_t rev = (int32_t)TRUE;
;;;1224       uint32_t u32Tmp;
;;;1225   
;;;1226       u32Tmp = (tCAN->TEST & CAN_TEST_BASIC_Msk);
000004  6941              LDR      r1,[r0,#0x14]
;;;1227   
;;;1228       if((tCAN->CON & CAN_CON_TEST_Msk) && u32Tmp)
000006  6803              LDR      r3,[r0,#0]
000008  f0010104          AND      r1,r1,#4              ;1226
00000c  061b              LSLS     r3,r3,#24
00000e  d504              BPL      |L15.26|
000010  b119              CBZ      r1,|L15.26|
;;;1229       {
;;;1230           rev = CAN_BasicReceiveMsg(tCAN, pCanMsg);
000012  bc30              POP      {r4,r5}
000014  4611              MOV      r1,r2
000016  f7ffbffe          B.W      CAN_BasicReceiveMsg
                  |L15.26|
;;;1231       }
;;;1232       else
;;;1233       {
;;;1234           rev = CAN_ReadMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)TRUE, pCanMsg);
00001a  b2e1              UXTB     r1,r4
00001c  4613              MOV      r3,r2
00001e  bc30              POP      {r4,r5}
000020  2201              MOVS     r2,#1
000022  f7ffbffe          B.W      CAN_ReadMsgObj
;;;1235       }
;;;1236   
;;;1237       return rev;
;;;1238   }
;;;1239   
                          ENDP


                          AREA ||i.CAN_SetBaudRate||, CODE, READONLY, ALIGN=2

                  CAN_SetBaudRate PROC
;;;730      */
;;;731    uint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;732    {
000004  b087              SUB      sp,sp,#0x1c
;;;733        long rate;
;;;734        long best_error = 1000000000, error = 0;
000006  485b              LDR      r0,|L16.372|
;;;735        int best_tseg = 0, best_brp = 0, brp = 0;
000008  9006              STR      r0,[sp,#0x18]
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;736        int tsegall, tseg = 0, tseg1 = 0, tseg2 = 0;
00000e  9004              STR      r0,[sp,#0x10]
000010  9002              STR      r0,[sp,#8]
;;;737        int spt_error = 1000, spt = 0, sampl_pt;
000012  9003              STR      r0,[sp,#0xc]
000014  f44f707a          MOV      r0,#0x3e8
000018  9005              STR      r0,[sp,#0x14]
00001a  9807              LDR      r0,[sp,#0x1c]
00001c  460e              MOV      r6,r1                 ;732
00001e  2401              MOVS     r4,#1
000020  2141              MOVS     r1,#0x41
000022  2500              MOVS     r5,#0
;;;738        uint64_t clock_freq = (uint64_t)0, u64PCLK_DIV = (uint64_t)1;
;;;739        uint32_t sjw = (uint32_t)1;
000024  4627              MOV      r7,r4
000026  6001              STR      r1,[r0,#0]
;;;740    
;;;741        CAN_EnterInitMode(tCAN, (uint8_t)0);
;;;742    
;;;743        SystemCoreClockUpdate();
000028  f7fffffe          BL       SystemCoreClockUpdate
;;;744        if(tCAN == CAN0)
00002c  4a52              LDR      r2,|L16.376|
00002e  9907              LDR      r1,[sp,#0x1c]
;;;745        {
;;;746            u64PCLK_DIV = (uint64_t)(CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk);
000030  0350              LSLS     r0,r2,#13
000032  f04f0801          MOV      r8,#1                 ;739
000036  4291              CMP      r1,r2                 ;744
000038  d104              BNE      |L16.68|
00003a  f8d00234          LDR      r0,[r0,#0x234]
00003e  f0000007          AND      r0,r0,#7
;;;747            u64PCLK_DIV = (uint64_t)(1 << u64PCLK_DIV);
000042  e006              B        |L16.82|
                  |L16.68|
;;;748        }
;;;749        else if(tCAN == CAN1)
000044  4a4d              LDR      r2,|L16.380|
000046  4291              CMP      r1,r2
000048  d106              BNE      |L16.88|
;;;750        {
;;;751            u64PCLK_DIV = (uint64_t)((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) >> CLK_PCLKDIV_APB1DIV_Pos);
00004a  f8d00234          LDR      r0,[r0,#0x234]
00004e  f3c01002          UBFX     r0,r0,#4,#3
                  |L16.82|
;;;752            u64PCLK_DIV = (uint64_t)(1 << u64PCLK_DIV);
000052  fa08f400          LSL      r4,r8,r0
000056  17e5              ASRS     r5,r4,#31
                  |L16.88|
;;;753        }
;;;754    
;;;755        clock_freq = SystemCoreClock / u64PCLK_DIV;
000058  4849              LDR      r0,|L16.384|
00005a  4622              MOV      r2,r4
00005c  462b              MOV      r3,r5
00005e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000060  2100              MOVS     r1,#0
000062  f7fffffe          BL       __aeabi_uldivmod
000066  4681              MOV      r9,r0
;;;756    
;;;757        if(u32BaudRate >= (uint32_t)1000000)
000068  4846              LDR      r0,|L16.388|
00006a  468a              MOV      r10,r1                ;755
00006c  4286              CMP      r6,r0
00006e  d301              BCC      |L16.116|
;;;758        {
;;;759            u32BaudRate = (uint32_t)1000000;
000070  4606              MOV      r6,r0
000072  e002              B        |L16.122|
                  |L16.116|
;;;760        }
;;;761    
;;;762        /* Use CIA recommended sample points */
;;;763        if (u32BaudRate > (uint32_t)800000)
000074  4844              LDR      r0,|L16.392|
000076  4286              CMP      r6,r0
000078  d902              BLS      |L16.128|
                  |L16.122|
;;;764        {
;;;765            sampl_pt = (int)750;
00007a  f24020ee          MOV      r0,#0x2ee
00007e  e007              B        |L16.144|
                  |L16.128|
;;;766        }
;;;767        else if (u32BaudRate > (uint32_t)500000)
000080  4842              LDR      r0,|L16.396|
000082  4286              CMP      r6,r0
000084  d902              BLS      |L16.140|
;;;768        {
;;;769            sampl_pt = (int)800;
000086  f44f7048          MOV      r0,#0x320
00008a  e001              B        |L16.144|
                  |L16.140|
;;;770        }
;;;771        else
;;;772        {
;;;773            sampl_pt = (int)875;
00008c  f240306b          MOV      r0,#0x36b
                  |L16.144|
;;;774        }
;;;775    
;;;776        /* tseg even = round down, odd = round up */
;;;777        for (tseg = (TSEG1_MAX + TSEG2_MAX) * 2ul + 1ul; tseg >= (TSEG1_MIN + TSEG2_MIN) * 2ul; tseg--)
000090  2431              MOVS     r4,#0x31
000092  9001              STR      r0,[sp,#4]
                  |L16.148|
;;;778        {
;;;779            tsegall = 1ul + tseg / 2ul;
000094  2001              MOVS     r0,#1
000096  eb000854          ADD      r8,r0,r4,LSR #1
;;;780            /* Compute all possible tseg choices (tseg=tseg1+tseg2) */
;;;781            brp = clock_freq / (tsegall * u32BaudRate) + tseg % 2;
00009a  fb08f206          MUL      r2,r8,r6
00009e  2300              MOVS     r3,#0
0000a0  4648              MOV      r0,r9
0000a2  4651              MOV      r1,r10
0000a4  f7fffffe          BL       __aeabi_uldivmod
0000a8  eb047bd4          ADD      r11,r4,r4,LSR #31
0000ac  f02b0101          BIC      r1,r11,#1
0000b0  1a61              SUBS     r1,r4,r1
0000b2  1845              ADDS     r5,r0,r1
;;;782            /* chose brp step which is possible in system */
;;;783            brp = (brp / BRP_INC) * BRP_INC;
;;;784    
;;;785            if ((brp < BRP_MIN) || (brp > BRP_MAX))
0000b4  f1a50001          SUB      r0,r5,#1
0000b8  f5b06f80          CMP      r0,#0x400
0000bc  d222              BCS      |L16.260|
;;;786            {
;;;787                continue;
;;;788            }
;;;789            rate = clock_freq / (brp * tsegall);
0000be  fb05f208          MUL      r2,r5,r8
0000c2  17d3              ASRS     r3,r2,#31
0000c4  4648              MOV      r0,r9
0000c6  4651              MOV      r1,r10
0000c8  f7fffffe          BL       __aeabi_uldivmod
;;;790    
;;;791            error = u32BaudRate - rate;
0000cc  1a30              SUBS     r0,r6,r0
;;;792    
;;;793            /* tseg brp biterror */
;;;794            if (error < 0)
0000ce  d500              BPL      |L16.210|
;;;795            {
;;;796                error = -error;
0000d0  4240              RSBS     r0,r0,#0
                  |L16.210|
;;;797            }
;;;798            if (error > best_error)
0000d2  9906              LDR      r1,[sp,#0x18]
0000d4  4288              CMP      r0,r1
0000d6  dc15              BGT      |L16.260|
;;;799            {
;;;800                continue;
;;;801            }
;;;802            best_error = error;
;;;803            if (error == 0)
0000d8  9006              STR      r0,[sp,#0x18]
0000da  b970              CBNZ     r0,|L16.250|
;;;804            {
;;;805                spt = can_update_spt(sampl_pt, tseg / 2, &tseg1, &tseg2);
0000dc  ea4f016b          ASR      r1,r11,#1
0000e0  ab03              ADD      r3,sp,#0xc
0000e2  aa02              ADD      r2,sp,#8
0000e4  9801              LDR      r0,[sp,#4]
0000e6  f7fffffe          BL       can_update_spt
;;;806                error = sampl_pt - spt;
0000ea  9901              LDR      r1,[sp,#4]
0000ec  1a08              SUBS     r0,r1,r0
;;;807                if (error < 0)
0000ee  d500              BPL      |L16.242|
;;;808                {
;;;809                    error = -error;
0000f0  4240              RSBS     r0,r0,#0
                  |L16.242|
;;;810                }
;;;811                if (error > spt_error)
0000f2  9905              LDR      r1,[sp,#0x14]
0000f4  4288              CMP      r0,r1
0000f6  dc05              BGT      |L16.260|
;;;812                {
;;;813                    continue;
;;;814                }
;;;815                spt_error = error;
0000f8  9005              STR      r0,[sp,#0x14]
                  |L16.250|
;;;816            }
;;;817            best_tseg = tseg / 2;
0000fa  ea4f016b          ASR      r1,r11,#1
;;;818            best_brp = brp;
;;;819    
;;;820            if (error == 0)
0000fe  9504              STR      r5,[sp,#0x10]
000100  9100              STR      r1,[sp,#0]
000102  b110              CBZ      r0,|L16.266|
                  |L16.260|
000104  1e64              SUBS     r4,r4,#1
000106  2c06              CMP      r4,#6                 ;777
000108  d2c4              BCS      |L16.148|
                  |L16.266|
;;;821            {
;;;822                break;
;;;823            }
;;;824        }
;;;825    
;;;826        spt = can_update_spt(sampl_pt, best_tseg, &tseg1, &tseg2);
00010a  e9dd1000          LDRD     r1,r0,[sp,#0]
00010e  ab03              ADD      r3,sp,#0xc
000110  aa02              ADD      r2,sp,#8
000112  f7fffffe          BL       can_update_spt
;;;827    
;;;828        /* check for sjw user settings */
;;;829        /* bt->sjw is at least 1 -> sanitize upper bound to sjw_max */
;;;830        if (sjw > SJW_MAX)
000116  2f04              CMP      r7,#4
000118  d900              BLS      |L16.284|
;;;831        {
;;;832            sjw = SJW_MAX;
00011a  2704              MOVS     r7,#4
                  |L16.284|
;;;833        }
;;;834        /* bt->sjw must not be higher than tseg2 */
;;;835        if (tseg2 < sjw)
00011c  9c03              LDR      r4,[sp,#0xc]
00011e  42bc              CMP      r4,r7
000120  d200              BCS      |L16.292|
;;;836        {
;;;837            sjw = tseg2;
000122  4627              MOV      r7,r4
                  |L16.292|
;;;838        }
;;;839    
;;;840        /* real bit-rate */
;;;841        u32BaudRate = clock_freq / (best_brp * (tseg1 + tseg2 + 1));
000124  9d02              LDR      r5,[sp,#8]
000126  9804              LDR      r0,[sp,#0x10]
000128  192a              ADDS     r2,r5,r4
00012a  1c52              ADDS     r2,r2,#1
00012c  4342              MULS     r2,r0,r2
00012e  17d3              ASRS     r3,r2,#31
000130  4648              MOV      r0,r9
000132  4651              MOV      r1,r10
000134  f7fffffe          BL       __aeabi_uldivmod
000138  4602              MOV      r2,r0
;;;842    
;;;843        tCAN->BTIME = ((uint32_t)(tseg2 - 1ul) << CAN_BTIME_TSEG2_Pos) | ((uint32_t)(tseg1 - 1ul) << CAN_BTIME_TSEG1_Pos) |
00013a  0320              LSLS     r0,r4,#12
00013c  f06f01ff          MVN      r1,#0xff
000140  eb012105          ADD      r1,r1,r5,LSL #8
000144  f5a05080          SUB      r0,r0,#0x1000
000148  4308              ORRS     r0,r0,r1
00014a  9904              LDR      r1,[sp,#0x10]
00014c  1e49              SUBS     r1,r1,#1
00014e  f001033f          AND      r3,r1,#0x3f
000152  4318              ORRS     r0,r0,r3
000154  ea401387          ORR      r3,r0,r7,LSL #6
000158  9807              LDR      r0,[sp,#0x1c]
00015a  60c3              STR      r3,[r0,#0xc]
;;;844                      ((uint32_t)(best_brp - 1ul) & CAN_BTIME_BRP_Msk) | (sjw << CAN_BTIME_SJW_Pos);
;;;845        tCAN->BRPE  = ((uint32_t)(best_brp - 1ul) >> 6) & 0x0Ful;
00015c  9807              LDR      r0,[sp,#0x1c]
00015e  f3c11183          UBFX     r1,r1,#6,#4
000162  6181              STR      r1,[r0,#0x18]
;;;846    
;;;847        /* printf("\n bitrate = %d \n", CAN_GetCANBitRate(tCAN)); */
;;;848    
;;;849        CAN_LeaveInitMode(tCAN);
000164  9807              LDR      r0,[sp,#0x1c]
000166  f7fffffe          BL       CAN_LeaveInitMode
;;;850    
;;;851        return u32BaudRate;
;;;852    }
00016a  b009              ADD      sp,sp,#0x24
00016c  4610              MOV      r0,r2                 ;851
00016e  e8bd8ff0          POP      {r4-r11,pc}
;;;853    
                          ENDP

000172  0000              DCW      0x0000
                  |L16.372|
                          DCD      0x3b9aca00
                  |L16.376|
                          DCD      0x400a0000
                  |L16.380|
                          DCD      0x400a1000
                  |L16.384|
                          DCD      SystemCoreClock
                  |L16.388|
                          DCD      0x000f4240
                  |L16.392|
                          DCD      0x000c3500
                  |L16.396|
                          DCD      0x0007a120

                          AREA ||i.CAN_SetMultiRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetMultiRxMsg PROC
;;;1130     */
;;;1131   int32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1132   {
;;;1133       int32_t  rev = (int32_t)TRUE;
000004  f04f0a01          MOV      r10,#1
000008  b081              SUB      sp,sp,#4              ;1132
00000a  469b              MOV      r11,r3                ;1132
00000c  460e              MOV      r6,r1                 ;1132
;;;1134       uint32_t i = 0ul;
;;;1135       uint32_t u32TimeOutCount;
;;;1136       uint32_t u32EOB_Flag = 0ul;
00000e  f04f0800          MOV      r8,#0
;;;1137   
;;;1138       for(i = 1ul; i < u32MsgCount; i++)
000012  4654              MOV      r4,r10
;;;1139       {
;;;1140           u32TimeOutCount = 0ul;
;;;1141   
;;;1142           u32MsgNum += (i - 1ul);
;;;1143   
;;;1144           if(i == u32MsgCount)
;;;1145           {
;;;1146               u32EOB_Flag = 1ul;
;;;1147           }
;;;1148           else
;;;1149           {
;;;1150           }
;;;1151   
;;;1152           while(CAN_SetRxMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)u32EOB_Flag) == (int32_t)FALSE)
;;;1153           {
;;;1154               if(++u32TimeOutCount >= RETRY_COUNTS)
000014  f04f5980          MOV      r9,#0x10000000
000018  e013              B        |L17.66|
                  |L17.26|
00001a  4426              ADD      r6,r6,r4              ;1142
00001c  f04f0500          MOV      r5,#0                 ;1140
000020  f1a60601          SUB      r6,r6,#1              ;1142
000024  d101              BNE      |L17.42|
000026  f04f0801          MOV      r8,#1                 ;1146
                  |L17.42|
00002a  f00807ff          AND      r7,r8,#0xff           ;1152
                  |L17.46|
00002e  f00b02ff          AND      r2,r11,#0xff          ;1152
000032  b2f1              UXTB     r1,r6                 ;1152
000034  9700              STR      r7,[sp,#0]            ;1152
000036  9b0e              LDR      r3,[sp,#0x38]         ;1152
000038  9801              LDR      r0,[sp,#4]            ;1152
00003a  f7fffffe          BL       CAN_SetRxMsgObj
00003e  b138              CBZ      r0,|L17.80|
                  |L17.64|
000040  1c64              ADDS     r4,r4,#1              ;1152
                  |L17.66|
000042  9803              LDR      r0,[sp,#0xc]          ;1138
000044  4284              CMP      r4,r0                 ;1138
000046  d3e8              BCC      |L17.26|
;;;1155               {
;;;1156                   rev = (int32_t)FALSE;
;;;1157                   break;
;;;1158               }
;;;1159               else
;;;1160               {
;;;1161               }
;;;1162           }
;;;1163       }
;;;1164   
;;;1165       return rev;
;;;1166   }
000048  b005              ADD      sp,sp,#0x14
00004a  4650              MOV      r0,r10                ;1165
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.80|
000050  f1050501          ADD      r5,r5,#1
000054  454d              CMP      r5,r9                 ;1154
000056  d3ea              BCC      |L17.46|
000058  f04f0a00          MOV      r10,#0                ;1156
00005c  e7f0              B        |L17.64|
;;;1167   
                          ENDP


                          AREA ||i.CAN_SetRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsg PROC
;;;1056     */
;;;1057   int32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1058   {
;;;1059       int32_t rev = (int32_t)TRUE;
000004  2501              MOVS     r5,#1
000006  469a              MOV      r10,r3                ;1058
000008  4616              MOV      r6,r2                 ;1058
00000a  460f              MOV      r7,r1                 ;1058
00000c  4683              MOV      r11,r0                ;1058
;;;1060       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1061   
;;;1062       while(CAN_SetRxMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1063       {
;;;1064           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5980          MOV      r9,#0x10000000
000014  46a8              MOV      r8,r5                 ;1059
000016  e004              B        |L18.34|
                  |L18.24|
000018  1c64              ADDS     r4,r4,#1              ;1058
00001a  454c              CMP      r4,r9
00001c  d301              BCC      |L18.34|
;;;1065           {
;;;1066               rev = (int32_t)(FALSE); /* return FALSE */
00001e  2500              MOVS     r5,#0
;;;1067               break;
000020  e009              B        |L18.54|
                  |L18.34|
000022  b2f2              UXTB     r2,r6                 ;1062
000024  b2f9              UXTB     r1,r7                 ;1062
000026  4653              MOV      r3,r10                ;1062
000028  4658              MOV      r0,r11                ;1062
00002a  f8cd8000          STR      r8,[sp,#0]            ;1062
00002e  f7fffffe          BL       CAN_SetRxMsgObj
000032  2800              CMP      r0,#0                 ;1062
000034  d0f0              BEQ      |L18.24|
                  |L18.54|
;;;1068           }
;;;1069           else
;;;1070           {
;;;1071           }
;;;1072       }
;;;1073   
;;;1074       return rev;
000036  4628              MOV      r0,r5
;;;1075   }
000038  e8bd8ff8          POP      {r3-r11,pc}
;;;1076   
                          ENDP


                          AREA ||i.CAN_SetRxMsgAndMsk||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgAndMsk PROC
;;;1093     */
;;;1094   int32_t CAN_SetRxMsgAndMsk(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID, uint32_t u32IDMask)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1095   {
000004  b083              SUB      sp,sp,#0xc
;;;1096       int32_t  rev = (int32_t)TRUE;
000006  2501              MOVS     r5,#1
000008  469b              MOV      r11,r3                ;1095
00000a  4616              MOV      r6,r2                 ;1095
00000c  460f              MOV      r7,r1                 ;1095
;;;1097       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1098   
;;;1099       while(CAN_SetRxMsgObjAndMsk(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, u32IDMask, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1100       {
;;;1101           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5a80          MOV      r10,#0x10000000
000014  46a9              MOV      r9,r5                 ;1096
000016  f8dd8040          LDR      r8,[sp,#0x40]         ;1095
00001a  e004              B        |L19.38|
                  |L19.28|
00001c  1c64              ADDS     r4,r4,#1              ;1095
00001e  4554              CMP      r4,r10
000020  d301              BCC      |L19.38|
;;;1102           {
;;;1103               rev = (int32_t)FALSE;
000022  2500              MOVS     r5,#0
;;;1104               break;
000024  e009              B        |L19.58|
                  |L19.38|
000026  b2f2              UXTB     r2,r6                 ;1099
000028  b2f9              UXTB     r1,r7                 ;1099
00002a  465b              MOV      r3,r11                ;1099
00002c  e9cd8900          STRD     r8,r9,[sp,#0]         ;1099
000030  9803              LDR      r0,[sp,#0xc]          ;1099
000032  f7fffffe          BL       CAN_SetRxMsgObjAndMsk
000036  2800              CMP      r0,#0                 ;1099
000038  d0f0              BEQ      |L19.28|
                  |L19.58|
;;;1105           }
;;;1106           else
;;;1107           {
;;;1108           }
;;;1109       }
;;;1110   
;;;1111       return rev;
;;;1112   }
00003a  b007              ADD      sp,sp,#0x1c
00003c  4628              MOV      r0,r5                 ;1111
00003e  e8bd8ff0          POP      {r4-r11,pc}
;;;1113   
                          ENDP


                          AREA ||i.CAN_SetRxMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObj PROC
;;;590      */
;;;591    int32_t CAN_SetRxMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;592    {
000004  461c              MOV      r4,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4680              MOV      r8,r0
;;;593        int32_t rev = 1l;
00000c  2501              MOVS     r5,#1
;;;594        uint32_t u32MsgIfNum;
;;;595    
;;;596        /* Get and lock a free interface */
;;;597        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000e  f8dd9020          LDR      r9,[sp,#0x20]
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L20.78|
;;;598        {
;;;599            rev = 0; /* return FALSE */
;;;600        }
;;;601        else
;;;602        {
;;;603            /* Command Setting */
;;;604            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb081043          ADD      r0,r8,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;605                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;606    
;;;607            if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  b197              CBZ      r7,|L20.82|
;;;608            {
;;;609                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;610                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;611            }
;;;612            else
;;;613            {
;;;614                tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
00002c  b2a3              UXTH     r3,r4
00002e  6303              STR      r3,[r0,#0x30]
;;;615                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000030  f3c4430c          UBFX     r3,r4,#16,#13
000034  f4434340          ORR      r3,r3,#0xc000
                  |L20.56|
000038  6343              STR      r3,[r0,#0x34]
;;;616            }
;;;617    
;;;618            /* tCAN->IF[u8MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; */
;;;619            tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
00003a  f44f53a0          MOV      r3,#0x1400
00003e  6383              STR      r3,[r0,#0x38]
;;;620            if(u8singleOrFifoLast)
;;;621            {
;;;622                tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;623            }
;;;624            else
;;;625            {
;;;626                tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
000040  6b83              LDR      r3,[r0,#0x38]
000042  f1b90f00          CMP      r9,#0                 ;620
000046  d00c              BEQ      |L20.98|
000048  f0430380          ORR      r3,r3,#0x80           ;622
00004c  e00b              B        |L20.102|
                  |L20.78|
00004e  2500              MOVS     r5,#0                 ;599
000050  e013              B        |L20.122|
                  |L20.82|
000052  6302              STR      r2,[r0,#0x30]         ;609
000054  f3c4030a          UBFX     r3,r4,#0,#11          ;610
000058  f44f4400          MOV      r4,#0x8000            ;610
00005c  ea440383          ORR      r3,r4,r3,LSL #2       ;610
000060  e7ea              B        |L20.56|
                  |L20.98|
000062  f0230380          BIC      r3,r3,#0x80
                  |L20.102|
000066  6383              STR      r3,[r0,#0x38]
;;;627            }
;;;628    
;;;629            tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000068  63c2              STR      r2,[r0,#0x3c]
;;;630            tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
00006a  6402              STR      r2,[r0,#0x40]
;;;631            tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
00006c  6442              STR      r2,[r0,#0x44]
;;;632            tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
00006e  6482              STR      r2,[r0,#0x48]
000070  1c76              ADDS     r6,r6,#1
;;;633    
;;;634            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
000072  6206              STR      r6,[r0,#0x20]
;;;635            ReleaseIF(tCAN, u32MsgIfNum);
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       ReleaseIF
                  |L20.122|
;;;636        }
;;;637    
;;;638        return rev;
00007a  4628              MOV      r0,r5
;;;639    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;640    
                          ENDP


                          AREA ||i.CAN_SetRxMsgObjAndMsk||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObjAndMsk PROC
;;;520      */
;;;521    int32_t CAN_SetRxMsgObjAndMsk(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint32_t u32idmask, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;522    {
000004  461c              MOV      r4,r3
000006  e9dd6a08          LDRD     r6,r10,[sp,#0x20]
00000a  4690              MOV      r8,r2
00000c  460f              MOV      r7,r1
00000e  4681              MOV      r9,r0
;;;523        int32_t rev = 1l;
000010  2501              MOVS     r5,#1
;;;524        uint32_t u32MsgIfNum;
;;;525    
;;;526        /* Get and lock a free interface */
;;;527        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d01e              BEQ      |L21.90|
;;;528        {
;;;529            rev = 0; /* return FALSE */
;;;530        }
;;;531        else
;;;532        {
;;;533            /* Command Setting */
;;;534            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb091043          ADD      r0,r9,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;535                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;536    
;;;537            if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  f1b80f00          CMP      r8,#0
00002e  d016              BEQ      |L21.94|
;;;538            {
;;;539                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;540                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;541            }
;;;542            else
;;;543            {
;;;544                tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
000030  b2a3              UXTH     r3,r4
000032  6303              STR      r3,[r0,#0x30]
;;;545                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000034  f3c4430c          UBFX     r3,r4,#16,#13
000038  f4434340          ORR      r3,r3,#0xc000
                  |L21.60|
00003c  6343              STR      r3,[r0,#0x34]
;;;546            }
;;;547    
;;;548            tCAN->IF[u32MsgIfNum].MASK1 = (u32idmask & 0xFFFFul);
00003e  b2b3              UXTH     r3,r6
000040  6283              STR      r3,[r0,#0x28]
;;;549            tCAN->IF[u32MsgIfNum].MASK2 = (u32idmask >> 16) & 0xFFFFul;
000042  0c33              LSRS     r3,r6,#16
000044  62c3              STR      r3,[r0,#0x2c]
;;;550    
;;;551            /* tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; */
;;;552            tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
000046  f44f53a0          MOV      r3,#0x1400
00004a  6383              STR      r3,[r0,#0x38]
;;;553            if(u8singleOrFifoLast)
;;;554            {
;;;555                tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;556            }
;;;557            else
;;;558            {
;;;559                tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
00004c  6b83              LDR      r3,[r0,#0x38]
00004e  f1ba0f00          CMP      r10,#0                ;553
000052  d00c              BEQ      |L21.110|
000054  f0430380          ORR      r3,r3,#0x80           ;555
000058  e00b              B        |L21.114|
                  |L21.90|
00005a  2500              MOVS     r5,#0                 ;529
00005c  e013              B        |L21.134|
                  |L21.94|
00005e  6302              STR      r2,[r0,#0x30]         ;539
000060  f3c4030a          UBFX     r3,r4,#0,#11          ;540
000064  f44f4400          MOV      r4,#0x8000            ;540
000068  ea440383          ORR      r3,r4,r3,LSL #2       ;540
00006c  e7e6              B        |L21.60|
                  |L21.110|
00006e  f0230380          BIC      r3,r3,#0x80
                  |L21.114|
000072  6383              STR      r3,[r0,#0x38]
;;;560            }
;;;561    
;;;562            tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000074  63c2              STR      r2,[r0,#0x3c]
;;;563            tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
000076  6402              STR      r2,[r0,#0x40]
;;;564            tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
000078  6442              STR      r2,[r0,#0x44]
;;;565            tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
00007a  6482              STR      r2,[r0,#0x48]
00007c  1c7f              ADDS     r7,r7,#1
;;;566    
;;;567            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
00007e  6207              STR      r7,[r0,#0x20]
;;;568            ReleaseIF(tCAN, u32MsgIfNum);
000080  4648              MOV      r0,r9
000082  f7fffffe          BL       ReleaseIF
                  |L21.134|
;;;569        }
;;;570    
;;;571        return rev;
000086  4628              MOV      r0,r5
;;;572    }
000088  e8bd87f0          POP      {r4-r10,pc}
;;;573    
                          ENDP


                          AREA ||i.CAN_SetTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetTxMsg PROC
;;;910      */
;;;911    int32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;912    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;913        int32_t rev = 1l;
00000a  2501              MOVS     r5,#1
;;;914        uint32_t u32MsgIfNum;
;;;915    
;;;916        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000c  f7fffffe          BL       LockIF_TL
000010  4601              MOV      r1,r0
000012  2802              CMP      r0,#2
000014  d017              BEQ      |L22.70|
;;;917        {
;;;918            rev = 0; /* return FALSE */
;;;919        }
;;;920        else
;;;921        {
;;;922            /* update the contents needed for transmission*/
;;;923            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
000016  eb010041          ADD      r0,r1,r1,LSL #1
00001a  eb071040          ADD      r0,r7,r0,LSL #5
00001e  22f3              MOVS     r2,#0xf3
000020  6242              STR      r2,[r0,#0x24]
;;;924                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk  | CAN_IF_CMASK_DATAB_Msk;
;;;925    
;;;926            if(pCanMsg->IdType == CAN_STD_ID)
000022  6822              LDR      r2,[r4,#0]
000024  b18a              CBZ      r2,|L22.74|
;;;927            {
;;;928                /* standard ID*/
;;;929                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;930                tCAN->IF[u32MsgIfNum].ARB2 = (((pCanMsg->Id) & 0x7FFul) << 2) | CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;931            }
;;;932            else
;;;933            {
;;;934                /* extended ID*/
;;;935                tCAN->IF[u32MsgIfNum].ARB1 = (pCanMsg->Id) & 0xFFFFul;
000026  8922              LDRH     r2,[r4,#8]
000028  b292              UXTH     r2,r2
00002a  6302              STR      r2,[r0,#0x30]
;;;936                tCAN->IF[u32MsgIfNum].ARB2 = ((pCanMsg->Id) & 0x1FFF0000ul) >> 16 |
00002c  68a2              LDR      r2,[r4,#8]
00002e  f3c2420c          UBFX     r2,r2,#16,#13
000032  f4424260          ORR      r2,r2,#0xe000
                  |L22.54|
000036  6342              STR      r2,[r0,#0x34]
;;;937                                             CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_XTD_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;938            }
;;;939    
;;;940            if(pCanMsg->FrameType)
000038  6862              LDR      r2,[r4,#4]
00003a  2a00              CMP      r2,#0
;;;941            {
;;;942                tCAN->IF[u32MsgIfNum].ARB2 |=   CAN_IF_ARB2_DIR_Msk;
;;;943            }
;;;944            else
;;;945            {
;;;946                tCAN->IF[u32MsgIfNum].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
00003c  6b42              LDR      r2,[r0,#0x34]
00003e  d00e              BEQ      |L22.94|
000040  f4425200          ORR      r2,r2,#0x2000         ;942
000044  e00d              B        |L22.98|
                  |L22.70|
000046  2500              MOVS     r5,#0                 ;918
000048  e020              B        |L22.140|
                  |L22.74|
00004a  2200              MOVS     r2,#0                 ;929
00004c  6302              STR      r2,[r0,#0x30]         ;929
00004e  8922              LDRH     r2,[r4,#8]            ;930
000050  f44f4320          MOV      r3,#0xa000            ;930
000054  f3c2020a          UBFX     r2,r2,#0,#11          ;930
000058  ea430282          ORR      r2,r3,r2,LSL #2       ;930
00005c  e7eb              B        |L22.54|
                  |L22.94|
00005e  f4225200          BIC      r2,r2,#0x2000
                  |L22.98|
000062  6342              STR      r2,[r0,#0x34]
;;;947            }
;;;948    
;;;949            tCAN->IF[u32MsgIfNum].DAT_A1 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[1] << 8)) | pCanMsg->Data[0]);
000064  f8342f0d          LDRH     r2,[r4,#0xd]!
000068  63c2              STR      r2,[r0,#0x3c]
;;;950            tCAN->IF[u32MsgIfNum].DAT_A2 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[3] << 8)) | pCanMsg->Data[2]);
00006a  8862              LDRH     r2,[r4,#2]
00006c  6402              STR      r2,[r0,#0x40]
;;;951            tCAN->IF[u32MsgIfNum].DAT_B1 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[5] << 8)) | pCanMsg->Data[4]);
00006e  88a2              LDRH     r2,[r4,#4]
000070  6442              STR      r2,[r0,#0x44]
;;;952            tCAN->IF[u32MsgIfNum].DAT_B2 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[7] << 8)) | pCanMsg->Data[6]);
000072  88e2              LDRH     r2,[r4,#6]
000074  6482              STR      r2,[r0,#0x48]
;;;953    
;;;954            tCAN->IF[u32MsgIfNum].MCON   =  CAN_IF_MCON_NEWDAT_Msk | pCanMsg->DLC | CAN_IF_MCON_TXIE_Msk | CAN_IF_MCON_EOB_Msk;
000076  f8142c01          LDRB     r2,[r4,#-1]
00007a  f6480380          MOV      r3,#0x8880
00007e  431a              ORRS     r2,r2,r3
000080  6382              STR      r2,[r0,#0x38]
000082  1c76              ADDS     r6,r6,#1
;;;955            tCAN->IF[u32MsgIfNum].CREQ   = 1ul + u32MsgNum;
000084  6206              STR      r6,[r0,#0x20]
;;;956    
;;;957            ReleaseIF(tCAN, u32MsgIfNum);
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       ReleaseIF
                  |L22.140|
;;;958        }
;;;959    
;;;960        return rev;
00008c  4628              MOV      r0,r5
;;;961    }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;962    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;1181     */
;;;1182   int32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;1183   {
000002  4605              MOV      r5,r0
;;;1184       int32_t rev = (int32_t)TRUE;
;;;1185       uint32_t u32Tmp;
;;;1186   
;;;1187       u32Tmp = (tCAN->TEST & CAN_TEST_BASIC_Msk);
000004  6940              LDR      r0,[r0,#0x14]
000006  460e              MOV      r6,r1                 ;1183
000008  2401              MOVS     r4,#1                 ;1184
;;;1188   
;;;1189       if((tCAN->CON & CAN_CON_TEST_Msk) && u32Tmp)
00000a  6829              LDR      r1,[r5,#0]
00000c  f0000004          AND      r0,r0,#4              ;1187
000010  0609              LSLS     r1,r1,#24
000012  d506              BPL      |L23.34|
000014  b128              CBZ      r0,|L23.34|
;;;1190       {
;;;1191           rev = CAN_BasicSendMsg(tCAN, pCanMsg);
000016  4611              MOV      r1,r2
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       CAN_BasicSendMsg
00001e  4604              MOV      r4,r0
000020  e008              B        |L23.52|
                  |L23.34|
;;;1192       }
;;;1193       else
;;;1194       {
;;;1195           if(CAN_SetTxMsg(tCAN, u32MsgNum, pCanMsg) == FALSE)
000022  4631              MOV      r1,r6
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       CAN_SetTxMsg
00002a  b128              CBZ      r0,|L23.56|
;;;1196           {
;;;1197               rev = (int32_t)FALSE;
;;;1198           }
;;;1199           else
;;;1200           {
;;;1201               CAN_TriggerTxMsg(tCAN, u32MsgNum);
00002c  4631              MOV      r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       CAN_TriggerTxMsg
                  |L23.52|
;;;1202           }
;;;1203       }
;;;1204   
;;;1205       return rev;
000034  4620              MOV      r0,r4
;;;1206   }
000036  bd70              POP      {r4-r6,pc}
                  |L23.56|
000038  2400              MOVS     r4,#0                 ;1197
00003a  e7fb              B        |L23.52|
;;;1207   
                          ENDP


                          AREA ||i.CAN_TriggerTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_TriggerTxMsg PROC
;;;972      */
;;;973    int32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum)
000000  b570              PUSH     {r4-r6,lr}
;;;974    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;975        int32_t rev = 1l;
000006  2501              MOVS     r5,#1
;;;976        uint32_t u32MsgIfNum;
;;;977    
;;;978        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000008  f7fffffe          BL       LockIF_TL
00000c  4602              MOV      r2,r0
00000e  2802              CMP      r0,#2
000010  d017              BEQ      |L24.66|
;;;979        {
;;;980            rev = 0; /* return FALSE */
;;;981        }
;;;982        else
;;;983        {
;;;984            tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
000012  6860              LDR      r0,[r4,#4]
000014  f0200008          BIC      r0,r0,#8
000018  6060              STR      r0,[r4,#4]
;;;985    
;;;986            /* read the message contents*/
;;;987            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk
00001a  eb020042          ADD      r0,r2,r2,LSL #1
00001e  eb041040          ADD      r0,r4,r0,LSL #5
000022  210c              MOVS     r1,#0xc
000024  6241              STR      r1,[r0,#0x24]
000026  1c76              ADDS     r6,r6,#1
;;;988                                          | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
;;;989    
;;;990            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u32MsgNum;
000028  6206              STR      r6,[r0,#0x20]
                  |L24.42|
;;;991    
;;;992            while(tCAN->IF[u32MsgIfNum].CREQ & CAN_IF_CREQ_BUSY_Msk)
00002a  6a01              LDR      r1,[r0,#0x20]
00002c  0409              LSLS     r1,r1,#16
00002e  d4fc              BMI      |L24.42|
;;;993            {
;;;994                /*Wait*/
;;;995            }
;;;996            tCAN->IF[u32MsgIfNum].CMASK  = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000030  2184              MOVS     r1,#0x84
000032  6241              STR      r1,[r0,#0x24]
;;;997            tCAN->IF[u32MsgIfNum].CREQ  = 1ul + u32MsgNum;
000034  6206              STR      r6,[r0,#0x20]
;;;998    
;;;999            ReleaseIF(tCAN, u32MsgIfNum);
000036  4611              MOV      r1,r2
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       ReleaseIF
                  |L24.62|
;;;1000       }
;;;1001   
;;;1002       return rev;
00003e  4628              MOV      r0,r5
;;;1003   }
000040  bd70              POP      {r4-r6,pc}
                  |L24.66|
000042  2500              MOVS     r5,#0                 ;980
000044  e7fb              B        |L24.62|
;;;1004   
                          ENDP


                          AREA ||i.CAN_WaitMsg||, CODE, READONLY, ALIGN=1

                  CAN_WaitMsg PROC
;;;259      */
;;;260    void CAN_WaitMsg(CAN_T *tCAN)
000000  2100              MOVS     r1,#0
;;;261    {
;;;262        tCAN->STATUS = 0x0ul; /* clr status */
000002  6041              STR      r1,[r0,#4]
                  |L25.4|
;;;263    
;;;264        while(1)
;;;265        {
;;;266            if(tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk)   /* check new data */
000004  f8d01098          LDR      r1,[r0,#0x98]
000008  0409              LSLS     r1,r1,#16
00000a  d402              BMI      |L25.18|
;;;267            {
;;;268                /* New Data IN */
;;;269                break;
;;;270            }
;;;271            else
;;;272            {
;;;273            }
;;;274    
;;;275            if(tCAN->STATUS & CAN_STATUS_RXOK_Msk)
00000c  6841              LDR      r1,[r0,#4]
;;;276            {
;;;277                /* Rx OK */
;;;278            }
;;;279            else
;;;280            {
;;;281            }
;;;282    
;;;283            if(tCAN->STATUS & CAN_STATUS_LEC_Msk)
00000e  6841              LDR      r1,[r0,#4]
000010  e7f8              B        |L25.4|
                  |L25.18|
;;;284            {
;;;285                /* Error */
;;;286            }
;;;287            else
;;;288            {
;;;289            }
;;;290        }
;;;291    }
000012  4770              BX       lr
;;;292    
                          ENDP


                          AREA ||i.LockIF||, CODE, READONLY, ALIGN=2

                  LockIF PROC
;;;57       */
;;;58     static uint32_t LockIF(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;59     {
;;;60         uint32_t u32CanNo;
;;;61         uint32_t u32FreeIfNo;
;;;62         uint32_t u32IntMask;
;;;63     
;;;64     #if defined(CAN1)
;;;65         u32CanNo = (tCAN == CAN1) ? 1ul : 0ul;
000002  4915              LDR      r1,|L26.88|
000004  4288              CMP      r0,r1
000006  d101              BNE      |L26.12|
000008  2201              MOVS     r2,#1
00000a  e000              B        |L26.14|
                  |L26.12|
00000c  2200              MOVS     r2,#0
                  |L26.14|
;;;66     #else /* defined(CAN0) || defined(CAN) */
;;;67         u32CanNo = 0ul;
;;;68     #endif
;;;69     
;;;70         u32FreeIfNo = 2ul;
;;;71     
;;;72         /* Disable CAN interrupt */
;;;73         u32IntMask = tCAN->CON & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
00000e  6803              LDR      r3,[r0,#0]
000010  2102              MOVS     r1,#2                 ;70
;;;74         tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000012  6804              LDR      r4,[r0,#0]
000014  f003030e          AND      r3,r3,#0xe            ;73
000018  f024040e          BIC      r4,r4,#0xe
00001c  6004              STR      r4,[r0,#0]
;;;75     
;;;76         /* Check interface 1 is available or not */
;;;77         if((tCAN->IF[0ul].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
00001e  6a04              LDR      r4,[r0,#0x20]
000020  f04f0501          MOV      r5,#1                 ;65
000024  0426              LSLS     r6,r4,#16
;;;78         {
;;;79             if(gu8LockCanIf[u32CanNo][0ul] == 0ul)
000026  4c0d              LDR      r4,|L26.92|
000028  d402              BMI      |L26.48|
00002a  f8146012          LDRB     r6,[r4,r2,LSL #1]
00002e  b146              CBZ      r6,|L26.66|
                  |L26.48|
;;;80             {
;;;81                 gu8LockCanIf[u32CanNo][0ul] = 1u;
;;;82                 u32FreeIfNo = 0ul;
;;;83             }
;;;84             else
;;;85             {
;;;86             }
;;;87         }
;;;88         else
;;;89         {
;;;90         }
;;;91     
;;;92         /* Or check interface 2 is available or not */
;;;93         if(u32FreeIfNo == 2ul)
;;;94         {
;;;95             if((tCAN->IF[1ul].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
000030  f8d06080          LDR      r6,[r0,#0x80]
000034  0436              LSLS     r6,r6,#16
000036  d40a              BMI      |L26.78|
;;;96             {
;;;97                 if(gu8LockCanIf[u32CanNo][1ul] == 0ul)
000038  eb040242          ADD      r2,r4,r2,LSL #1
00003c  7854              LDRB     r4,[r2,#1]
00003e  b124              CBZ      r4,|L26.74|
000040  e005              B        |L26.78|
                  |L26.66|
000042  f8045012          STRB     r5,[r4,r2,LSL #1]     ;81
000046  2100              MOVS     r1,#0                 ;82
000048  e001              B        |L26.78|
                  |L26.74|
;;;98                 {
;;;99                     gu8LockCanIf[u32CanNo][1ul] = 1u;
00004a  7055              STRB     r5,[r2,#1]
;;;100                    u32FreeIfNo = 1ul;
00004c  2101              MOVS     r1,#1
                  |L26.78|
;;;101                }
;;;102                else
;;;103                {
;;;104                }
;;;105            }
;;;106            else
;;;107            {
;;;108            }
;;;109        }
;;;110        else
;;;111        {
;;;112        }
;;;113    
;;;114        /* Enable CAN interrupt */
;;;115        tCAN->CON |= u32IntMask;
00004e  6802              LDR      r2,[r0,#0]
000050  431a              ORRS     r2,r2,r3
000052  6002              STR      r2,[r0,#0]
;;;116    
;;;117        return u32FreeIfNo;
000054  4608              MOV      r0,r1
;;;118    }
000056  bd70              POP      {r4-r6,pc}
;;;119    
                          ENDP

                  |L26.88|
                          DCD      0x400a1000
                  |L26.92|
                          DCD      ||.data||

                          AREA ||i.LockIF_TL||, CODE, READONLY, ALIGN=1

                  LockIF_TL PROC
;;;129      */
;;;130    static uint32_t LockIF_TL(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;131    {
000002  4606              MOV      r6,r0
;;;132        uint32_t u32Count;
;;;133        uint32_t u32FreeIfNo;
;;;134    
;;;135        for(u32Count = 0ul; u32Count < RETRY_COUNTS; u32Count++)
000004  2400              MOVS     r4,#0
000006  f04f5580          MOV      r5,#0x10000000
                  |L27.10|
;;;136        {
;;;137            if((u32FreeIfNo = LockIF(tCAN)) != 2ul)
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       LockIF
000010  2802              CMP      r0,#2
000012  d102              BNE      |L27.26|
000014  1c64              ADDS     r4,r4,#1
000016  42ac              CMP      r4,r5                 ;135
000018  d3f7              BCC      |L27.10|
                  |L27.26|
;;;138            {
;;;139                break;
;;;140            }
;;;141            else
;;;142            {
;;;143            }
;;;144        }
;;;145    
;;;146        return u32FreeIfNo;
;;;147    }
00001a  bd70              POP      {r4-r6,pc}
;;;148    
                          ENDP


                          AREA ||i.ReleaseIF||, CODE, READONLY, ALIGN=2

                  ReleaseIF PROC
;;;155      */
;;;156    static void ReleaseIF(CAN_T *tCAN, uint32_t u32IfNo)
000000  b530              PUSH     {r4,r5,lr}
;;;157    {
;;;158        uint32_t u32IntMask;
;;;159        uint32_t u32CanNo;
;;;160    
;;;161        if(u32IfNo >= 2ul)
000002  2902              CMP      r1,#2
000004  d214              BCS      |L28.48|
;;;162        {
;;;163        }
;;;164        else
;;;165        {
;;;166    #if defined(CAN1)
;;;167            u32CanNo = (tCAN == CAN1) ? 1ul : 0ul;
000006  4a0b              LDR      r2,|L28.52|
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L28.16|
00000c  2201              MOVS     r2,#1
00000e  e000              B        |L28.18|
                  |L28.16|
000010  2200              MOVS     r2,#0
                  |L28.18|
;;;168    #else /* defined(CAN0) || defined(CAN) */
;;;169            u32CanNo = 0ul;
;;;170    #endif
;;;171    
;;;172            /* Disable CAN interrupt */
;;;173            u32IntMask = tCAN->CON & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000012  6803              LDR      r3,[r0,#0]
;;;174            tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000014  6804              LDR      r4,[r0,#0]
000016  f003030e          AND      r3,r3,#0xe            ;173
00001a  f024040e          BIC      r4,r4,#0xe
00001e  6004              STR      r4,[r0,#0]
;;;175    
;;;176            gu8LockCanIf[u32CanNo][u32IfNo] = 0u;
000020  4d05              LDR      r5,|L28.56|
000022  2400              MOVS     r4,#0
000024  eb050242          ADD      r2,r5,r2,LSL #1
000028  5454              STRB     r4,[r2,r1]
;;;177    
;;;178            /* Enable CAN interrupt */
;;;179            tCAN->CON |= u32IntMask;
00002a  6801              LDR      r1,[r0,#0]
00002c  4319              ORRS     r1,r1,r3
00002e  6001              STR      r1,[r0,#0]
                  |L28.48|
;;;180        }
;;;181    }
000030  bd30              POP      {r4,r5,pc}
;;;182    
                          ENDP

000032  0000              DCW      0x0000
                  |L28.52|
                          DCD      0x400a1000
                  |L28.56|
                          DCD      ||.data||

                          AREA ||i.can_update_spt||, CODE, READONLY, ALIGN=1

                  can_update_spt PROC
;;;182    
;;;183    static int can_update_spt(int sampl_pt, int tseg, int *tseg1, int *tseg2)
000000  b530              PUSH     {r4,r5,lr}
;;;184    {
;;;185        *tseg2 = tseg + 1 - (sampl_pt * (tseg + 1)) / 1000;
000002  1c4c              ADDS     r4,r1,#1
000004  4360              MULS     r0,r4,r0
000006  f44f757a          MOV      r5,#0x3e8
00000a  fb90f0f5          SDIV     r0,r0,r5
00000e  1a08              SUBS     r0,r1,r0
000010  1c40              ADDS     r0,r0,#1
000012  6018              STR      r0,[r3,#0]            ;184
000014  d009              BEQ      |L29.42|
;;;186        if (*tseg2 < TSEG2_MIN)
;;;187        {
;;;188            *tseg2 = TSEG2_MIN;
;;;189        }
;;;190        else
;;;191        {
;;;192        }
;;;193    
;;;194        if (*tseg2 > TSEG2_MAX)
000016  2808              CMP      r0,#8
000018  d901              BLS      |L29.30|
;;;195        {
;;;196            *tseg2 = TSEG2_MAX;
00001a  2008              MOVS     r0,#8
                  |L29.28|
00001c  6018              STR      r0,[r3,#0]            ;188
                  |L29.30|
;;;197        }
;;;198        else
;;;199        {
;;;200        }
;;;201    
;;;202        *tseg1 = tseg - *tseg2;
00001e  1a08              SUBS     r0,r1,r0
;;;203        if (*tseg1 > TSEG1_MAX)
000020  6010              STR      r0,[r2,#0]
000022  2810              CMP      r0,#0x10
000024  d803              BHI      |L29.46|
;;;204        {
;;;205            *tseg1 = TSEG1_MAX;
;;;206            *tseg2 = tseg - *tseg1;
000026  6818              LDR      r0,[r3,#0]
000028  e006              B        |L29.56|
                  |L29.42|
00002a  2001              MOVS     r0,#1                 ;188
00002c  e7f6              B        |L29.28|
                  |L29.46|
00002e  2010              MOVS     r0,#0x10              ;205
000030  6010              STR      r0,[r2,#0]
000032  f1a10010          SUB      r0,r1,#0x10
000036  6018              STR      r0,[r3,#0]
                  |L29.56|
;;;207        }
;;;208        else
;;;209        {
;;;210        }
;;;211    
;;;212        return 1000 * (tseg + 1 - *tseg2) / (tseg + 1);
000038  1a08              SUBS     r0,r1,r0
00003a  f44f717a          MOV      r1,#0x3e8
00003e  1c40              ADDS     r0,r0,#1
000040  4348              MULS     r0,r1,r0
000042  fb90f0f4          SDIV     r0,r0,r4
;;;213    }
000046  bd30              POP      {r4,r5,pc}
;;;214    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  gu8LockCanIf
000000  00000000          DCB      0x00,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_can_c_0fdded17____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REVSH|
#line 402
|__asm___5_can_c_0fdded17____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____RRX|
#line 587
|__asm___5_can_c_0fdded17____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
