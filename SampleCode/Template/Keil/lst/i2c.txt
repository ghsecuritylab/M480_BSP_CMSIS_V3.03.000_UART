; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;97       */
;;;98     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;99     {
;;;100        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  6141              STR      r1,[r0,#0x14]
;;;101    }
000008  4770              BX       lr
;;;102    
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;69     
;;;70     void I2C_Close(I2C_T *i2c)
000000  4a0d              LDR      r2,|L2.56|
;;;71     {
;;;72         /* Reset I2C Controller */
;;;73         if((uint32_t)i2c == I2C0_BASE)
;;;74         {
;;;75             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  02d1              LSLS     r1,r2,#11
000004  4290              CMP      r0,r2                 ;73
000006  d107              BNE      |L2.24|
000008  68ca              LDR      r2,[r1,#0xc]
00000a  f4427280          ORR      r2,r2,#0x100
00000e  60ca              STR      r2,[r1,#0xc]
;;;76             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
000010  68ca              LDR      r2,[r1,#0xc]
000012  f4227280          BIC      r2,r2,#0x100
000016  e009              B        |L2.44|
                  |L2.24|
;;;77         }
;;;78         else if((uint32_t)i2c == I2C1_BASE)
000018  4a08              LDR      r2,|L2.60|
00001a  4290              CMP      r0,r2
00001c  d107              BNE      |L2.46|
;;;79         {
;;;80             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
00001e  68ca              LDR      r2,[r1,#0xc]
000020  f4427200          ORR      r2,r2,#0x200
000024  60ca              STR      r2,[r1,#0xc]
;;;81             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
000026  68ca              LDR      r2,[r1,#0xc]
000028  f4227200          BIC      r2,r2,#0x200
                  |L2.44|
00002c  60ca              STR      r2,[r1,#0xc]
                  |L2.46|
;;;82         }
;;;83     
;;;84         /* Disable I2C */
;;;85         i2c->CTL0 &= ~I2C_CTL0_I2CEN_Msk;
00002e  6801              LDR      r1,[r0,#0]
000030  f0210140          BIC      r1,r1,#0x40
000034  6001              STR      r1,[r0,#0]
;;;86     }
000036  4770              BX       lr
;;;87     
                          ENDP

                  |L2.56|
                          DCD      0x40080000
                  |L2.60|
                          DCD      0x40081000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;153      */
;;;154    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;155    {
;;;156        i2c->CTL0 &= ~I2C_CTL0_INTEN_Msk;
000002  f0210180          BIC      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;157    }
000008  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;399     */
;;;400    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;401    {
;;;402        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  f0210104          BIC      r1,r1,#4
000006  6141              STR      r1,[r0,#0x14]
;;;403    }
000008  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;429     */
;;;430    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;431    {
;;;432        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;433    }
000008  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;168      */
;;;169    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171        i2c->CTL0 |= I2C_CTL0_INTEN_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;172    }
000008  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;375     */
;;;376    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2900              CMP      r1,#0
;;;377    {
;;;378        if(u8LongTimeout)
;;;379        {
;;;380            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;381        }
;;;382        else
;;;383        {
;;;384            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L7.12|
000006  f0410102          ORR      r1,r1,#2              ;380
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L7.16|
000010  6141              STR      r1,[r0,#0x14]
;;;385        }
;;;386    
;;;387        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000012  6941              LDR      r1,[r0,#0x14]
000014  f0410104          ORR      r1,r1,#4
000018  6141              STR      r1,[r0,#0x14]
;;;388    }
00001a  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;414     */
;;;415    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;416    {
;;;417        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;418    }
000008  4770              BX       lr
;;;419    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;182     */
;;;183    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        uint32_t u32Divider = i2c->CLKDIV;
000002  6904              LDR      r4,[r0,#0x10]
;;;186        uint32_t u32Pclk;
;;;187    
;;;188        if(i2c == I2C1)
000004  4906              LDR      r1,|L9.32|
000006  4288              CMP      r0,r1
000008  d102              BNE      |L9.16|
;;;189        {
;;;190            u32Pclk = CLK_GetPCLK1Freq();
00000a  f7fffffe          BL       CLK_GetPCLK1Freq
00000e  e001              B        |L9.20|
                  |L9.16|
;;;191        }
;;;192        else
;;;193        {
;;;194            u32Pclk = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.20|
;;;195        }
;;;196    
;;;197        return (u32Pclk / ((u32Divider + 1U) << 2U));
000014  00a1              LSLS     r1,r4,#2
000016  1d09              ADDS     r1,r1,#4
000018  fbb0f0f1          UDIV     r0,r0,r1
;;;198    }
00001c  bd10              POP      {r4,pc}
;;;199    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40081000

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;277     */
;;;278    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;279    {
;;;280        return (uint8_t)(i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;281    }
000004  4770              BX       lr
;;;282    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;238     */
;;;239    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;240    {
;;;241        uint32_t u32Value;
;;;242    
;;;243        if((i2c->CTL0 & I2C_CTL0_SI_Msk) == I2C_CTL0_SI_Msk)
000002  0700              LSLS     r0,r0,#28
000004  d501              BPL      |L11.10|
;;;244        {
;;;245            u32Value = 1U;
000006  2001              MOVS     r0,#1
;;;246        }
;;;247        else
;;;248        {
;;;249            u32Value = 0U;
;;;250        }
;;;251    
;;;252        return u32Value;
;;;253    }
000008  4770              BX       lr
                  |L11.10|
00000a  2000              MOVS     r0,#0                 ;249
00000c  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;263     */
;;;264    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;265    {
;;;266        return (i2c->STATUS0);
;;;267    }
000002  4770              BX       lr
;;;268    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;35       */
;;;36     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4604              MOV      r4,r0
;;;38         uint32_t u32Div;
;;;39         uint32_t u32Pclk;
;;;40     
;;;41         if(i2c == I2C1)
000004  480e              LDR      r0,|L13.64|
000006  460d              MOV      r5,r1                 ;37
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L13.18|
;;;42         {
;;;43             u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;44         }
;;;45         else
;;;46         {
;;;47             u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.22|
;;;48         }
;;;49     
;;;50         u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000016  eb000180          ADD      r1,r0,r0,LSL #2
00001a  0049              LSLS     r1,r1,#1
00001c  00aa              LSLS     r2,r5,#2
00001e  fbb1f1f2          UDIV     r1,r1,r2
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
00002a  1e4a              SUBS     r2,r1,#1
;;;51         i2c->CLKDIV = u32Div;
00002c  6122              STR      r2,[r4,#0x10]
;;;52     
;;;53         /* Enable I2C */
;;;54         i2c->CTL0 |= I2C_CTL0_I2CEN_Msk;
00002e  6822              LDR      r2,[r4,#0]
000030  f0420240          ORR      r2,r2,#0x40
000034  6022              STR      r2,[r4,#0]
;;;55     
;;;56         return (u32Pclk / ((u32Div + 1U) << 2U));
;;;57     }
000036  0089              LSLS     r1,r1,#2
000038  fbb0f0f1          UDIV     r0,r0,r1              ;56
00003c  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

00003e  0000              DCW      0x0000
                  |L13.64|
                          DCD      0x40081000

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;1042     */
;;;1043   uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;1044   {
;;;1045       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Ctrl = 0u;
000002  2401              MOVS     r4,#1
000004  2200              MOVS     r2,#0
;;;1046   
;;;1047       I2C_START(i2c);                                                /* Send START */
000006  6805              LDR      r5,[r0,#0]
000008  4613              MOV      r3,r2                 ;1045
00000a  f0250508          BIC      r5,r5,#8
00000e  f0450520          ORR      r5,r5,#0x20
000012  6005              STR      r5,[r0,#0]
;;;1048       while(u8Xfering && (u8Err == 0u))
;;;1049       {
;;;1050           I2C_WAIT_READY(i2c) {}
;;;1051           switch(I2C_GET_STATUS(i2c))
;;;1052           {
;;;1053           case 0x08u:
;;;1054               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
000014  eb040141          ADD      r1,r4,r1,LSL #1
000018  b2ce              UXTB     r6,r1
                  |L14.26|
00001a  6801              LDR      r1,[r0,#0]            ;1050
00001c  0709              LSLS     r1,r1,#28             ;1050
00001e  d5fc              BPL      |L14.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1051
000022  2908              CMP      r1,#8                 ;1051
000024  d008              BEQ      |L14.56|
000026  2940              CMP      r1,#0x40              ;1051
000028  d007              BEQ      |L14.58|
00002a  2948              CMP      r1,#0x48              ;1051
00002c  d001              BEQ      |L14.50|
00002e  2958              CMP      r1,#0x58              ;1051
000030  d005              BEQ      |L14.62|
                  |L14.50|
;;;1055               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1056               break;
;;;1057           case 0x40u:                                             /* Slave Address ACK */
;;;1058               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1059               break;
;;;1060           case 0x48u:                                             /* Slave Address NACK */
;;;1061               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000032  2118              MOVS     r1,#0x18
;;;1062               u8Err = 1u;
000034  2201              MOVS     r2,#1
;;;1063               break;
000036  e006              B        |L14.70|
                  |L14.56|
000038  6086              STR      r6,[r0,#8]            ;1054
                  |L14.58|
00003a  2108              MOVS     r1,#8                 ;1058
00003c  e003              B        |L14.70|
                  |L14.62|
;;;1064           case 0x58u:
;;;1065               rdata = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
00003e  6881              LDR      r1,[r0,#8]
000040  b2cb              UXTB     r3,r1
;;;1066               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2118              MOVS     r1,#0x18
;;;1067               u8Xfering = 0u;
000044  2400              MOVS     r4,#0
                  |L14.70|
;;;1068               break;
;;;1069           case 0x38u:                                             /* Arbitration Lost */
;;;1070           default:                                               /* Unknow status */
;;;1071               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1072               u8Err = 1u;
;;;1073               break;
;;;1074           }
;;;1075           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000046  6805              LDR      r5,[r0,#0]
000048  f025053c          BIC      r5,r5,#0x3c
00004c  430d              ORRS     r5,r5,r1
00004e  6005              STR      r5,[r0,#0]
000050  b114              CBZ      r4,|L14.88|
000052  2a00              CMP      r2,#0                 ;1048
000054  d0e1              BEQ      |L14.26|
000056  e000              B        |L14.90|
                  |L14.88|
;;;1076       }
;;;1077       if(u8Err)
000058  b102              CBZ      r2,|L14.92|
                  |L14.90|
;;;1078       {
;;;1079           rdata = 0u;                                                 /* If occurs error, return 0 */
00005a  2300              MOVS     r3,#0
                  |L14.92|
;;;1080       }
;;;1081       return rdata;                                                  /* Return read data */
00005c  4618              MOV      r0,r3
;;;1082   }
00005e  bd70              POP      {r4-r6,pc}
;;;1083   
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;1161     */
;;;1162   uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1163   {
;;;1164       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2400              MOVS     r4,#0
;;;1165   
;;;1166       I2C_START(i2c);                                                /* Send START */
000006  6805              LDR      r5,[r0,#0]
000008  4626              MOV      r6,r4                 ;1164
00000a  4623              MOV      r3,r4                 ;1164
00000c  f0250508          BIC      r5,r5,#8
000010  f0450520          ORR      r5,r5,#0x20
000014  6005              STR      r5,[r0,#0]
                  |L15.22|
;;;1167       while(u8Xfering && (u8Err == 0u))
;;;1168       {
;;;1169           I2C_WAIT_READY(i2c) {}
000016  6805              LDR      r5,[r0,#0]
000018  072d              LSLS     r5,r5,#28
00001a  d5fc              BPL      |L15.22|
;;;1170           switch(I2C_GET_STATUS(i2c))
00001c  68c5              LDR      r5,[r0,#0xc]
00001e  f0150f07          TST      r5,#7
000022  d10e              BNE      |L15.66|
000024  10ed              ASRS     r5,r5,#3
000026  2d0c              CMP      r5,#0xc
000028  d20b              BCS      |L15.66|
00002a  e8dff005          TBB      [pc,r5]
00002e  0a06              DCB      0x0a,0x06
000030  0f080a0d          DCB      0x0f,0x08,0x0a,0x0d
000034  0a0a140a          DCB      0x0a,0x0a,0x14,0x0a
000038  0a16              DCB      0x0a,0x16
;;;1171           {
;;;1172           case 0x08u:
;;;1173               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));      /* Write SLA+W to Register I2CDAT */
00003a  004b              LSLS     r3,r1,#1
;;;1174               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1175               break;
00003c  e009              B        |L15.82|
;;;1176           case 0x18u:                                             /* Slave Address ACK */
;;;1177               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003e  6082              STR      r2,[r0,#8]
;;;1178               break;
000040  e00f              B        |L15.98|
                  |L15.66|
;;;1179           case 0x20u:                                             /* Slave Address NACK */
;;;1180           case 0x30u:                                             /* Master transmit data NACK */
;;;1181               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2318              MOVS     r3,#0x18
;;;1182               u8Err = 1u;
000044  2401              MOVS     r4,#1
;;;1183               break;
000046  e00c              B        |L15.98|
;;;1184           case 0x28u:
;;;1185               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2328              MOVS     r3,#0x28
;;;1186               break;
00004a  e00a              B        |L15.98|
;;;1187           case 0x10u:
;;;1188               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
00004c  2301              MOVS     r3,#1
00004e  eb030341          ADD      r3,r3,r1,LSL #1
                  |L15.82|
000052  b2db              UXTB     r3,r3                 ;1173
000054  6083              STR      r3,[r0,#8]            ;1173
;;;1189               u8Ctrl = I2C_CTL_SI;                               /* Clear SI */
;;;1190               break;
;;;1191           case 0x40u:                                             /* Slave Address ACK */
;;;1192               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
000056  2308              MOVS     r3,#8
;;;1193               break;
000058  e003              B        |L15.98|
;;;1194           case 0x48u:                                             /* Slave Address NACK */
;;;1195               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1196               u8Err = 1u;
;;;1197               break;
;;;1198           case 0x58u:
;;;1199               rdata = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
00005a  6883              LDR      r3,[r0,#8]
00005c  b2de              UXTB     r6,r3
;;;1200               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
00005e  2318              MOVS     r3,#0x18
;;;1201               u8Xfering = 0u;
000060  2700              MOVS     r7,#0
                  |L15.98|
;;;1202               break;
;;;1203           case 0x38u:                                             /* Arbitration Lost */
;;;1204           default:                                               /* Unknow status */
;;;1205               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1206               u8Err = 1u;
;;;1207               break;
;;;1208           }
;;;1209           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000062  6805              LDR      r5,[r0,#0]
000064  f025053c          BIC      r5,r5,#0x3c
000068  431d              ORRS     r5,r5,r3
00006a  6005              STR      r5,[r0,#0]
00006c  b117              CBZ      r7,|L15.116|
00006e  2c00              CMP      r4,#0                 ;1167
000070  d0d1              BEQ      |L15.22|
000072  e000              B        |L15.118|
                  |L15.116|
;;;1210       }
;;;1211       if(u8Err)
000074  b104              CBZ      r4,|L15.120|
                  |L15.118|
;;;1212       {
;;;1213           rdata = 0u;                                                 /* If occurs error, return 0 */
000076  2600              MOVS     r6,#0
                  |L15.120|
;;;1214       }
;;;1215       return rdata;                                                  /* Return read data */
000078  4630              MOV      r0,r6
;;;1216   }
00007a  bdf0              POP      {r4-r7,pc}
;;;1217   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1309     */
;;;1310   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1311   {
;;;1312       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Addr = 1u, u8Ctrl = 0u;
000002  2400              MOVS     r4,#0
000004  f04f0c01          MOV      r12,#1
;;;1313   
;;;1314       I2C_START(i2c);                                                         /* Send START */
000008  6805              LDR      r5,[r0,#0]
00000a  4626              MOV      r6,r4                 ;1312
00000c  4667              MOV      r7,r12                ;1312
00000e  4623              MOV      r3,r4                 ;1312
000010  f0250508          BIC      r5,r5,#8
000014  f0450520          ORR      r5,r5,#0x20
000018  6005              STR      r5,[r0,#0]
                  |L16.26|
;;;1315       while(u8Xfering && (u8Err == 0u))
;;;1316       {
;;;1317           I2C_WAIT_READY(i2c) {}
00001a  6805              LDR      r5,[r0,#0]
00001c  072d              LSLS     r5,r5,#28
00001e  d5fc              BPL      |L16.26|
;;;1318           switch(I2C_GET_STATUS(i2c))
000020  68c5              LDR      r5,[r0,#0xc]
000022  f0150f07          TST      r5,#7
000026  d10f              BNE      |L16.72|
000028  10ed              ASRS     r5,r5,#3
00002a  2d0c              CMP      r5,#0xc
00002c  d20c              BCS      |L16.72|
00002e  e8dff005          TBB      [pc,r5]
000032  0b06              DCB      0x0b,0x06
000034  15080b0e          DCB      0x15,0x08,0x0b,0x0e
000038  0b0b1a0b          DCB      0x0b,0x0b,0x1a,0x0b
00003c  0b1c              DCB      0x0b,0x1c
;;;1319           {
;;;1320           case 0x08u:
;;;1321               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
00003e  004b              LSLS     r3,r1,#1
;;;1322               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1323               break;
000040  e00f              B        |L16.98|
;;;1324           case 0x18u:                                                      /* Slave Address ACK */
;;;1325               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
000042  0a15              LSRS     r5,r2,#8
000044  6085              STR      r5,[r0,#8]
;;;1326               break;
000046  e015              B        |L16.116|
                  |L16.72|
;;;1327           case 0x20u:                                                      /* Slave Address NACK */
;;;1328           case 0x30u:                                                      /* Master transmit data NACK */
;;;1329               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000048  2318              MOVS     r3,#0x18
;;;1330               u8Err = 1u;
00004a  2401              MOVS     r4,#1
;;;1331               break;
00004c  e012              B        |L16.116|
;;;1332           case 0x28u:
;;;1333               if(u8Addr)
00004e  b11f              CBZ      r7,|L16.88|
;;;1334               {
;;;1335                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
000050  b2d5              UXTB     r5,r2
000052  6085              STR      r5,[r0,#8]
;;;1336                   u8Addr = 0u;
000054  2700              MOVS     r7,#0
000056  e00d              B        |L16.116|
                  |L16.88|
;;;1337               }
;;;1338               else
;;;1339               {
;;;1340                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000058  2328              MOVS     r3,#0x28
00005a  e00b              B        |L16.116|
;;;1341               }
;;;1342               break;
;;;1343           case 0x10u:
;;;1344               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));             /* Write SLA+R to Register I2CDAT */
00005c  2301              MOVS     r3,#1
00005e  eb030341          ADD      r3,r3,r1,LSL #1
                  |L16.98|
000062  b2db              UXTB     r3,r3                 ;1321
000064  6083              STR      r3,[r0,#8]            ;1321
;;;1345               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1346               break;
;;;1347           case 0x40u:                                                      /* Slave Address ACK */
;;;1348               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
000066  2308              MOVS     r3,#8
;;;1349               break;
000068  e004              B        |L16.116|
;;;1350           case 0x48u:                                                      /* Slave Address NACK */
;;;1351               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1352               u8Err = 1u;
;;;1353               break;
;;;1354           case 0x58u:
;;;1355               rdata = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
00006a  6883              LDR      r3,[r0,#8]
;;;1356               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1357               u8Xfering = 0u;
00006c  f04f0c00          MOV      r12,#0
000070  b2de              UXTB     r6,r3                 ;1355
000072  2318              MOVS     r3,#0x18              ;1356
                  |L16.116|
;;;1358               break;
;;;1359           case 0x38u:                                                      /* Arbitration Lost */
;;;1360           default:                                                        /* Unknow status */
;;;1361               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1362               u8Err = 1u;
;;;1363               break;
;;;1364           }
;;;1365           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000074  6805              LDR      r5,[r0,#0]
000076  f025053c          BIC      r5,r5,#0x3c
00007a  431d              ORRS     r5,r5,r3
00007c  6005              STR      r5,[r0,#0]
00007e  f1bc0f00          CMP      r12,#0                ;1315
000082  d002              BEQ      |L16.138|
000084  2c00              CMP      r4,#0                 ;1315
000086  d0c8              BEQ      |L16.26|
000088  e000              B        |L16.140|
                  |L16.138|
;;;1366       }
;;;1367       if(u8Err)
00008a  b104              CBZ      r4,|L16.142|
                  |L16.140|
;;;1368       {
;;;1369           rdata = 0u;                                                          /* If occurs error, return 0 */
00008c  2600              MOVS     r6,#0
                  |L16.142|
;;;1370       }
;;;1371       return rdata;                                                           /* Return read data */
00008e  4630              MOV      r0,r6
;;;1372   }
000090  bdf0              POP      {r4-r7,pc}
;;;1373   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;1098     */
;;;1099   uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1100   {
;;;1101       uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2600              MOVS     r6,#0
;;;1102       uint32_t u32rxLen = 0u;
;;;1103   
;;;1104       I2C_START(i2c);                                                /* Send START */
000006  6805              LDR      r5,[r0,#0]
000008  4634              MOV      r4,r6                 ;1102
00000a  f0250508          BIC      r5,r5,#8
00000e  f0450520          ORR      r5,r5,#0x20
000012  6005              STR      r5,[r0,#0]
                  |L17.20|
;;;1105       while(u8Xfering && (u8Err == 0u))
;;;1106       {
;;;1107           I2C_WAIT_READY(i2c) {}
000014  6805              LDR      r5,[r0,#0]
000016  072d              LSLS     r5,r5,#28
000018  d5fc              BPL      |L17.20|
;;;1108           switch(I2C_GET_STATUS(i2c))
00001a  68c5              LDR      r5,[r0,#0xc]
00001c  2d48              CMP      r5,#0x48
00001e  d009              BEQ      |L17.52|
000020  dc04              BGT      |L17.44|
000022  2d08              CMP      r5,#8
000024  d009              BEQ      |L17.58|
000026  2d40              CMP      r5,#0x40
000028  d104              BNE      |L17.52|
00002a  e012              B        |L17.82|
                  |L17.44|
00002c  2d50              CMP      r5,#0x50
00002e  d00a              BEQ      |L17.70|
000030  2d58              CMP      r5,#0x58
000032  d012              BEQ      |L17.90|
                  |L17.52|
;;;1109           {
;;;1110           case 0x08u:
;;;1111               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
;;;1112               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1113               break;
;;;1114           case 0x40u:                                             /* Slave Address ACK */
;;;1115               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1116               break;
;;;1117           case 0x48u:                                             /* Slave Address NACK */
;;;1118               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000034  2518              MOVS     r5,#0x18
;;;1119               u8Err = 1u;
000036  2601              MOVS     r6,#1
;;;1120               break;
000038  e014              B        |L17.100|
                  |L17.58|
00003a  2501              MOVS     r5,#1                 ;1111
00003c  eb050541          ADD      r5,r5,r1,LSL #1       ;1111
000040  b2ed              UXTB     r5,r5                 ;1111
000042  6085              STR      r5,[r0,#8]            ;1111
000044  e007              B        |L17.86|
                  |L17.70|
;;;1121           case 0x50u:
;;;1122               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
000046  6885              LDR      r5,[r0,#8]
000048  5515              STRB     r5,[r2,r4]
;;;1123               if(u32rxLen < (u32rLen - 1u))
00004a  1e5d              SUBS     r5,r3,#1
00004c  1c64              ADDS     r4,r4,#1
00004e  42ac              CMP      r4,r5
000050  d201              BCS      |L17.86|
                  |L17.82|
;;;1124               {
;;;1125                   u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
000052  250c              MOVS     r5,#0xc
000054  e006              B        |L17.100|
                  |L17.86|
;;;1126               }
;;;1127               else
;;;1128               {
;;;1129                   u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
000056  2508              MOVS     r5,#8
000058  e004              B        |L17.100|
                  |L17.90|
;;;1130               }
;;;1131               break;
;;;1132           case 0x58u:
;;;1133               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
00005a  6885              LDR      r5,[r0,#8]
00005c  5515              STRB     r5,[r2,r4]
;;;1134               u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
00005e  2518              MOVS     r5,#0x18
;;;1135               u8Xfering = 0u;
000060  2700              MOVS     r7,#0
000062  1c64              ADDS     r4,r4,#1
                  |L17.100|
;;;1136               break;
;;;1137           case 0x38u:                                                    /* Arbitration Lost */
;;;1138           default:                                                      /* Unknow status */
;;;1139               u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1140               u8Err = 1u;
;;;1141               break;
;;;1142           }
;;;1143           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
000064  f8d0c000          LDR      r12,[r0,#0]
000068  f02c0c3c          BIC      r12,r12,#0x3c
00006c  ea4c0c05          ORR      r12,r12,r5
000070  f8c0c000          STR      r12,[r0,#0]
000074  b10f              CBZ      r7,|L17.122|
000076  2e00              CMP      r6,#0                 ;1105
000078  d0cc              BEQ      |L17.20|
                  |L17.122|
;;;1144       }
;;;1145       return u32rxLen;                                                      /* Return bytes length that have been received */
00007a  4620              MOV      r0,r4
;;;1146   }
00007c  bdf0              POP      {r4-r7,pc}
;;;1147   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1232     */
;;;1233   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1234   {
;;;1235       uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000004  2600              MOVS     r6,#0
;;;1236       uint32_t u32rxLen = 0u;
;;;1237   
;;;1238       I2C_START(i2c);                                                /* Send START */
000006  f8dd901c          LDR      r9,[sp,#0x1c]
00000a  6807              LDR      r7,[r0,#0]
00000c  f04f0c01          MOV      r12,#1                ;1235
000010  4634              MOV      r4,r6                 ;1235
000012  4635              MOV      r5,r6                 ;1236
000014  f0270708          BIC      r7,r7,#8
000018  f0470720          ORR      r7,r7,#0x20
00001c  6007              STR      r7,[r0,#0]
                  |L18.30|
;;;1239       while(u8Xfering && (u8Err == 0u))
;;;1240       {
;;;1241           I2C_WAIT_READY(i2c) {}
00001e  6807              LDR      r7,[r0,#0]
000020  073f              LSLS     r7,r7,#28
000022  d5fc              BPL      |L18.30|
;;;1242           switch(I2C_GET_STATUS(i2c))
000024  68c7              LDR      r7,[r0,#0xc]
000026  f0170f07          TST      r7,#7
00002a  d10e              BNE      |L18.74|
00002c  10ff              ASRS     r7,r7,#3
00002e  2f0c              CMP      r7,#0xc
000030  d20b              BCS      |L18.74|
000032  e8dff007          TBB      [pc,r7]
000036  0a06              DCB      0x0a,0x06
000038  0f080a0d          DCB      0x0f,0x08,0x0a,0x0d
00003c  0a0a1c0a          DCB      0x0a,0x0a,0x1c,0x0a
000040  1520              DCB      0x15,0x20
;;;1243           {
;;;1244           case 0x08u:
;;;1245               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));      /* Write SLA+W to Register I2CDAT */
000042  004c              LSLS     r4,r1,#1
;;;1246               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1247               break;
000044  e009              B        |L18.90|
;;;1248           case 0x18u:                                             /* Slave Address ACK */
;;;1249               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
000046  6082              STR      r2,[r0,#8]
;;;1250               break;
000048  e01b              B        |L18.130|
                  |L18.74|
;;;1251           case 0x20u:                                             /* Slave Address NACK */
;;;1252           case 0x30u:                                             /* Master transmit data NACK */
;;;1253               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
00004a  2418              MOVS     r4,#0x18
;;;1254               u8Err = 1u;
00004c  2601              MOVS     r6,#1
;;;1255               break;
00004e  e018              B        |L18.130|
;;;1256           case 0x28u:
;;;1257               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000050  2428              MOVS     r4,#0x28
;;;1258               break;
000052  e016              B        |L18.130|
;;;1259           case 0x10u:
;;;1260               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
000054  2401              MOVS     r4,#1
000056  eb040441          ADD      r4,r4,r1,LSL #1
                  |L18.90|
00005a  b2e4              UXTB     r4,r4
00005c  6084              STR      r4,[r0,#8]
00005e  e008              B        |L18.114|
;;;1261               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1262               break;
;;;1263           case 0x40u:                                             /* Slave Address ACK */
;;;1264               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1265               break;
;;;1266           case 0x48u:                                             /* Slave Address NACK */
;;;1267               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1268               u8Err = 1u;
;;;1269               break;
;;;1270           case 0x50u:
;;;1271               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000060  6884              LDR      r4,[r0,#8]
000062  555c              STRB     r4,[r3,r5]
;;;1272               if(u32rxLen < (u32rLen - 1u))
000064  f1a90401          SUB      r4,r9,#1
000068  1c6d              ADDS     r5,r5,#1
00006a  42a5              CMP      r5,r4
00006c  d201              BCS      |L18.114|
;;;1273               {
;;;1274                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
00006e  240c              MOVS     r4,#0xc
000070  e007              B        |L18.130|
                  |L18.114|
;;;1275               }
;;;1276               else
;;;1277               {
;;;1278                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000072  2408              MOVS     r4,#8
000074  e005              B        |L18.130|
;;;1279               }
;;;1280               break;
;;;1281           case 0x58u:
;;;1282               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000076  6884              LDR      r4,[r0,#8]
000078  555c              STRB     r4,[r3,r5]
;;;1283               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
00007a  2418              MOVS     r4,#0x18
;;;1284               u8Xfering = 0u;
00007c  f04f0c00          MOV      r12,#0
000080  1c6d              ADDS     r5,r5,#1
                  |L18.130|
;;;1285               break;
;;;1286           case 0x38u:                                             /* Arbitration Lost */
;;;1287           default:                                               /* Unknow status */
;;;1288               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1289               u8Err = 1u;
;;;1290               break;
;;;1291           }
;;;1292           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000082  6807              LDR      r7,[r0,#0]
000084  f027073c          BIC      r7,r7,#0x3c
000088  4327              ORRS     r7,r7,r4
00008a  6007              STR      r7,[r0,#0]
00008c  f1bc0f00          CMP      r12,#0                ;1239
000090  d001              BEQ      |L18.150|
000092  2e00              CMP      r6,#0                 ;1239
000094  d0c3              BEQ      |L18.30|
                  |L18.150|
;;;1293       }
;;;1294       return u32rxLen;                                               /* Return bytes length that have been received */
000096  4628              MOV      r0,r5
;;;1295   }
000098  e8bd83f0          POP      {r4-r9,pc}
;;;1296   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1388     */
;;;1389   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1390   {
;;;1391       uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2500              MOVS     r5,#0
000006  4691              MOV      r9,r2                 ;1390
000008  f04f0c01          MOV      r12,#1
;;;1392       uint32_t u32rxLen = 0u;
;;;1393   
;;;1394       I2C_START(i2c);                                                         /* Send START */
00000c  f8dda020          LDR      r10,[sp,#0x20]
000010  6806              LDR      r6,[r0,#0]
000012  4667              MOV      r7,r12                ;1391
000014  462a              MOV      r2,r5                 ;1391
000016  462c              MOV      r4,r5                 ;1392
000018  f0260608          BIC      r6,r6,#8
00001c  f0460620          ORR      r6,r6,#0x20
000020  6006              STR      r6,[r0,#0]
                  |L19.34|
;;;1395       while(u8Xfering && (u8Err == 0u))
;;;1396       {
;;;1397           I2C_WAIT_READY(i2c) {}
000022  6806              LDR      r6,[r0,#0]
000024  0736              LSLS     r6,r6,#28
000026  d5fc              BPL      |L19.34|
;;;1398           switch(I2C_GET_STATUS(i2c))
000028  68c6              LDR      r6,[r0,#0xc]
00002a  f0160f07          TST      r6,#7
00002e  d110              BNE      |L19.82|
000030  10f6              ASRS     r6,r6,#3
000032  2e0c              CMP      r6,#0xc
000034  d20d              BCS      |L19.82|
000036  e8dff006          TBB      [pc,r6]
00003a  0c06              DCB      0x0c,0x06
00003c  17080c0f          DCB      0x17,0x08,0x0c,0x0f
000040  0c0c240c          DCB      0x0c,0x0c,0x24,0x0c
000044  1d28              DCB      0x1d,0x28
;;;1399           {
;;;1400           case 0x08u:
;;;1401               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
000046  004a              LSLS     r2,r1,#1
;;;1402               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1403               break;
000048  e011              B        |L19.110|
;;;1404           case 0x18u:                                                      /* Slave Address ACK */
;;;1405               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
00004a  ea4f2619          LSR      r6,r9,#8
00004e  6086              STR      r6,[r0,#8]
;;;1406               break;
000050  e021              B        |L19.150|
                  |L19.82|
;;;1407           case 0x20u:                                                      /* Slave Address NACK */
;;;1408           case 0x30u:                                                      /* Master transmit data NACK */
;;;1409               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000052  2218              MOVS     r2,#0x18
;;;1410               u8Err = 1u;
000054  2501              MOVS     r5,#1
;;;1411               break;
000056  e01e              B        |L19.150|
;;;1412           case 0x28u:
;;;1413               if(u8Addr)
000058  b127              CBZ      r7,|L19.100|
;;;1414               {
;;;1415                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
00005a  f00906ff          AND      r6,r9,#0xff
00005e  6086              STR      r6,[r0,#8]
;;;1416                   u8Addr = 0u;
000060  2700              MOVS     r7,#0
000062  e018              B        |L19.150|
                  |L19.100|
;;;1417               }
;;;1418               else
;;;1419               {
;;;1420                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000064  2228              MOVS     r2,#0x28
000066  e016              B        |L19.150|
;;;1421               }
;;;1422               break;
;;;1423           case 0x10u:
;;;1424               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));             /* Write SLA+R to Register I2CDAT */
000068  2201              MOVS     r2,#1
00006a  eb020241          ADD      r2,r2,r1,LSL #1
                  |L19.110|
00006e  b2d2              UXTB     r2,r2
000070  6082              STR      r2,[r0,#8]
000072  e008              B        |L19.134|
;;;1425               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1426               break;
;;;1427           case 0x40u:                                                      /* Slave Address ACK */
;;;1428               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1429               break;
;;;1430           case 0x48u:                                                      /* Slave Address NACK */
;;;1431               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1432               u8Err = 1u;
;;;1433               break;
;;;1434           case 0x50u:
;;;1435               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000074  6882              LDR      r2,[r0,#8]
000076  551a              STRB     r2,[r3,r4]
;;;1436               if(u32rxLen < (u32rLen - 1u))
000078  f1aa0201          SUB      r2,r10,#1
00007c  1c64              ADDS     r4,r4,#1
00007e  4294              CMP      r4,r2
000080  d201              BCS      |L19.134|
;;;1437               {
;;;1438                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
000082  220c              MOVS     r2,#0xc
000084  e007              B        |L19.150|
                  |L19.134|
;;;1439               }
;;;1440               else
;;;1441               {
;;;1442                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
000086  2208              MOVS     r2,#8
000088  e005              B        |L19.150|
;;;1443               }
;;;1444               break;
;;;1445           case 0x58u:
;;;1446               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
00008a  6882              LDR      r2,[r0,#8]
00008c  551a              STRB     r2,[r3,r4]
;;;1447               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00008e  2218              MOVS     r2,#0x18
;;;1448               u8Xfering = 0u;
000090  f04f0c00          MOV      r12,#0
000094  1c64              ADDS     r4,r4,#1
                  |L19.150|
;;;1449               break;
;;;1450           case 0x38u:                                                      /* Arbitration Lost */
;;;1451           default:                                                        /* Unknow status */
;;;1452               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1453               u8Err = 1u;
;;;1454               break;
;;;1455           }
;;;1456           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000096  6806              LDR      r6,[r0,#0]
000098  f026063c          BIC      r6,r6,#0x3c
00009c  4316              ORRS     r6,r6,r2
00009e  6006              STR      r6,[r0,#0]
0000a0  f1bc0f00          CMP      r12,#0                ;1395
0000a4  d001              BEQ      |L19.170|
0000a6  2d00              CMP      r5,#0                 ;1395
0000a8  d0bb              BEQ      |L19.34|
                  |L19.170|
;;;1457       }
;;;1458       return u32rxLen;                                                        /* Return bytes length that have been received */
0000aa  4620              MOV      r0,r4
;;;1459   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;1460   
                          ENDP


                          AREA ||i.I2C_SMBusClearInterruptFlag||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClearInterruptFlag PROC
;;;460     */
;;;461    void I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8SMBusIntFlag)
000000  6581              STR      r1,[r0,#0x58]
;;;462    {
;;;463        i2c->BUSSTS = u8SMBusIntFlag;
;;;464    }
000002  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.I2C_SMBusClockLoTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClockLoTimeout PROC
;;;645    
;;;646    void I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;647    {
;;;648        uint32_t u32Div, u32Pclk_kHz;
;;;649    
;;;650        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000002  f4237300          BIC      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;651    
;;;652        /* DIV4 disabled */
;;;653        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000008  6943              LDR      r3,[r0,#0x14]
00000a  f0230304          BIC      r3,r3,#4
00000e  6143              STR      r3,[r0,#0x14]
;;;654        u32Pclk_kHz = u32Pclk / 1000U;
000010  f44f737a          MOV      r3,#0x3e8
000014  fbb2f2f3          UDIV     r2,r2,r3
;;;655        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000018  4351              MULS     r1,r2,r1
00001a  f04f33ff          MOV      r3,#0xffffffff
00001e  eb033291          ADD      r2,r3,r1,LSR #14
;;;656        if(u32Div <= 0xFFU)
000022  2aff              CMP      r2,#0xff
000024  d801              BHI      |L21.42|
;;;657        {
;;;658            i2c->CLKTOUT = u32Div;
000026  6682              STR      r2,[r0,#0x68]
;;;659        }
;;;660        else
;;;661        {
;;;662            /* DIV4 enabled */
;;;663            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;664            i2c->CLKTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
;;;665        }
;;;666    }
000028  4770              BX       lr
                  |L21.42|
00002a  6942              LDR      r2,[r0,#0x14]         ;663
00002c  f0420204          ORR      r2,r2,#4              ;663
000030  6142              STR      r2,[r0,#0x14]         ;663
000032  eb034111          ADD      r1,r3,r1,LSR #16      ;664
000036  b2c9              UXTB     r1,r1                 ;664
000038  6681              STR      r1,[r0,#0x68]         ;664
00003a  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.I2C_SMBusClose||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClose PROC
;;;518     */
;;;519    void I2C_SMBusClose(I2C_T *i2c)
000000  2100              MOVS     r1,#0
;;;520    {
;;;521    
;;;522        i2c->BUSCTL = 0x00U;
000002  6501              STR      r1,[r0,#0x50]
;;;523    }
000004  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.I2C_SMBusGetPECValue||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetPECValue PROC
;;;559     */
;;;560    uint8_t I2C_SMBusGetPECValue(I2C_T *i2c)
000000  6e00              LDR      r0,[r0,#0x60]
;;;561    {
;;;562        return (uint8_t)i2c->PKTCRC;
000002  b2c0              UXTB     r0,r0
;;;563    }
000004  4770              BX       lr
;;;564    
                          ENDP


                          AREA ||i.I2C_SMBusGetStatus||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetStatus PROC
;;;444     */
;;;445    uint32_t I2C_SMBusGetStatus(I2C_T *i2c)
000000  6d80              LDR      r0,[r0,#0x58]
;;;446    {
;;;447        return (i2c->BUSSTS);
;;;448    }
000002  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.I2C_SMBusIdleTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusIdleTimeout PROC
;;;577    
;;;578    void I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;579    {
;;;580        uint32_t  u32Div, u32Hclk_kHz;
;;;581    
;;;582        i2c->BUSCTL |= I2C_BUSCTL_TIDLE_Msk;
000002  f4437300          ORR      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;583        u32Hclk_kHz = u32Hclk / 1000U;
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb2f2f3          UDIV     r2,r2,r3
;;;584        u32Div = (((us * u32Hclk_kHz) / 1000U) >> 2U) - 1U;
000010  4351              MULS     r1,r2,r1
000012  fbb1f1f3          UDIV     r1,r1,r3
000016  f04f32ff          MOV      r2,#0xffffffff
00001a  eb020191          ADD      r1,r2,r1,LSR #2
;;;585        if(u32Div > 255U)
00001e  29ff              CMP      r1,#0xff
000020  d900              BLS      |L25.36|
;;;586        {
;;;587            i2c->BUSTOUT = 0xFFU;
000022  21ff              MOVS     r1,#0xff
                  |L25.36|
;;;588        }
;;;589        else
;;;590        {
;;;591            i2c->BUSTOUT = u32Div;
000024  6641              STR      r1,[r0,#0x64]
;;;592        }
;;;593    
;;;594    }
000026  4770              BX       lr
;;;595    
                          ENDP


                          AREA ||i.I2C_SMBusOpen||, CODE, READONLY, ALIGN=1

                  I2C_SMBusOpen PROC
;;;492     */
;;;493    void I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice)
000000  6d02              LDR      r2,[r0,#0x50]
;;;494    {
;;;495        /* Clear  BMHEN, BMDEN of BUSCTL Register */
;;;496        i2c->BUSCTL &=  ~(I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BMDEN_Msk);
000002  f022020c          BIC      r2,r2,#0xc
000006  6502              STR      r2,[r0,#0x50]
;;;497    
;;;498        /* Set SMBus Host/Device Mode, and enable Bus Management*/
;;;499        if(u8HostDevice == (uint8_t)I2C_SMBH_ENABLE)
000008  2901              CMP      r1,#1
;;;500        {
;;;501            i2c->BUSCTL |= (I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BUSEN_Msk);
;;;502        }
;;;503        else
;;;504        {
;;;505            i2c->BUSCTL |= (I2C_BUSCTL_BMDEN_Msk | I2C_BUSCTL_BUSEN_Msk);
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d003              BEQ      |L26.22|
00000e  f0410184          ORR      r1,r1,#0x84
                  |L26.18|
000012  6501              STR      r1,[r0,#0x50]         ;501
;;;506        }
;;;507    }
000014  4770              BX       lr
                  |L26.22|
000016  f0410188          ORR      r1,r1,#0x88           ;501
00001a  e7fa              B        |L26.18|
;;;508    
                          ENDP


                          AREA ||i.I2C_SMBusPECTxEnable||, CODE, READONLY, ALIGN=1

                  I2C_SMBusPECTxEnable PROC
;;;535     */
;;;536    void I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn)
000000  6d02              LDR      r2,[r0,#0x50]
;;;537    {
;;;538        i2c->BUSCTL &= ~I2C_BUSCTL_PECTXEN_Msk;
000002  f4227280          BIC      r2,r2,#0x100
000006  6502              STR      r2,[r0,#0x50]
;;;539    
;;;540        if(u8PECTxEn)
000008  2900              CMP      r1,#0
;;;541        {
;;;542            i2c->BUSCTL |= (I2C_BUSCTL_PECEN_Msk | I2C_BUSCTL_PECTXEN_Msk);
;;;543        }
;;;544        else
;;;545        {
;;;546            i2c->BUSCTL |= I2C_BUSCTL_PECEN_Msk;
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d002              BEQ      |L27.20|
00000e  f4417181          ORR      r1,r1,#0x102          ;542
000012  e001              B        |L27.24|
                  |L27.20|
000014  f0410102          ORR      r1,r1,#2
                  |L27.24|
000018  6501              STR      r1,[r0,#0x50]         ;542
;;;547        }
;;;548    }
00001a  4770              BX       lr
;;;549    
                          ENDP


                          AREA ||i.I2C_SMBusSetPacketByteCount||, CODE, READONLY, ALIGN=1

                  I2C_SMBusSetPacketByteCount PROC
;;;476     */
;;;477    void I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize)
000000  65c1              STR      r1,[r0,#0x5c]
;;;478    {
;;;479        i2c->PKTSIZE = u32PktSize;
;;;480    }
000002  4770              BX       lr
;;;481    
                          ENDP


                          AREA ||i.I2C_SMBusTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusTimeout PROC
;;;609    
;;;610    void I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;611    {
;;;612        uint32_t u32Div, u32Pclk_kHz;
;;;613    
;;;614        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000002  f4237300          BIC      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;615    
;;;616        /* DIV4 disabled */
;;;617        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000008  6943              LDR      r3,[r0,#0x14]
00000a  f0230304          BIC      r3,r3,#4
00000e  6143              STR      r3,[r0,#0x14]
;;;618        u32Pclk_kHz = u32Pclk / 1000U;
000010  f44f737a          MOV      r3,#0x3e8
000014  fbb2f2f3          UDIV     r2,r2,r3
;;;619        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000018  4351              MULS     r1,r2,r1
00001a  f04f33ff          MOV      r3,#0xffffffff
00001e  eb033291          ADD      r2,r3,r1,LSR #14
;;;620        if(u32Div <= 0xFFU)
000022  2aff              CMP      r2,#0xff
000024  d801              BHI      |L29.42|
;;;621        {
;;;622            i2c->BUSTOUT = u32Div;
000026  6642              STR      r2,[r0,#0x64]
;;;623        }
;;;624        else
;;;625        {
;;;626            /* DIV4 enabled */
;;;627            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;628            i2c->BUSTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
;;;629        }
;;;630    }
000028  4770              BX       lr
                  |L29.42|
00002a  6942              LDR      r2,[r0,#0x14]         ;627
00002c  f0420204          ORR      r2,r2,#4              ;627
000030  6142              STR      r2,[r0,#0x14]         ;627
000032  eb034111          ADD      r1,r3,r1,LSR #16      ;628
000036  b2c9              UXTB     r1,r1                 ;628
000038  6641              STR      r1,[r0,#0x64]         ;628
00003a  4770              BX       lr
;;;631    
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;209     */
;;;210    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;211    {
000002  4604              MOV      r4,r0
;;;212        uint32_t u32Div;
;;;213        uint32_t u32Pclk;
;;;214    
;;;215        if(i2c == I2C1)
000004  480c              LDR      r0,|L30.56|
000006  460d              MOV      r5,r1                 ;211
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L30.18|
;;;216        {
;;;217            u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L30.22|
                  |L30.18|
;;;218        }
;;;219        else
;;;220        {
;;;221            u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L30.22|
;;;222        }
;;;223    
;;;224        u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000016  eb000180          ADD      r1,r0,r0,LSL #2
00001a  0049              LSLS     r1,r1,#1
00001c  00aa              LSLS     r2,r5,#2
00001e  fbb1f1f2          UDIV     r1,r1,r2
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
00002a  1e4a              SUBS     r2,r1,#1
;;;225        i2c->CLKDIV = u32Div;
00002c  6122              STR      r2,[r4,#0x10]
;;;226    
;;;227        return (u32Pclk / ((u32Div + 1U) << 2U));
;;;228    }
00002e  0089              LSLS     r1,r1,#2
000030  fbb0f0f1          UDIV     r0,r0,r1              ;227
000034  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

000036  0000              DCW      0x0000
                  |L30.56|
                          DCD      0x40081000

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;292     */
;;;293    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;294    {
;;;295        i2c->DAT = u8Data;
;;;296    }
000002  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;311     */
;;;312    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  ea430242          ORR      r2,r3,r2,LSL #1
;;;313    {
;;;314        switch(u8SlaveNo)
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L32.20|
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L32.24|
00000c  2903              CMP      r1,#3
00000e  d005              BEQ      |L32.28|
;;;315        {
;;;316        case 1:
;;;317            i2c->ADDR1  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;318            break;
;;;319        case 2:
;;;320            i2c->ADDR2  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;321            break;
;;;322        case 3:
;;;323            i2c->ADDR3  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;324            break;
;;;325        case 0:
;;;326        default:
;;;327            i2c->ADDR0  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;328            break;
;;;329        }
;;;330    }
000012  4770              BX       lr
                  |L32.20|
000014  6182              STR      r2,[r0,#0x18]         ;317
000016  4770              BX       lr
                  |L32.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;320
00001a  4770              BX       lr
                  |L32.28|
00001c  6202              STR      r2,[r0,#0x20]         ;323
00001e  4770              BX       lr
;;;331    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;343     */
;;;344    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;345    {
;;;346        switch(u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L33.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L33.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L33.26|
;;;347        {
;;;348        case 1:
;;;349            i2c->ADDRMSK1  = (uint32_t)u8SlaveAddrMask << 1U;
;;;350            break;
;;;351        case 2:
;;;352            i2c->ADDRMSK2  = (uint32_t)u8SlaveAddrMask << 1U;
;;;353            break;
;;;354        case 3:
;;;355            i2c->ADDRMSK3  = (uint32_t)u8SlaveAddrMask << 1U;
;;;356            break;
;;;357        case 0:
;;;358        default:
;;;359            i2c->ADDRMSK0  = (uint32_t)u8SlaveAddrMask << 1U;
00000e  6242              STR      r2,[r0,#0x24]
;;;360            break;
;;;361        }
;;;362    }
000010  4770              BX       lr
                  |L33.18|
000012  6282              STR      r2,[r0,#0x28]         ;349
000014  4770              BX       lr
                  |L33.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;352
000018  4770              BX       lr
                  |L33.26|
00001a  6302              STR      r2,[r0,#0x30]         ;355
00001c  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;116      */
;;;117    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119        uint32_t u32Reg = 0U;
000002  2400              MOVS     r4,#0
000004  9d03              LDR      r5,[sp,#0xc]          ;118
000006  b101              CBZ      r1,|L34.10|
;;;120    
;;;121        if(u8Start)
;;;122        {
;;;123            u32Reg |= I2C_CTL_STA;
000008  2420              MOVS     r4,#0x20
                  |L34.10|
;;;124        }
;;;125    
;;;126        if(u8Stop)
00000a  b10a              CBZ      r2,|L34.16|
;;;127        {
;;;128            u32Reg |= I2C_CTL_STO;
00000c  f0440410          ORR      r4,r4,#0x10
                  |L34.16|
;;;129        }
;;;130    
;;;131        if(u8Si)
000010  b10b              CBZ      r3,|L34.22|
;;;132        {
;;;133            u32Reg |= I2C_CTL_SI;
000012  f0440408          ORR      r4,r4,#8
                  |L34.22|
;;;134        }
;;;135    
;;;136        if(u8Ack)
000016  b10d              CBZ      r5,|L34.28|
;;;137        {
;;;138            u32Reg |= I2C_CTL_AA;
000018  f0440404          ORR      r4,r4,#4
                  |L34.28|
;;;139        }
;;;140    
;;;141        i2c->CTL0 = (i2c->CTL0 & ~0x3CU) | u32Reg;
00001c  6801              LDR      r1,[r0,#0]
00001e  f021013c          BIC      r1,r1,#0x3c
000022  4321              ORRS     r1,r1,r4
000024  6001              STR      r1,[r0,#0]
;;;142    }
000026  bd30              POP      {r4,r5,pc}
;;;143    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;682    
;;;683    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;684    {
;;;685        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;686    
;;;687        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;685
00000a  f0260608          BIC      r6,r6,#8
00000e  f0460620          ORR      r6,r6,#0x20
000012  6006              STR      r6,[r0,#0]
;;;688        while(u8Xfering && (u8Err == 0u))
;;;689        {
;;;690            I2C_WAIT_READY(i2c) {}
;;;691            switch(I2C_GET_STATUS(i2c))
;;;692            {
;;;693            case 0x08u:
;;;694                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
000014  0649              LSLS     r1,r1,#25
000016  0e0e              LSRS     r6,r1,#24
                  |L35.24|
000018  6801              LDR      r1,[r0,#0]            ;690
00001a  0709              LSLS     r1,r1,#28             ;690
00001c  d5fc              BPL      |L35.24|
00001e  68c1              LDR      r1,[r0,#0xc]          ;691
000020  2920              CMP      r1,#0x20              ;691
000022  d007              BEQ      |L35.52|
000024  dc04              BGT      |L35.48|
000026  2908              CMP      r1,#8                 ;691
000028  d007              BEQ      |L35.58|
00002a  2918              CMP      r1,#0x18              ;691
00002c  d102              BNE      |L35.52|
00002e  e007              B        |L35.64|
                  |L35.48|
000030  2928              CMP      r1,#0x28              ;691
000032  d007              BEQ      |L35.68|
                  |L35.52|
;;;695                u8Ctrl = I2C_CTL_SI;                              /* Clear SI */
;;;696                break;
;;;697            case 0x18u:                                           /* Slave Address ACK */
;;;698                I2C_SET_DATA(i2c, data);                          /* Write data to I2CDAT */
;;;699                break;
;;;700            case 0x20u:                                           /* Slave Address NACK */
;;;701            case 0x30u:                                           /* Master transmit data NACK */
;;;702                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
000034  2318              MOVS     r3,#0x18
;;;703                u8Err = 1u;
000036  2401              MOVS     r4,#1
;;;704                break;
000038  e006              B        |L35.72|
                  |L35.58|
00003a  6086              STR      r6,[r0,#8]            ;694
00003c  2308              MOVS     r3,#8                 ;695
00003e  e003              B        |L35.72|
                  |L35.64|
000040  6082              STR      r2,[r0,#8]            ;698
000042  e001              B        |L35.72|
                  |L35.68|
;;;705            case 0x28u:
;;;706                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
000044  2318              MOVS     r3,#0x18
;;;707                u8Xfering = 0u;
000046  2500              MOVS     r5,#0
                  |L35.72|
;;;708                break;
;;;709            case 0x38u:                                           /* Arbitration Lost */
;;;710            default:                                              /* Unknow status */
;;;711                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
;;;712                u8Err = 1u;
;;;713                break;
;;;714            }
;;;715            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000048  6801              LDR      r1,[r0,#0]
00004a  f021013c          BIC      r1,r1,#0x3c
00004e  4319              ORRS     r1,r1,r3
000050  6001              STR      r1,[r0,#0]
000052  b10d              CBZ      r5,|L35.88|
000054  2c00              CMP      r4,#0                 ;688
000056  d0df              BEQ      |L35.24|
                  |L35.88|
;;;716        }
;;;717        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000058  ea440005          ORR      r0,r4,r5
;;;718    }
00005c  bd70              POP      {r4-r6,pc}
;;;719    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;791    
;;;792    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;793    {
;;;794        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2600              MOVS     r6,#0
;;;795        uint32_t u32txLen = 0u;
;;;796    
;;;797        I2C_START(i2c);                                              /* Send START */
000006  6804              LDR      r4,[r0,#0]
000008  4635              MOV      r5,r6                 ;794
00000a  46b4              MOV      r12,r6                ;795
00000c  f0240408          BIC      r4,r4,#8
000010  f0440420          ORR      r4,r4,#0x20
000014  6004              STR      r4,[r0,#0]
                  |L36.22|
;;;798        while(u8Xfering && (u8Err == 0u))
;;;799        {
;;;800            I2C_WAIT_READY(i2c) {}
000016  6804              LDR      r4,[r0,#0]
000018  0724              LSLS     r4,r4,#28
00001a  d5fc              BPL      |L36.22|
;;;801            switch(I2C_GET_STATUS(i2c))
00001c  68c4              LDR      r4,[r0,#0xc]
00001e  2c20              CMP      r4,#0x20
000020  d007              BEQ      |L36.50|
000022  dc04              BGT      |L36.46|
000024  2c08              CMP      r4,#8
000026  d007              BEQ      |L36.56|
000028  2c18              CMP      r4,#0x18
00002a  d102              BNE      |L36.50|
00002c  e009              B        |L36.66|
                  |L36.46|
00002e  2c28              CMP      r4,#0x28
000030  d009              BEQ      |L36.70|
                  |L36.50|
;;;802            {
;;;803            case 0x08u:
;;;804                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Send Slave address with write bit */
;;;805                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;806                break;
;;;807            case 0x18u:                                           /* Slave Address ACK */
;;;808                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;809                break;
;;;810            case 0x20u:                                           /* Slave Address NACK */
;;;811            case 0x30u:                                           /* Master transmit data NACK */
;;;812                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000032  2518              MOVS     r5,#0x18
;;;813                u8Err = 1u;
000034  2601              MOVS     r6,#1
;;;814                break;
000036  e00b              B        |L36.80|
                  |L36.56|
000038  064c              LSLS     r4,r1,#25             ;804
00003a  0e24              LSRS     r4,r4,#24             ;804
00003c  6084              STR      r4,[r0,#8]            ;804
00003e  2508              MOVS     r5,#8                 ;805
000040  e006              B        |L36.80|
                  |L36.66|
000042  6082              STR      r2,[r0,#8]            ;808
000044  e004              B        |L36.80|
                  |L36.70|
;;;815            case 0x28u:
;;;816                if(u32txLen < 1u)
000046  f1bc0f00          CMP      r12,#0
00004a  d00c              BEQ      |L36.102|
;;;817                {
;;;818                    I2C_SET_DATA(i2c, data);
;;;819                    u32txLen++;
;;;820                }
;;;821                else
;;;822                {
;;;823                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
00004c  2518              MOVS     r5,#0x18
;;;824                    u8Xfering = 0u;
00004e  2700              MOVS     r7,#0
                  |L36.80|
;;;825                }
;;;826                break;
;;;827            case 0x38u:                                           /* Arbitration Lost */
;;;828            default:                                             /* Unknow status */
;;;829                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;830                u8Err = 1u;
;;;831                break;
;;;832            }
;;;833            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000050  6804              LDR      r4,[r0,#0]
000052  f024043c          BIC      r4,r4,#0x3c
000056  432c              ORRS     r4,r4,r5
000058  6004              STR      r4,[r0,#0]
00005a  b10f              CBZ      r7,|L36.96|
00005c  2e00              CMP      r6,#0                 ;798
00005e  d0da              BEQ      |L36.22|
                  |L36.96|
;;;834        }
;;;835        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000060  ea460007          ORR      r0,r6,r7
;;;836    }
000064  bdf0              POP      {r4-r7,pc}
                  |L36.102|
000066  6083              STR      r3,[r0,#8]            ;818
000068  f04f0c01          MOV      r12,#1                ;819
00006c  e7f0              B        |L36.80|
;;;837    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;914    
;;;915    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;916    {
;;;917        uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000002  2701              MOVS     r7,#1
000004  2600              MOVS     r6,#0
;;;918        uint32_t u32txLen = 0u;
;;;919    
;;;920        I2C_START(i2c);                                                         /* Send START */
000006  6804              LDR      r4,[r0,#0]
000008  46be              MOV      lr,r7                 ;917
00000a  4635              MOV      r5,r6                 ;917
00000c  46b4              MOV      r12,r6                ;918
00000e  f0240408          BIC      r4,r4,#8
000012  f0440420          ORR      r4,r4,#0x20
000016  6004              STR      r4,[r0,#0]
                  |L37.24|
;;;921        while(u8Xfering && (u8Err == 0u))
;;;922        {
;;;923            I2C_WAIT_READY(i2c) {}
000018  6804              LDR      r4,[r0,#0]
00001a  0724              LSLS     r4,r4,#28
00001c  d5fc              BPL      |L37.24|
;;;924            switch(I2C_GET_STATUS(i2c))
00001e  68c4              LDR      r4,[r0,#0xc]
000020  2c20              CMP      r4,#0x20
000022  d007              BEQ      |L37.52|
000024  dc04              BGT      |L37.48|
000026  2c08              CMP      r4,#8
000028  d007              BEQ      |L37.58|
00002a  2c18              CMP      r4,#0x18
00002c  d102              BNE      |L37.52|
00002e  e009              B        |L37.68|
                  |L37.48|
000030  2c28              CMP      r4,#0x28
000032  d00a              BEQ      |L37.74|
                  |L37.52|
;;;925            {
;;;926            case 0x08u:
;;;927                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
;;;928                u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;929                break;
;;;930            case 0x18u:                                                      /* Slave Address ACK */
;;;931                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
;;;932                break;
;;;933            case 0x20u:                                                      /* Slave Address NACK */
;;;934            case 0x30u:                                                      /* Master transmit data NACK */
;;;935                u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000034  2518              MOVS     r5,#0x18
;;;936                u8Err = 1u;
000036  2601              MOVS     r6,#1
;;;937                break;
000038  e014              B        |L37.100|
                  |L37.58|
00003a  064c              LSLS     r4,r1,#25             ;927
00003c  0e24              LSRS     r4,r4,#24             ;927
00003e  6084              STR      r4,[r0,#8]            ;927
000040  2508              MOVS     r5,#8                 ;928
000042  e00f              B        |L37.100|
                  |L37.68|
000044  0a14              LSRS     r4,r2,#8              ;931
000046  6084              STR      r4,[r0,#8]            ;931
000048  e00c              B        |L37.100|
                  |L37.74|
;;;938            case 0x28u:
;;;939                if(u8Addr)
00004a  f1be0f00          CMP      lr,#0
00004e  d004              BEQ      |L37.90|
;;;940                {
;;;941                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
000050  b2d4              UXTB     r4,r2
000052  6084              STR      r4,[r0,#8]
;;;942                    u8Addr = 0u;
000054  f04f0e00          MOV      lr,#0
000058  e004              B        |L37.100|
                  |L37.90|
;;;943                }
;;;944                else if((u32txLen < 1u) && (u8Addr == 0u))
00005a  f1bc0f00          CMP      r12,#0
00005e  d00c              BEQ      |L37.122|
;;;945                {
;;;946                    I2C_SET_DATA(i2c, data);
;;;947                    u32txLen++;
;;;948                }
;;;949                else
;;;950                {
;;;951                    u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
000060  2518              MOVS     r5,#0x18
;;;952                    u8Xfering = 0u;
000062  2700              MOVS     r7,#0
                  |L37.100|
;;;953                }
;;;954                break;
;;;955            case 0x38u:                                                      /* Arbitration Lost */
;;;956            default:                                                        /* Unknow status */
;;;957                u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;958                u8Err = 1u;
;;;959                break;
;;;960            }
;;;961            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000064  6804              LDR      r4,[r0,#0]
000066  f024043c          BIC      r4,r4,#0x3c
00006a  432c              ORRS     r4,r4,r5
00006c  6004              STR      r4,[r0,#0]
00006e  b10f              CBZ      r7,|L37.116|
000070  2e00              CMP      r6,#0                 ;921
000072  d0d1              BEQ      |L37.24|
                  |L37.116|
;;;962        }
;;;963        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
000074  ea460007          ORR      r0,r6,r7
;;;964    }
000078  bdf0              POP      {r4-r7,pc}
                  |L37.122|
00007a  6083              STR      r3,[r0,#8]            ;946
00007c  f04f0c01          MOV      r12,#1                ;947
000080  e7f0              B        |L37.100|
;;;965    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;733    
;;;734    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;735    {
;;;736        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2700              MOVS     r7,#0
;;;737        uint32_t u32txLen = 0u;
;;;738    
;;;739        I2C_START(i2c);                                              /* Send START */
000004  6804              LDR      r4,[r0,#0]
000006  f04f0c01          MOV      r12,#1                ;736
00000a  463d              MOV      r5,r7                 ;736
00000c  463e              MOV      r6,r7                 ;737
00000e  f0240408          BIC      r4,r4,#8
000012  f0440420          ORR      r4,r4,#0x20
000016  6004              STR      r4,[r0,#0]
                  |L38.24|
;;;740        while(u8Xfering && (u8Err == 0u))
;;;741        {
;;;742            I2C_WAIT_READY(i2c) {}
000018  6804              LDR      r4,[r0,#0]
00001a  0724              LSLS     r4,r4,#28
00001c  d5fc              BPL      |L38.24|
;;;743            switch(I2C_GET_STATUS(i2c))
00001e  68c4              LDR      r4,[r0,#0xc]
000020  2c20              CMP      r4,#0x20
000022  d007              BEQ      |L38.52|
000024  dc04              BGT      |L38.48|
000026  2c08              CMP      r4,#8
000028  d012              BEQ      |L38.80|
00002a  2c18              CMP      r4,#0x18
00002c  d102              BNE      |L38.52|
00002e  e014              B        |L38.90|
                  |L38.48|
000030  2c28              CMP      r4,#0x28
000032  d012              BEQ      |L38.90|
                  |L38.52|
;;;744            {
;;;745            case 0x08u:
;;;746                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;747                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;748                break;
;;;749            case 0x18u:                                           /* Slave Address ACK */
;;;750            case 0x28u:
;;;751                if(u32txLen < u32wLen)
;;;752                {
;;;753                    I2C_SET_DATA(i2c, data[u32txLen++]);                /* Write Data to I2CDAT */
;;;754                }
;;;755                else
;;;756                {
;;;757                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;758                    u8Xfering = 0u;
;;;759                }
;;;760                break;
;;;761            case 0x20u:                                           /* Slave Address NACK */
;;;762            case 0x30u:                                           /* Master transmit data NACK */
;;;763                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000034  2518              MOVS     r5,#0x18
;;;764                u8Err = 1u;
000036  2701              MOVS     r7,#1
                  |L38.56|
;;;765                break;
;;;766            case 0x38u:                                           /* Arbitration Lost */
;;;767            default:                                             /* Unknow status */
;;;768                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;769                u8Err = 1u;
;;;770                break;
;;;771            }
;;;772            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000038  6804              LDR      r4,[r0,#0]
00003a  f024043c          BIC      r4,r4,#0x3c
00003e  432c              ORRS     r4,r4,r5
000040  6004              STR      r4,[r0,#0]
000042  f1bc0f00          CMP      r12,#0                ;740
000046  d001              BEQ      |L38.76|
000048  2f00              CMP      r7,#0                 ;740
00004a  d0e5              BEQ      |L38.24|
                  |L38.76|
;;;773        }
;;;774        return u32txLen;                                             /* Return bytes length that have been transmitted */
00004c  4630              MOV      r0,r6
;;;775    }
00004e  bdf0              POP      {r4-r7,pc}
                  |L38.80|
000050  064c              LSLS     r4,r1,#25             ;746
000052  0e24              LSRS     r4,r4,#24             ;746
000054  6084              STR      r4,[r0,#8]            ;746
000056  2508              MOVS     r5,#8                 ;747
000058  e7ee              B        |L38.56|
                  |L38.90|
00005a  429e              CMP      r6,r3                 ;751
00005c  d203              BCS      |L38.102|
00005e  5d94              LDRB     r4,[r2,r6]            ;753
000060  6084              STR      r4,[r0,#8]            ;753
000062  1c76              ADDS     r6,r6,#1              ;753
000064  e7e8              B        |L38.56|
                  |L38.102|
000066  2518              MOVS     r5,#0x18              ;757
000068  f04f0c00          MOV      r12,#0                ;758
00006c  e7e4              B        |L38.56|
;;;776    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;853    
;;;854    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;855    {
;;;856        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000002  2700              MOVS     r7,#0
;;;857        uint32_t u32txLen = 0u;
;;;858    
;;;859        I2C_START(i2c);                                              /* Send START */
000004  f8dde014          LDR      lr,[sp,#0x14]
000008  6804              LDR      r4,[r0,#0]
00000a  f04f0c01          MOV      r12,#1                ;856
00000e  463d              MOV      r5,r7                 ;856
000010  463e              MOV      r6,r7                 ;857
000012  f0240408          BIC      r4,r4,#8
000016  f0440420          ORR      r4,r4,#0x20
00001a  6004              STR      r4,[r0,#0]
                  |L39.28|
;;;860        while(u8Xfering && (u8Err == 0u))
;;;861        {
;;;862            I2C_WAIT_READY(i2c) {}
00001c  6804              LDR      r4,[r0,#0]
00001e  0724              LSLS     r4,r4,#28
000020  d5fc              BPL      |L39.28|
;;;863            switch(I2C_GET_STATUS(i2c))
000022  68c4              LDR      r4,[r0,#0xc]
000024  2c20              CMP      r4,#0x20
000026  d007              BEQ      |L39.56|
000028  dc04              BGT      |L39.52|
00002a  2c08              CMP      r4,#8
00002c  d007              BEQ      |L39.62|
00002e  2c18              CMP      r4,#0x18
000030  d102              BNE      |L39.56|
000032  e009              B        |L39.72|
                  |L39.52|
000034  2c28              CMP      r4,#0x28
000036  d009              BEQ      |L39.76|
                  |L39.56|
;;;864            {
;;;865            case 0x08u:
;;;866                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;867                u8Ctrl = I2C_CTL_SI;
;;;868                break;
;;;869            case 0x18u:                                           /* Slave Address ACK */
;;;870                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;871                break;
;;;872            case 0x20u:                                           /* Slave Address NACK */
;;;873            case 0x30u:                                           /* Master transmit data NACK */
;;;874                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000038  2518              MOVS     r5,#0x18
;;;875                u8Err = 1u;
00003a  2701              MOVS     r7,#1
;;;876                break;
00003c  e00f              B        |L39.94|
                  |L39.62|
00003e  064c              LSLS     r4,r1,#25             ;866
000040  0e24              LSRS     r4,r4,#24             ;866
000042  6084              STR      r4,[r0,#8]            ;866
000044  2508              MOVS     r5,#8                 ;867
000046  e00a              B        |L39.94|
                  |L39.72|
000048  6082              STR      r2,[r0,#8]            ;870
00004a  e008              B        |L39.94|
                  |L39.76|
;;;877            case 0x28u:
;;;878                if(u32txLen < u32wLen)
00004c  4576              CMP      r6,lr
00004e  d203              BCS      |L39.88|
;;;879                {
;;;880                    I2C_SET_DATA(i2c, data[u32txLen++]);
000050  5d9c              LDRB     r4,[r3,r6]
000052  6084              STR      r4,[r0,#8]
000054  1c76              ADDS     r6,r6,#1
000056  e002              B        |L39.94|
                  |L39.88|
;;;881                }
;;;882                else
;;;883                {
;;;884                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
000058  2518              MOVS     r5,#0x18
;;;885                    u8Xfering = 0u;
00005a  f04f0c00          MOV      r12,#0
                  |L39.94|
;;;886                }
;;;887                break;
;;;888            case 0x38u:                                           /* Arbitration Lost */
;;;889            default:                                             /* Unknow status */
;;;890                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;891                u8Err = 1u;
;;;892                break;
;;;893            }
;;;894            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00005e  6804              LDR      r4,[r0,#0]
000060  f024043c          BIC      r4,r4,#0x3c
000064  432c              ORRS     r4,r4,r5
000066  6004              STR      r4,[r0,#0]
000068  f1bc0f00          CMP      r12,#0                ;860
00006c  d001              BEQ      |L39.114|
00006e  2f00              CMP      r7,#0                 ;860
000070  d0d4              BEQ      |L39.28|
                  |L39.114|
;;;895        }
;;;896    
;;;897        return u32txLen;                                             /* Return bytes length that have been transmitted */
000072  4630              MOV      r0,r6
;;;898    }
000074  bdf0              POP      {r4-r7,pc}
;;;899    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;981    
;;;982    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;983    {
;;;984        uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2700              MOVS     r7,#0
000006  f04f0801          MOV      r8,#1
;;;985        uint32_t u32txLen = 0u;
;;;986    
;;;987        I2C_START(i2c);                                                         /* Send START */
00000a  f8dd901c          LDR      r9,[sp,#0x1c]
00000e  6804              LDR      r4,[r0,#0]
000010  46c4              MOV      r12,r8                ;984
000012  463d              MOV      r5,r7                 ;984
000014  463e              MOV      r6,r7                 ;985
000016  f0240408          BIC      r4,r4,#8
00001a  f0440420          ORR      r4,r4,#0x20
00001e  6004              STR      r4,[r0,#0]
                  |L40.32|
;;;988        while(u8Xfering && (u8Err == 0u))
;;;989        {
;;;990            I2C_WAIT_READY(i2c) {}
000020  6804              LDR      r4,[r0,#0]
000022  0724              LSLS     r4,r4,#28
000024  d5fc              BPL      |L40.32|
;;;991            switch(I2C_GET_STATUS(i2c))
000026  68c4              LDR      r4,[r0,#0xc]
000028  2c20              CMP      r4,#0x20
00002a  d007              BEQ      |L40.60|
00002c  dc04              BGT      |L40.56|
00002e  2c08              CMP      r4,#8
000030  d007              BEQ      |L40.66|
000032  2c18              CMP      r4,#0x18
000034  d102              BNE      |L40.60|
000036  e009              B        |L40.76|
                  |L40.56|
000038  2c28              CMP      r4,#0x28
00003a  d00a              BEQ      |L40.82|
                  |L40.60|
;;;992            {
;;;993            case 0x08u:
;;;994                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
;;;995                u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;996                break;
;;;997            case 0x18u:                                                      /* Slave Address ACK */
;;;998                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
;;;999                break;
;;;1000           case 0x20u:                                                      /* Slave Address NACK */
;;;1001           case 0x30u:                                                      /* Master transmit data NACK */
;;;1002               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00003c  2518              MOVS     r5,#0x18
;;;1003               u8Err = 1u;
00003e  2701              MOVS     r7,#1
;;;1004               break;
000040  e018              B        |L40.116|
                  |L40.66|
000042  064c              LSLS     r4,r1,#25             ;994
000044  0e24              LSRS     r4,r4,#24             ;994
000046  6084              STR      r4,[r0,#8]            ;994
000048  2508              MOVS     r5,#8                 ;995
00004a  e013              B        |L40.116|
                  |L40.76|
00004c  0a14              LSRS     r4,r2,#8              ;998
00004e  6084              STR      r4,[r0,#8]            ;998
000050  e010              B        |L40.116|
                  |L40.82|
;;;1005           case 0x28u:
;;;1006               if(u8Addr)
000052  f1bc0f00          CMP      r12,#0
000056  d004              BEQ      |L40.98|
;;;1007               {
;;;1008                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
000058  b2d4              UXTB     r4,r2
00005a  6084              STR      r4,[r0,#8]
;;;1009                   u8Addr = 0u;
00005c  f04f0c00          MOV      r12,#0
000060  e008              B        |L40.116|
                  |L40.98|
;;;1010               }
;;;1011               else if((u32txLen < u32wLen) && (u8Addr == 0u))
000062  454e              CMP      r6,r9
000064  d203              BCS      |L40.110|
;;;1012               {
;;;1013                   I2C_SET_DATA(i2c, data[u32txLen++]);                           /* Write data to Register I2CDAT*/
000066  5d9c              LDRB     r4,[r3,r6]
000068  6084              STR      r4,[r0,#8]
00006a  1c76              ADDS     r6,r6,#1
00006c  e002              B        |L40.116|
                  |L40.110|
;;;1014               }
;;;1015               else
;;;1016               {
;;;1017                   u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
00006e  2518              MOVS     r5,#0x18
;;;1018                   u8Xfering = 0u;
000070  f04f0800          MOV      r8,#0
                  |L40.116|
;;;1019               }
;;;1020               break;
;;;1021           case 0x38u:                                                      /* Arbitration Lost */
;;;1022           default:                                                        /* Unknow status */
;;;1023               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1024               u8Err = 1u;
;;;1025               break;
;;;1026           }
;;;1027           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000074  6804              LDR      r4,[r0,#0]
000076  f024043c          BIC      r4,r4,#0x3c
00007a  432c              ORRS     r4,r4,r5
00007c  6004              STR      r4,[r0,#0]
00007e  f1b80f00          CMP      r8,#0                 ;988
000082  d001              BEQ      |L40.136|
000084  2f00              CMP      r7,#0                 ;988
000086  d0cb              BEQ      |L40.32|
                  |L40.136|
;;;1028       }
;;;1029       return u32txLen;                                                        /* Return bytes length that have been transmitted */
000088  4630              MOV      r0,r6
;;;1030   }
00008a  e8bd83f0          POP      {r4-r9,pc}
;;;1031   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____RRX|
#line 587
|__asm___5_i2c_c_I2C_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
